[{"authors":["youngfar"],"categories":null,"content":"","date":1554595200,"expirydate":-62135596800,"kind":"taxonomy","lang":"zh","lastmod":1554595200,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://strivefar.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"","tags":null,"title":"YoungFar","type":"authors"},{"authors":null,"categories":null,"content":"Flexibility This feature can be used for publishing content such as:\n Online courses Project or software documentation Tutorials  The courses folder may be renamed. For example, we can rename it to docs for software/project documentation or tutorials for creating an online course.\nDelete tutorials To remove these pages, delete the courses folder and see below to delete the associated menu link.\nUpdate site menu After renaming or deleting the courses folder, you may wish to update any [[main]] menu links to it by editing your menu configuration at config/_default/menus.toml.\nFor example, if you delete this folder, you can remove the following from your menu configuration:\n[[main]] name = \u0026quot;Courses\u0026quot; url = \u0026quot;courses/\u0026quot; weight = 50  Or, if you are creating a software documentation site, you can rename the courses folder to docs and update the associated Courses menu configuration to:\n[[main]] name = \u0026quot;Docs\u0026quot; url = \u0026quot;docs/\u0026quot; weight = 50  Update the docs menu If you use the docs layout, note that the name of the menu in the front matter should be in the form [menu.X] where X is the folder name. Hence, if you rename the courses/example/ folder, you should also rename the menu definitions in the front matter of files within courses/example/ from [menu.example] to [menu.\u0026lt;NewFolderName\u0026gt;].\n","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1536451200,"objectID":"59c3ce8e202293146a8a934d37a4070b","permalink":"https://strivefar.github.io/courses/example/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/courses/example/","section":"courses","summary":"正在努力学习中...","tags":null,"title":"Overview","type":"docs"},{"authors":null,"categories":null,"content":"In this tutorial, I\u0026rsquo;ll share my top 10 tips for getting started with Academic:\nTip 1 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\nTip 2 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"74533bae41439377bd30f645c4677a27","permalink":"https://strivefar.github.io/courses/example/example1/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/courses/example/example1/","section":"courses","summary":"In this tutorial, I\u0026rsquo;ll share my top 10 tips for getting started with Academic:\nTip 1 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim.","tags":null,"title":"Example Page 1","type":"docs"},{"authors":null,"categories":null,"content":"Here are some more tips for getting started with Academic:\nTip 3 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\nTip 4 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"1c2b5a11257c768c90d5050637d77d6a","permalink":"https://strivefar.github.io/courses/example/example2/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/courses/example/example2/","section":"courses","summary":"Here are some more tips for getting started with Academic:\nTip 3 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus.","tags":null,"title":"Example Page 2","type":"docs"},{"authors":[],"categories":null,"content":" Click on the Slides button above to view the built-in slides feature.   Slides can be added in a few ways:\n Create slides using Academic\u0026rsquo;s Slides feature and link using slides parameter in the front matter of the talk file Upload an existing slide deck to static/ and link using url_slides parameter in the front matter of the talk file Embed your slides (e.g. Google Slides) or presentation video on this page using shortcodes.  Further talk details can easily be added to this page using Markdown and $\\rm \\LaTeX$ math code.\n","date":1906549200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1906549200,"objectID":"96344c08df50a1b693cc40432115cbe3","permalink":"https://strivefar.github.io/talk/example/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/talk/example/","section":"talk","summary":"An example talk using Academic's Markdown slides feature.","tags":[],"title":"Example Talk","type":"talk"},{"authors":["youngfar"],"categories":[],"content":"auto 关键字  auto即C语言中局部变量的默认属性 auto表明将被修饰的变量存储于栈上 编译器默认所有的局部变量都是auto的 示例：  void f() { int i; //局部变量默认属性为 auto auto int j; //显示声明 auto 属性 }  register 关键字 用于向编译器申请在CPU寄存器上分配空间，以实现高速访问，但是要注意，申请不一定能成功，因为占用CPU寄存器是一件花销很大的事情，ARM算上影子寄存器加起来总共37个，下面我们看一下什么情况下编译器会拒绝该申请。\n#include \u0026lt;stdio.h\u0026gt; register unsigned int a; int main() { register unsigned int i; printf(\u0026quot;\u0026amp;i = %p\\n\u0026quot;, \u0026amp;i);] return 0; }  对于全局变量，在程序的整个运行期间内始终存活，编译器一旦允许，则会长时间的占用CPU寄存器，所以这种情况编译器直接拒绝了\n不能用 \u0026amp; 符获取register变量地址，地址是相对内存而言的，CPU寄存器尽管可以记录内存地址信息，但CPU寄存器本身没有地址的概念。\n上述两处错误给出提示如下：\n4-1.c: In function ‘main’: 4-1.c:9:5: error: address of register variable ‘i’ requested printf(\u0026quot;\u0026amp;i = %p\\n\u0026quot;, \u0026amp;i);] ^~~~~~ 4-1.c:9:29: error: expected statement before ‘]’ token printf(\u0026quot;\u0026amp;i = %p\\n\u0026quot;, \u0026amp;i);] ^ 4-1.c: At top level: 4-1.c:3:23: error: register name not specified for ‘a’ register unsigned int a; ^  所以对于register关键字，现总结如下：\n register关键字指明将局部变量存储于寄存器中 register只是请求寄存器变量，但不一定请求成功 register变量的必须是CPU寄存器可以接受的值 不能用\u0026amp;运算符获取register变量的地址  static关键字 这个在以前的博客中做过详细讨论，\n这里仅给出以下特性：\n static关键字指明变量的“静态”属性 static修饰的局部变量存储在程序静态区 static关键字同时具有“作用域限定符”的意义   static修饰的全局变量作用域只是声明的文件中     static修饰的函数作用域只是声明的文件中    ","date":1599639971,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1599639971,"objectID":"3d2222f646ae58b3d16c75742e3f2524","permalink":"https://strivefar.github.io/project/post/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","publishdate":"2020-09-09T16:26:11+08:00","relpermalink":"/project/post/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","section":"project","summary":"auto 关键字 auto即C语言中局部变量的默认属性 auto表明将被修饰的变量存储于栈上 编译器默认所有的局部变量都是auto的 示例： void f() { int i; //局","tags":["C"],"title":"类型转换","type":"project"},{"authors":["youngfar"],"categories":[],"content":" 1. C++中的 bool 类型  1.1. bool 类型参与数学运算（不建议但允许）   2. C++中的引用  2.1. C++对三目运算符的升级    1. C++中的 bool 类型 特点：\n bool 可取的值只有true 和 false 理论上bool只占用一个字节  注意：\ntrue 代表真值，编译器内部用 1 来表示 false 代表非真值，编译器内部用 0 来表示  1.1. bool 类型参与数学运算（不建议但允许） 为了兼容C语言，c++中的bool类型可以进行数学运算，g++编译器当遇到bool类型参与数学运算时，直接将其当做一个只占用一个字节的整型数来处理，但是会将最终的结果按照以下规则进行转换：\n 将非零值用true（1）来代替 将零值用 false（0）来代替  示例1：\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { bool b = false; printf(\u0026quot;sizeof(b) = %d\\n\u0026quot;, sizeof(b)); printf(\u0026quot;b = %d\\n\u0026quot;, b); b++; // b = 1; =\u0026gt; 非零值; printf(\u0026quot;b = %d\\n\u0026quot;, b); b = b - 3;// b = 1 - 3 = -2 =\u0026gt; 非零值; printf(\u0026quot;b = %d\\n\u0026quot;, b); return 0; }  编译：\ng++ -o test 4-1.cpp -m32 4-1.cpp: In function ‘int main(int, char**)’: 4-1.cpp:8:6: warning: use of an operand of type ‘bool’ in ‘operator++’ is deprecated [-Wdeprecated] b++; ^~  可见：编译器给出了警告，bool 类型参与数学运算，编译器的态度是不建议但允许\n运行:\n./test  输出结果如下：\nsizeof(b) = 1 b = 0 b = 1 b = 1  示例2：\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { bool b = false; int a = b; printf(\u0026quot;sizeof(b) = %d\\n\u0026quot;, sizeof(b)); printf(\u0026quot;b = %d, a = %d\\n\u0026quot;, b, a); b = 3; a = b; printf(\u0026quot;b = %d, a = %d\\n\u0026quot;, b, a); b = -5; a = b; printf(\u0026quot;b = %d, a = %d\\n\u0026quot;, b, a); a = 10; b = a; printf(\u0026quot;b = %d, a = %d\\n\u0026quot;, b, a); a = 0; b = a; printf(\u0026quot;b = %d, a = %d\\n\u0026quot;, b, a); return 0; }  编译：\ng++ -o test 4-2.cpp -m32  运行：\n./test  输出结果如下：\nsizeof(b) = 1 b = 0, a = 0 b = 1, a = 1 b = 1, a = 1 b = 1, a = 10 b = 0, a = 0  2. C++中的引用 在讨论引用之前，我们先来明确几个概念：\n 变量是一段实际连续存储空间的别名 程序中通过变量来申请并命名存储空间 通过变量的名字可以使用存储空间  但一段连续的存储空间不止可以有一个别名\n于是在C++中新增加了引用的概念\n  引用可以看作一个已定义变量的别名\n  引用的语法:\nType \u0026amp; name = var;    注意： C++是强类型的，普通引用在定义时必须用同类型的变量进行初始化。\n  2.1. C++对三目运算符的升级  当三目运算符的可能返回都是变量时，返回的是变量的引用 当三目运算符的可能返回中有常量时，返回的是值  示例3： 4-3.cpp\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { int a = 1; int b = 2; float f = 0.123f; float \u0026amp;f_quote = f; printf(\u0026quot;f = %f, f_quote= %f\\n\u0026quot;, f, f_quote); printf(\u0026quot;\u0026amp;f = %p, \u0026amp;f_quote = %p\\n\u0026quot;, \u0026amp;f, \u0026amp;f_quote); (a \u0026lt; b ? a : b) = 3; //正确，返回a或b的引用，可作为左值 printf(\u0026quot;a = %d, b = %d\\n\u0026quot;, a, b); //printf(a \u0026lt; b ? 1 : b); //错误，返回1或b的值，不能作为左值 return 0; }  编译运行：\ngcc -o test 4-3.cpp -m32 ./test f = 0.123000, f_quote= 0.123000 \u0026amp;f = 0xfff78cec, \u0026amp;f_quote = 0xfff78cec a = 3, b = 2  注意：这里三目运算符的可能返回都是变量，返回的是变量的引用，也就是a的引用，也就是a的另外一个名字，我们先不管a变量空间的另外一个名字是啥，从概念上我们很容易知道，a的引用就是a变量本身\n仅保留三目运算符相关代码，将文件后缀改为.c 编译报错如下：\ngcc -o test 4-3.c -m32 4-3.c: In function ‘main’: 4-3.c:8:21: error: lvalue required as left operand of assignment (a \u0026lt; b ? a : b) = 3; //正确，返回a或b的引用，可作为左值 ^  由此可见： C语言不允许三目运算符做左值\n","date":1599440346,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1599440346,"objectID":"fb5547ed05f37a3f98a12d16b7faab57","permalink":"https://strivefar.github.io/project/post/%E7%AC%AC%E5%9B%9B%E8%AF%BE%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8/","publishdate":"2020-09-07T08:59:06+08:00","relpermalink":"/project/post/%E7%AC%AC%E5%9B%9B%E8%AF%BE%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8/","section":"project","summary":"1. C++中的 bool 类型 1.1. bool 类型参与数学运算（不建议但允许） 2. C++中的引用 2.1. C++对三目运算符的升级 1. C++中的 bool 类型 特点： bool 可取的值只有tru","tags":["plus_C"],"title":"布尔类型和引用","type":"project"},{"authors":["youngfar"],"categories":[],"content":" 1. 浮点数在内存中的存储方式 2. 浮点数存储示例  2.1. 实数8.25在内存中的float表示 2.2. 编程验证   3. 精度问题  3.1. 编程验证    1. 浮点数在内存中的存储方式 浮点数在内存中由以下三部分组成：\n 符号位 指数 尾数  无论是float类型还是double类型的数据，在计算机内部的表示方法是相同的，但由于所占的存储空间不同，其分别能够表示的数值范围和精度不同。\n   类型 符号位 指数 尾数     float 1位（第31位） 8位（第23~30位） 23位（第0~22位）   double 1位（第63位） 11位（第52~62位） 52位（第0~51位）    2. 浮点数存储示例 浮点数的转换\n   将浮点数转换成二进制    用科学计数法表示二进制浮点数    计算指数偏移后的值    注意∶\n   计算指数时需要加上偏移量，而偏移量的值与类型有关。    对于指数6，偏移后的值如下：\nfloat : 127 + 6 = 123 double: 1023 + 6 = 1030    小数用二进制如何表示    首先，给出一个任意实数，整数部分用普通的二进制便可以表示，这里只说小数部分如何表示\n例如0.6\n文字描述该过程如下：将该数字乘以2，取出整数部分作为二进制表示的第1位；然后再将小数部分乘以2，将得到的整数部分作为二进制表示的第2位；以此类推，知道小数部分为0。\n特殊情况： 小数部分出现循环，无法停止，则用有限的二进制位无法准确表示一个小数，这也是在编程语言中表示小数会出现误差的原因\n下面我们具体计算一下0.6的小数表示过程\n0.6 * 2 = 1.2 ——————- 1 0.2 * 2 = 0.4 ——————- 0 0.4 * 2 = 0.8 ——————- 0 0.8 * 2 = 1.6 ——————- 1 0.6 * 2 = 1.2 ——————- 1 …………  我们可以发现在该计算中已经出现了循环，0.6用二进制表示为 1001 1001 1001 1001 …… 如果是10.6，那个10.6的完整二进制表示为 1010.100110011001……\n参考：https://blog.csdn.net/xingtanzjr/article/details/50803832\n2.1. 实数8.25在内存中的float表示 2.2. 编程验证 #include \u0026lt;stdio.h\u0026gt; /**功能：输出内存片段中的每一位的值 * 参数： * p :指向占1、2、4、8字节内存的变量的指针 * size ：变量在内存中所占的字节数 */ void put_bin(void *p, char size) { char i; switch (size) { case 1: for (i = sizeof(unsigned char) * 8; i \u0026gt; 0; i--) { printf(\u0026quot;%d\u0026quot;, !!(*((unsigned char *)p) \u0026amp; (1 \u0026lt;\u0026lt; (i - 1)))); if (0 == (i - 1) % 4) printf(\u0026quot; \u0026quot;); } printf(\u0026quot;\\n\u0026quot;); break; case 2: for (i = sizeof(unsigned short) * 8; i \u0026gt; 0; i--) { printf(\u0026quot;%d\u0026quot;, !!(*((unsigned short *)p) \u0026amp; (1 \u0026lt;\u0026lt; (i - 1)))); if (0 == (i - 1) % 4) printf(\u0026quot; \u0026quot;); } printf(\u0026quot;\\n\u0026quot;); break; case 4: for (i = sizeof(unsigned int) * 8; i \u0026gt; 0; i--) { printf(\u0026quot;%d\u0026quot;, !!(*((unsigned int *)p) \u0026amp; (1 \u0026lt;\u0026lt; (i - 1)))); if (0 == (i - 1) % 4) printf(\u0026quot; \u0026quot;); } printf(\u0026quot;\\n\u0026quot;); break; case 8: for (i = sizeof(long long) * 8; i \u0026gt; 0; i--) { printf(\u0026quot;%d\u0026quot;, !!(*((unsigned long long int *)p) \u0026amp; (1 \u0026lt;\u0026lt; (i - 1)))); if (0 == (i - 1) % 4) printf(\u0026quot; \u0026quot;); } printf(\u0026quot;\\n\u0026quot;); break; default: break; } } int main() { float f = 8.25; unsigned int *p = (unsigned int *)\u0026amp;f; //占用内存大小相同 put_bin(p, sizeof(unsigned int)); //输出unsigned int内存片段中的每一位的值 printf(\u0026quot;0x%08x\\n\u0026quot;, *p); //16进制打印 return 0; }  输出结果：\ngcc -o test 3-1.c -m32 ./test 0100 0001 0000 0100 0000 0000 0000 0000 0x41040000  3. 精度问题 为了引出对这一问题的思考，我们先看一下int与float类型的范围 那么问题来了：\nint 和 float 都占4字节的内存，为什么float却比int的范围大呢？\n目前我们知道\n int和float都占4个字节的内存，因此float能表示的具体数字的个数与int相同 float类型所能表示的数字的范围却比int的范围大  因此：\n float可表示的数字之间不是连续的，存在间隙 float只是一种近似的表示法，不能作为精确数使用 由于内存表示法相对复杂，float的运算速度比int慢得多  3.1. 编程验证 #include \u0026lt;stdio.h\u0026gt; int main() { float f = 3.14159f; float fa = 123456789; printf(\u0026quot;%0.10f\\n\u0026quot;, f); printf(\u0026quot;%0.10f\\n\u0026quot;, fa); return 0; }  输出结果：\n3.1415901184 123456792.0000000000  注：本文为学习唐老师C进阶课程的笔记，如有问题，欢迎各位批评指正。\n","date":1599380611,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1599380611,"objectID":"f7a91717de807dbcd5e8bb342e3d324c","permalink":"https://strivefar.github.io/project/post/c_advanced/","publishdate":"2020-09-06T16:23:31+08:00","relpermalink":"/project/post/c_advanced/","section":"project","summary":"1. 浮点数在内存中的存储方式 2. 浮点数存储示例 2.1. 实数8.25在内存中的float表示 2.2. 编程验证 3. 精度问题 3.1. 编程验证 1. 浮点数在内存中的存储方式 浮点","tags":["C"],"title":"浮点数的秘密","type":"project"},{"authors":["youngfar"],"categories":[],"content":"在计算机中，数值类型分为整数型或实数型，其中整型又分为无符类型或有符类型，而实型则只有符类型。 字符类型也分为有符和无符类型。在程序中，用户可以自己定义是否需要一个非负整数；\n一、无符号数和有符号数的表示方式 以一个字节(char类型)为例：若想要表示正负号，一般需要一个位来标记，如取最高代表正负号，则有符号和无符号的数值最大值对比如下：\n 有符号：0111 1111 = 2^6+2^5+2^4+2^3+2^2+2^1+2^0 = 127; ==\u0026gt; 范围是 -128 ~ 127 无符号：1111 1111 = 2^7+2^6+2^5+2^4+2^3+2^2+2^1+2^0 = 255；==\u0026gt; 范围是 0 ~ 255  由上可看出：\n 同样一个字节大小，有符号和无符号表示的范围不同，但个数相同均为256个； 单纯这样存储是存在问题:   针对有符号数，0在内存中存在两种方式即＋0和－0；     针对负数的大小，-1(1000 0001)和-2(1000 0010)单纯的从二进制存储来比较，应该是-2(1000 0010)\u0026gt; -1(1000 0001)这与实际逻辑不吻合；   二进制补码避免了这个问题，这也是当今最常用的系统存储方式：即高位段0代表正数，1代表负数，表示正数为原码，而表示负数的方式采用：补码 = 反码+1  参考： 有符号数和无符号数\n以下为OneNote笔记截图，由于时间原因，以后再做整理 ","date":1598930331,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1598930331,"objectID":"5760538402619dcace07b32617bd6e55","permalink":"https://strivefar.github.io/project/post/unsigned%E4%B8%8Esigned/","publishdate":"2020-09-01T11:18:51+08:00","relpermalink":"/project/post/unsigned%E4%B8%8Esigned/","section":"project","summary":"在计算机中，数值类型分为整数型或实数型，其中整型又分为无符类型或有符类型，而实型则只有符类型。 字符类型也分为有符和无符类型。在程序中，用户可","tags":["C"],"title":"细究 unsigned 与 signed","type":"project"},{"authors":["youngfar"],"categories":null,"content":"\u0026amp; 在数组中的应用 以下面这个数组为例，我们先来明确一些概念\nint a[10];  a与\u0026amp;a[0]的关系   数组名a是数组0号元素的地址,也就是存在以下等价关系\na 等价于 \u0026amp;a[0]    \u0026amp;a[0] 表示对一个int型变量取地址，a[0]是一个int变量， 一个int变量的地址类型是 int* ,所以 \u0026amp;a[0] 为 int* 类型\n  于是有 a 等价于 \u0026amp;a[0]，且二者均为 int* 类型\n  a与\u0026amp;a的关系   \u0026amp;a 和 a 在数值上相同，但意义不同！\n  \u0026amp;a 代表数组地址，类型为 int(*)[10]\n  a 代表 数组0号元素的地址，类型为 int*   于是指向数组的指针可以定义为：\nint(*p_arr)[10] = \u0026amp;a;    指向数组成员的指针可以定义为：\nint *p = a; 或 int *p = \u0026amp;a[0];    a+i 中的隐式转换 我们经常在程序中看到类似这样的用法\nprintf(\u0026quot;%d\\n\u0026quot;, *(a+i));  a 为int类型，i为 int类型，a+i的结果是int类型，加几就越过几个sizeof(int)，所以\na+i 或 \u0026amp;a[0]+i = 被取址变量本身的地址 + i * sizeof(被取址的变量的类型)\n这个关系很重要，有的时候我们为使代码简洁，会直接对变量取址，进行上述操作后再解引用，而不是定义一个指针指来指去，下边的代码综合和柔性数组会遇到这种情况。\n示例代码1 以下示例代码包含了上边讨论的诸多情况，有助于对上述讨论内容的理解\n#include \u0026lt;stdio.h\u0026gt; int a[10] = {0}; int main() { int i; for (i = 0; i \u0026lt; 10; i++) { a[i] = i + 1; } int *p = a; int *p1 = \u0026amp;a[0]; int *p2 = \u0026amp;a[1]; int(*p_half)[5] = (int(*)[5]) \u0026amp; a; int(*p_2)[2] = (int(*)[2]) \u0026amp; a[1]; printf(\u0026quot; p = %p\\n\u0026quot;, a); printf(\u0026quot; p1 = %p\\n\u0026quot;, p1); printf(\u0026quot; p_half = %p\\n\u0026quot;, p_half); printf(\u0026quot; p2 = %p\\n\u0026quot;, p2); printf(\u0026quot; p_2 = %p\\n\u0026quot;, p_2); printf(\u0026quot;%d, %d, %d\\n\u0026quot;, p[0], p1[0], *((int *)p_half)); printf(\u0026quot;%d , %d\\n\u0026quot;, a[5], *((int *)(p_half + 1))); printf(\u0026quot;%d , %d\\n\u0026quot;, a[3], *((int *)(p_2 + 1))); }  在Linux执行\ngcc - o test test.c ./test  输出结果如下： 注意：\n  代码中的p_2 的类型为 int(*)[2]\n  \u0026amp;a[1]为int*类型，此处需要强制类型转换   \u0026amp;在结构体中的应用 结构和数组的联系与区别 数组和结构相似的地方是都不再是单一的原子类型，而是一个集合。区别在于数组是相同类型元素（元素可以是原子类型的整型、浮点型、字符型或者结构体、数组等）的集合，而结构是不同类型元素（元素可以是原子类型的整型、浮点型、字符型或者结构体、数组等）的集合。所以结构无所不包，当然结构中也可以定义相同类型的元素，而数组则不然，从这个角度，结构体的普世意义更为广泛，但是毫无疑问，如果结构定义为成员类型是相同的，那么相比定义数组要麻烦的多。\n(来自 https://blog.csdn.net/zhanshen112/article/details/80429861 )\n为更为彻底的体会\u0026amp;的妙用，我们的示例代码将涉及柔性数组(也叫零长度数组)\n示例代码2 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; struct test { int count; //reverse is array name;the array is no item; //the array address follow test struct int reverse[0]; }; int main() { int i; struct test *ptest = (struct test *)malloc(sizeof(struct test) + sizeof(int) * 10); for (i = 0; i \u0026lt; 10; i++) { ptest-\u0026gt;reverse[i] = i + 1; } for (i = 0; i \u0026lt; 10; i++) { printf(\u0026quot;reverse[%d]=%d \\n\u0026quot;, i, ptest-\u0026gt;reverse[i]); } printf(\u0026quot;\\n\\n\u0026quot;); printf(\u0026quot;sizeof(struct test) =%ld\\n\u0026quot;, sizeof(struct test)); /* a+i 或 \u0026amp;a[0]+i = 被取址变量本身的地址 + i * sizeof(被取址的变量的类型)*/ int a = *(\u0026amp;ptest-\u0026gt;count + 1); printf(\u0026quot;\u0026amp;ptest-\u0026gt;count = %p\\n\u0026quot;, \u0026amp;ptest-\u0026gt;count); printf(\u0026quot;\u0026amp;ptest-\u0026gt;count +1 = %p\\n\u0026quot;, (\u0026amp;ptest-\u0026gt;count + 1)); printf(\u0026quot;a=%d\\n\\n\\n\u0026quot;, a); int(*p)[5] = (int(*)[5])(\u0026amp;ptest-\u0026gt;reverse[0]); // int(*p)[5] = (\u0026amp;ptest-\u0026gt;reverse[0]); /* \u0026amp;ptest-\u0026gt;reverse[0]\u0026lt;=\u0026gt;数组0号元素的地址，类型为int* ，所以此处编译器会给出警告 */ /* 无论\u0026amp;取哪个成员的地址，只要加上正确的偏移，总能正确访问到目标 */ printf(\u0026quot;%d ,%d\\n\u0026quot;, *(\u0026amp;ptest-\u0026gt;count + 1), *((int *)p)); printf(\u0026quot;%d ,%d\\n\u0026quot;, *(\u0026amp;ptest-\u0026gt;count + 1 + 5), *((int *)(p + 1))); printf(\u0026quot;%d ,%d\\n\u0026quot;, *(\u0026amp;ptest-\u0026gt;reverse[0] + 5), *((int *)(p + 1))); printf(\u0026quot;%d ,%d\\n\u0026quot;, *(\u0026amp;ptest-\u0026gt;reverse[1] + 4), *((int *)(p + 1))); free(ptest); return 0; }  gcc - o test_1 test1.c ./test_1  ","date":1597910549,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1597910549,"objectID":"5f95e02ccd2ca835feef7be260f8a5b6","permalink":"https://strivefar.github.io/project/post/%E5%85%B3%E4%BA%8E%E5%8F%96%E5%9D%80%E7%AC%A6%E7%9A%84%E8%AE%A8%E8%AE%BA/","publishdate":"2020-08-20T16:02:29+08:00","relpermalink":"/project/post/%E5%85%B3%E4%BA%8E%E5%8F%96%E5%9D%80%E7%AC%A6%E7%9A%84%E8%AE%A8%E8%AE%BA/","section":"project","summary":"\u0026amp; 在数组中的应用 以下面这个数组为例，我们先来明确一些概念 int a[10]; a与\u0026amp;a[0]的关系 数组名a是数组0号元素的地址,也就是存在以下等价关系","tags":["C"],"title":"关于取址符'\u0026'的讨论","type":"project"},{"authors":["youngfar"],"categories":null,"content":" 1. 程序清单2.6  1.1. 2.6说明：    1. 程序清单2.6 // convert.cpp -- converts stone to pounds #include \u0026lt;iostream\u0026gt; int stonetolb(int); // function prototype int main() { using namespace std; int stone; cout \u0026lt;\u0026lt; \u0026quot;Enter the weight in stone: \u0026quot;; cin \u0026gt;\u0026gt; stone; int pounds = stonetolb(stone); cout \u0026lt;\u0026lt; stone \u0026lt;\u0026lt; \u0026quot; stone = \u0026quot;; cout \u0026lt;\u0026lt; pounds \u0026lt;\u0026lt; \u0026quot; pounds.\u0026quot; \u0026lt;\u0026lt; endl; return 0; } int stonetolb(int sts) { return 14 * sts; }  1.1. 2.6说明：  cout \u0026lt;\u0026lt; stone \u0026lt;\u0026lt; \u0026quot; stone = \u0026quot;;   输出到屏幕上的只能是字符串形式，所以在打印之前，cout必须将整数形式的数字转换为字符串形式。 cout 相比 printf 更“聪明”,知道stone是一个需要转换的整数，而printf则需要使用特殊代码进行指定要打印的是字符串还是整数 cout 的智能行为源自C++的面向对象的特性  printf(\u0026quot;Printing a string : %s\\n\u0026quot;,\u0026quot;25\u0026quot;); printf(\u0026quot;Printing an integer: %d\\n\u0026quot;, 25);  #define min(x,y) ({ \\ typeof(x) __min1 = (x); \\ typeof(y) __min2 = (y); \\ (void) (\u0026amp; __min1 == \u0026amp; __min2); \\ __min1 \u0026lt; __min2 ? __min1 :__min2})  ","date":1597109813,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1597109813,"objectID":"84bd799c37662bbb2f74238e6327644a","permalink":"https://strivefar.github.io/project/post/c++_primer_plus_chapter2/","publishdate":"2020-08-11T09:36:53+08:00","relpermalink":"/project/post/c++_primer_plus_chapter2/","section":"project","summary":"1. 程序清单2.6 1.1. 2.6说明： 1. 程序清单2.6 // convert.cpp -- converts stone to pounds #include \u0026lt;iostream\u0026gt; int stonetolb(int); // function prototype int main() { using namespace std; int stone; cout \u0026lt;\u0026lt; \u0026quot;Enter the weight in stone: \u0026quot;; cin \u0026gt;\u0026gt; stone; int pounds = stonetolb(stone); cout \u0026lt;\u0026lt; stone \u0026lt;\u0026lt; \u0026quot; stone = \u0026quot;; cout \u0026lt;\u0026lt;","tags":["plus_C"],"title":"C++_Primer_Plus_chapter2","type":"project"},{"authors":["youngfar"],"categories":null,"content":" 1. Device Tree简介 2. Device Tree编译 3. Device Tree头信息 4. DTB文件结构 5. kernel解析Device Tree 6. platform_device和device_node绑定 7. i2c_client和device_node绑定 8. Device_Tree与sysfs 9. 特此感谢  #内核对设备树的处理 dts在PC 上被编译为.dtb文件； uboot把dtb文件传给内核； 内核解析dtb 文件，把每一个节点都转换为 device_node 结构体； 对于某些device_node结构体，会被转换为platform_device结构体。\n1. Device Tree简介 Linus Torvalds在2011年3月17日的ARM Linux邮件列表宣称“this whole ARM thing is a fucking pain in the ass”，引发ARM Linux社区的地震，随后ARM社区进行了一系列的重大修正。在过去的ARM Linux中，arch/arm/plat-xxx和arch/arm/mach-xxx中充斥着大量的垃圾代码，相当多数的代码只是在描述板级细节，而这些板级细节对于内核来讲，不过是垃圾，如板上的platform设备、resource、i2c_board_info、spi_board_info以及各种硬件的platform_data。 社区必须改变这种局面，于是PowerPC等其他体系架构下已经使用的Flattened Device Tree（FDT）进入ARM社区的视野。Device Tree是一种描述硬件的数据结构，它起源于OpenFirmware(OF)。在Linux2.6中，ARM架构的板极硬件细节过多地被硬编码在arch/arm/plat-xxx和arch/arm/mach-xxx，采用Device Tree后，许多硬件的细节可以直接透过它传递给Linux，而不再需要在kernel中进行大量的冗余编码。\nDevice Tree由一系列被命名的结点（node）和属性（property）组成，而结点本身可包含子结点。所谓属性，其实就是成对出现的name和value。在Device Tree中，可描述的信息包括（原先这些信息大多被hard code到kernel中）:\n CPU的数量和类别 内存基地址和大小 总线和桥 外设连接 中断控制器和中断使用情况 GPIO控制器和GPIO使用情况  它基本上就是画一棵电路板上CPU、总线、设备组成的树，Bootloader会将这棵树传递给内核，然后内核可以识别这棵树，并根据它展开出Linux内核中的platform_device、i2c_client、spi_device等设备。这些设备用到的内存、IRQ等资源，也被传递给了kernel，kernel会将这些资源绑定给展开的相应的设备。\n2. Device Tree编译 Device Tree文件的格式为dts，包含的头文件格式为dtsi，dts文件是一种人可以看懂的编码格式。但是uboot和linux不能直接识别，他们只能识别二进制文件，所以需要把dts文件编译成dtb文件。dtb文件是一种可以被kernel和uboot识别的二进制文件。把dts编译成dtb文件的工具是dtc。Linux源码目录下scripts/dtc目录包含dtc工具的源码。在Linux的scripts/dtc目录下除了提供dtc工具外，也可以自己安装dtc工具，linux下执行：sudo apt-get install device-tree-compiler安装dtc工具。其中还提供了一个fdtdump的工具，可以反编译dtb文件。dts和dtb文件的转换如图1所示。\ndtc工具的使用方法是：\ndtc –I dts –O dtb –o xxx.dtb xxx.dts  即可生成dts文件对应的dtb文件了。\n3. Device Tree头信息 fdtdump工具使用，Linux终端执行ftddump –h，输出以下信息：\nfdtdump -h Usage: fdtdump [options] Options: -[dshV] -d, –debug Dump debug information while decoding the file -s, –scan Scan for an embedded fdt in file -h, –help Print this help and exit -V, –version Print version and exit  本文采用s5pv21_smc.dtb文件为例说明fdtdump工具的使用。Linux终端执行fdtdump –sd s5pv21_smc.dtb \u0026gt; s5pv21_smc.txt，打开s5pv21_smc.txt文件，部分输出信息如下所示：\n// magic: 0xd00dfeed // totalsize: 0xce4 (3300) // off_dt_struct: 0x38 // off_dt_strings: 0xc34 // off_mem_rsvmap: 0x28 // version: 17 // last_comp_version: 16 // boot_cpuid_phys: 0x0 // size_dt_strings: 0xb0 // size_dt_struct: 0xbfc  以上信息便是Device Tree文件头信息，存储在dtb文件的开头部分。\n在Linux内核中使用struct fdt_header结构体描述。struct fdt_header结构体定义在scripts\\dtc\\libfdt\\fdt.h文件中。\nstruct fdt_header { fdt32_t magic; /* magic word FDT_MAGIC */ fdt32_t totalsize; /* total size of DT block */ fdt32_t off_dt_struct; /* offset to structure */ fdt32_t off_dt_strings; /* offset to strings */ fdt32_t off_mem_rsvmap; /* offset to memory reserve map */ fdt32_t version; /* format version */ fdt32_t last_comp_version; /* last compatible version */ /* version 2 fields below */ fdt32_t boot_cpuid_phys; /* Which physical CPU id we're booting on */ /* version 3 fields below */ fdt32_t size_dt_strings; /* size of the strings block */ /* version 17 fields below */ fdt32_t size_dt_struct; /* size of the structure block */ };  fdtdump工具的输出信息即是以上结构中每一个成员的值，struct fdt_header结构体包含了Device Tree的私有信息。例如: fdt_header.magic是fdt的魔数,固定值为0xd00dfeed，fdt_header.totalsize是fdt文件的大小。使用二进制工具打开s5pv21_smc.dtb验证。s5pv21_smc.dtb二进制文件头信息如图2所示。从图2中可以得到Device Tree的文件是以大端模式储存。并且，头部信息和fdtdump的输出信息一致。\nDevice Tree中的节点信息举例如下所示。 上述.dts文件并没有什么真实的用途，但它基本表征了一个Device Tree源文件的结构。\n  1个root结点“ / ”；\n  root结点下面含一系列子结点，本例中为“node@0”和“node@1”；\n  结点“node@0”下又含有一系列子结点，本例中为“ child-node@0 ”；\n  各结点都有一系列属性：\n   这些属性可能为空，如“ an-empty-property”；     可能为字符串，如“a-string-property”；     可能为字符串序列，如“a-string-list-property”；     可能为Cells（由u32整数组成，用尖括号括起来），如“second-child-property”；     可能为字节数据，（每个byte用2个16进制数表示，用“[]”括起来）如“a-byte-data-property”。    Device Tree源文件的结构分为header、fill_area、dt_struct及dt_string四个区域。header为头信息，fill_area为填充区域，填充数字0，dt_struct存储节点数值及名称相关信息，dt_string存储属性名。例如：a-string-property就存储在dt_string区，”A string”及node1就存储在dt_struct区域。\n我们可以给一个设备节点添加lable，之后可以通过\u0026amp;lable的形式访问这个lable，这种引用是通过phandle（pointer handle）进行的。例如，图3中的node1就是一个lable，node@0的子节点child-node@0通过\u0026lt;\u0026amp;node1\u0026gt;引用node@1节点。像是这种phandle的节点，在经过DTC工具编译之后，\u0026amp;node1会变成一个特殊的整型数字n，假设n值为1，那么在node@1节点下自动生成两个属性，属性如下： linux,phandle = \u0026lt;0x00000001\u0026gt;; phandle = \u0026lt;0x00000001\u0026gt;; node@0的子节点child-node@0中的a-reference-to-something = \u0026lt;\u0026amp;node1\u0026gt;会变成a-reference-to-something = \u0026lt; 0x00000001\u0026gt;。此处0x00000001就是一个phandle得值，每一个phandle都有一个独一无二的整型值，在后续kernel中通过这个特殊的数字间接找到引用的节点。通过查看fdtdump输出信息以及dtb二进制文件信息，得到struct fdt_header和文件结构之间的关系信息如所示。\n4. DTB文件结构 通过以上分析，可以得到Device Tree文件结构如图5所示。dtb的头部首先存放的是fdt_header的结构体信息，接着是填充区域，填充大小为off_dt_struct – sizeof(struct fdt_header)，填充的值为0。接着就是struct fdt_property结构体的相关信息。最后是dt_string部分。 Device Tree源文件的结构分为header、fill_area、dt_struct及dt_string四个区域。fill_area区域填充数值0。节点（node）信息使用struct fdt_node_header结构体描述。属性信息使用struct fdt_property结构体描述。各个结构体信息如下:\nstruct fdt_node_header { fdt32_t tag; char name[0]; }; struct fdt_property { fdt32_t tag; fdt32_t len; fdt32_t nameoff; char data[0]; };  struct fdt_node_header描述节点信息，tag是标识node的起始结束等信息的标志位，name指向node名称的首地址。tag的取值如下：\n#define FDT_BEGIN_NODE 0x1 /* Start node: full name */ #define FDT_END_NODE 0x2 /* End node */ #define FDT_PROP 0x3 /* Property: name off, size, content */ #define FDT_NOP 0x4 /* nop */ #define FDT_END 0x9  FDT_BEGIN_NODE和FDT_END_NODE标识node节点的起始和结束，FDT_PROP标识node节点下面的属性起始符，FDT_END标识Device Tree的结束标识符。因此，对于每个node节点的tag标识符一般为FDT_BEGIN_NODE，对于每个node节点下面的属性的tag标识符一般是FDT_PROP。\n描述属性采用struct fdt_property描述，tag标识是属性，取值为FDT_PROP；len为属性值的长度（包括‘\\0’，单位：字节）；nameoff为属性名称存储位置相对于off_dt_strings的偏移地址。\n例如：compatible = “samsung,goni”, “samsung,s5pv210”;compatible是属性名称，”samsung,goni”, “samsung,s5pv210”是属性值。compatible属性名称字符串存放的区域是dt_string。”samsung,goni”, “samsung,s5pv210”存放的位置是fdt_property.data后面。因此fdt_property.data指向该属性值。fdt_property.tag的值为属性标识，len为属性值的长度（包括‘\\0’，单位：字节）,此处len = 29。nameoff为compatible字符串的位置相对于off_dt_strings的偏移地址，即\u0026amp;compatible = nameoff + off_dt_strings。\ndt_struct在Device Tree中的结构如图6所示。节点的嵌套也带来tag标识符的嵌套。 5. kernel解析Device Tree Device Tree文件结构描述就以上struct fdt_header、struct fdt_node_header及struct fdt_property三个结构体描述。kernel会根据Device Tree的结构解析出kernel能够使用的struct property结构体。kernel根据Device Tree中所有的属性解析出数据填充struct property结构体。struct property结构体描述如下：\nstruct property { char *name; /* property full name */ int length; /* property value length */ void *value; /* property value */ struct property *next; /* next property under the same node */ unsigned long _flags; unsigned int unique_id; struct bin_attribute attr; /* 属性文件，与sysfs文件系统挂接 */ };  总的来说，kernel根据Device Tree的文件结构信息转换成struct property结构体，并将同一个node节点下面的所有属性通过property.next指针进行链接，形成一个单链表。 kernel中究竟是如何解析Device Tree的呢？下面分析函数解析过程。函数调用过程如图7所示。kernel的C语言阶段的入口函数是init/main.c/stsrt_kernel()函数，在early_init_dt_scan_nodes()中会做以下三件事：\n  扫描/chosen或者/chose@0节点下面的bootargs属性值到boot_command_line，此外，还处理initrd相关的property，并保存在initrd_start和initrd_end这两个全局变量中；\n  扫描根节点下面，获取{size,address}-cells信息，并保存在dt_root_size_cells和dt_root_addr_cells全局变量中；\n  扫描具有device_type =“memory”属性的/memory或者/memory@0节点下面的reg属性值，并把相关信息保存在meminfo中，全局变量meminfo保存了系统内存相关的信息。\n  Device Tree中的每一个node节点经过kernel处理都会生成一个struct device_node的结构体，struct device_node最终一般会被挂接到具体的struct device结构体。struct device_node结构体描述如下：\nstruct device_node { const char *name; /* node的名称，取最后一次“/”和“@”之间子串 */ const char *type; /* device_type的属性名称，没有为\u0026lt;NULL\u0026gt; */ phandle phandle; /* phandle属性值 */ const char *full_name; /* 指向该结构体结束的位置，存放node的路径全名，例如：/chosen */ struct fwnode_handle fwnode; struct property *properties; /* 指向该节点下的第一个属性，其他属性与该属性链表相接 */ struct property *deadprops; /* removed properties */ struct device_node *parent; /* 父节点 */ struct device_node *child; /* 子节点 */ struct device_node *sibling; /* 姊妹节点，与自己同等级的node */ struct kobject kobj; /* sysfs文件系统目录体现 */ unsigned long _flags; /* 当前node状态标志位，见/include/linux/of.h line124-127 */ void *data; }; /* flag descriptions (need to be visible even when !CONFIG_OF) */ #define OF_DYNAMIC 1 /* node and properties were allocated via kmalloc */ #define OF_DETACHED 2 /* node has been detached from the device tree*/ #define OF_POPULATED 3 /* device already created for the node */ #define OF_POPULATED_BUS 4 /* of_platform_populate recursed to children of this node */  struct device_node结构体中的每个成员作用已经备注了注释信息，下面分析以上信息是如何得来的。\nDevice Tree的解析首先从unflatten_device_tree()开始，代码列出如下：\n/** * unflatten_device_tree - create tree of device_nodes from flat blob * * unflattens the device-tree passed by the firmware, creating the * tree of struct device_node. It also fills the \u0026quot;name\u0026quot; and \u0026quot;type\u0026quot; * pointers of the nodes so the normal device-tree walking functions * can be used. */ void __init unflatten_device_tree(void) { __unflatten_device_tree(initial_boot_params, NULL, \u0026amp;of_root, early_init_dt_alloc_memory_arch, false); /* Get pointer to \u0026quot;/chosen\u0026quot; and \u0026quot;/aliases\u0026quot; nodes for use everywhere */ of_alias_scan(early_init_dt_alloc_memory_arch); }  分析以上代码，在unflatten_device_tree()中，调用函数__unflatten_device_tree()，参数initial_boot_params指向Device Tree在内存中的首地址，of_root在经过该函数处理之后，会指向根节点，early_init_dt_alloc_memory_arch是一个函数指针，为struct device_node和struct property结构体分配内存的回调函数（callback）。\n在__unflatten_device_tree()函数中，两次调用unflatten_dt_node()函数，第一次是为了得到Device Tree转换成struct device_node和struct property结构体需要分配的内存大小，第二次调用才是具体填充每一个struct device_node和struct property结构体。__unflatten_device_tree()代码列出如下：\n/** * __unflatten_device_tree - create tree of device_nodes from flat blob * * unflattens a device-tree, creating the * tree of struct device_node. It also fills the \u0026quot;name\u0026quot; and \u0026quot;type\u0026quot; * pointers of the nodes so the normal device-tree walking functions * can be used. * @blob: The blob to expand * @dad: Parent device node * @mynodes: The device_node tree created by the call * @dt_alloc: An allocator that provides a virtual address to memory * for the resulting tree * * Returns NULL on failure or the memory chunk containing the unflattened * device tree on success. */ static void *__unflatten_device_tree(const void *blob, struct device_node *dad, struct device_node **mynodes, void *(*dt_alloc)(u64 size, u64 align), bool detached) { int size; void *mem; pr_debug(\u0026quot; -\u0026gt; unflatten_device_tree()\\n\u0026quot;); if (!blob) { pr_debug(\u0026quot;No device tree pointer\\n\u0026quot;); return NULL; } pr_debug(\u0026quot;Unflattening device tree:\\n\u0026quot;); pr_debug(\u0026quot;magic: %08x\\n\u0026quot;, fdt_magic(blob)); pr_debug(\u0026quot;size: %08x\\n\u0026quot;, fdt_totalsize(blob)); pr_debug(\u0026quot;version: %08x\\n\u0026quot;, fdt_version(blob)); if (fdt_check_header(blob)) { pr_err(\u0026quot;Invalid device tree blob header\\n\u0026quot;); return NULL; } /* First pass, scan for size */ size = unflatten_dt_nodes(blob, NULL, dad, NULL); if (size \u0026lt; 0) return NULL; size = ALIGN(size, 4); pr_debug(\u0026quot; size is %d, allocating...\\n\u0026quot;, size); /* Allocate memory for the expanded device tree */ mem = dt_alloc(size + 4, __alignof__(struct device_node)); if (!mem) return NULL; memset(mem, 0, size); *(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef); pr_debug(\u0026quot; unflattening %p...\\n\u0026quot;, mem); /* Second pass, do actual unflattening */ unflatten_dt_nodes(blob, mem, dad, mynodes); if (be32_to_cpup(mem + size) != 0xdeadbeef) pr_warning(\u0026quot;End of tree marker overwritten: %08x\\n\u0026quot;, be32_to_cpup(mem + size)); if (detached \u0026amp;\u0026amp; mynodes) { of_node_set_flag(*mynodes, OF_DETACHED); pr_debug(\u0026quot;unflattened tree is detached\\n\u0026quot;); } pr_debug(\u0026quot; \u0026lt;- unflatten_device_tree()\\n\u0026quot;); return mem; }  __unflatten_device_tree()代码列出如下：\n/** * unflatten_dt_nodes - Alloc and populate a device_node from the flat tree * @blob: The parent device tree blob * @mem: Memory chunk to use for allocating device nodes and properties * @dad: Parent struct device_node * @nodepp: The device_node tree created by the call * * It returns the size of unflattened device tree or error code */ static int unflatten_dt_nodes(const void *blob, void *mem, struct device_node *dad, struct device_node **nodepp) { struct device_node *root; int offset = 0, depth = 0, initial_depth = 0; #define FDT_MAX_DEPTH\t64 unsigned int fpsizes[FDT_MAX_DEPTH]; struct device_node *nps[FDT_MAX_DEPTH]; void *base = mem; bool dryrun = !base; if (nodepp) *nodepp = NULL; /* * We're unflattening device sub-tree if @dad is valid. There are * possibly multiple nodes in the first level of depth. We need * set @depth to 1 to make fdt_next_node() happy as it bails * immediately when negative @depth is found. Otherwise, the device * nodes except the first one won't be unflattened successfully. */ if (dad) depth = initial_depth = 1; root = dad; fpsizes[depth] = dad ? strlen(of_node_full_name(dad)) : 0; nps[depth] = dad; for (offset = 0; offset \u0026gt;= 0 \u0026amp;\u0026amp; depth \u0026gt;= initial_depth; offset = fdt_next_node(blob, offset, \u0026amp;depth)) { if (WARN_ON_ONCE(depth \u0026gt;= FDT_MAX_DEPTH)) continue; fpsizes[depth+1] = populate_node(blob, offset, \u0026amp;mem, nps[depth], fpsizes[depth], \u0026amp;nps[depth+1], dryrun); if (!fpsizes[depth+1]) return mem - base; if (!dryrun \u0026amp;\u0026amp; nodepp \u0026amp;\u0026amp; !*nodepp) *nodepp = nps[depth+1]; if (!dryrun \u0026amp;\u0026amp; !root) root = nps[depth+1]; } if (offset \u0026lt; 0 \u0026amp;\u0026amp; offset != -FDT_ERR_NOTFOUND) { pr_err(\u0026quot;Error %d processing FDT\\n\u0026quot;, offset); return -EINVAL; } /* * Reverse the child list. Some drivers assumes node order matches .dts * node order */ if (!dryrun) reverse_nodes(root); return mem - base; }  通过以上函数处理就得到了所有的struct device_node结构体，为每一个node都会自动添加一个名称为“name”的property，property.length的值为当前node的名称取最后一个“/”和“@”之间的子串（包括‘\\0’）。例如：/serial@e2900800，则length = 7，property.value = device_node.name = “serial”。\n6. platform_device和device_node绑定 经过以上解析，Device Tree的数据已经全部解析出具体的struct device_node和struct property结构体，下面需要和具体的device进行绑定。首先讲解platform_device和device_node的绑定过程。在arch/arm/kernel/setup.c文件中，customize_machine()函数负责填充struct platform_device结构体。函数调用过程如下图所示。\n代码分析如下：\nconst struct of_device_id of_default_bus_match_table[] = { { .compatible = \u0026quot;simple-bus\u0026quot;, }, { .compatible = \u0026quot;simple-mfd\u0026quot;, }, #ifdef CONFIG_ARM_AMBA { .compatible = \u0026quot;arm,amba-bus\u0026quot;, }, #endif /* CONFIG_ARM_AMBA */ {} /* Empty terminated list */ }; int of_platform_populate(struct device_node *root, const struct of_device_id *matches, const struct of_dev_auxdata *lookup, struct device *parent) { struct device_node *child; int rc = 0; /* 获取根节点 */ root = root ? of_node_get(root) : of_find_node_by_path(\u0026quot;/\u0026quot;); if (!root) return -EINVAL; /* 为根节点下面的每一个节点创建platform_device结构体 */ for_each_child_of_node(root, child) { rc = of_platform_bus_create(child, matches, lookup, parent, true); if (rc) { of_node_put(child); break; } } /* 更新device_node flag标志位 */ of_node_set_flag(root, OF_POPULATED_BUS); of_node_put(root); return rc; } static int of_platform_bus_create(struct device_node *bus, const struct of_device_id *matches, const struct of_dev_auxdata *lookup, struct device *parent, bool strict) { const struct of_dev_auxdata *auxdata; struct device_node *child; struct platform_device *dev; const char *bus_id = NULL; void *platform_data = NULL; int rc = 0; /* 只有包含\u0026quot;compatible\u0026quot;属性的node节点才会生成相应的platform_device结构体 */ /* Make sure it has a compatible property */ if (strict \u0026amp;\u0026amp; (!of_get_property(bus, \u0026quot;compatible\u0026quot;, NULL))) { return 0; } /* 省略部分代码 */ /* * 针对节点下面得到status = \u0026quot;ok\u0026quot; 或者status = \u0026quot;okay\u0026quot;或者不存在status属性的 * 节点分配内存并填充platform_device结构体 */ dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent); if (!dev || !of_match_node(matches, bus)) return 0; /* 递归调用节点解析函数，为子节点继续生成platform_device结构体，前提是父节点 * 的“compatible” = “simple-bus”，也就是匹配of_default_bus_match_table结构体中的数据 */ for_each_child_of_node(bus, child) { rc = of_platform_bus_create(child, matches, lookup, \u0026amp;dev-\u0026gt;dev, strict); if (rc) { of_node_put(child); break; } } of_node_set_flag(bus, OF_POPULATED_BUS); return rc; }  总的来说，当of_platform_populate()函数执行完毕:\n  kernel就为DTB中所有包含compatible属性名的第一级node创建platform_device结构体，并向平台设备总线注册设备信息。\n  如果第一级node的compatible属性值等于“simple-bus”、“simple-mfd”或者”arm,amba-bus”的话，kernel会继续为当前node的第二级包含compatible属性的node创建platform_device结构体，并注册设备。\n  Linux系统下的设备大多都是挂载在平台总线下的，因此在平台总线被注册后，会根据of_root节点的树结构，去寻找该总线的子节点，所有的子节点将被作为设备注册到该总线上。\n7. i2c_client和device_node绑定 经过customize_machine()函数的初始化，DTB已经转换成platform_device结构体，这其中就包含i2c adapter设备，不同的SoC需要通过平台设备总线的方式自己实现i2c adapter设备的驱动。例如：i2c_adapter驱动的probe函数中会调用i2c_add_numbered_adapter()注册adapter驱动，函数流执行如图9所示。 在of_i2c_register_devices()函数内部便利i2c节点下面的每一个子节点，并为子节点（status = “disable”的除外）创建i2c_client结构体，并与子节点的device_node挂接。其中i2c_client的填充是在i2c_new_device()中进行的，最后device_register()。在构建i2c_client的时候，会对node下面的compatible属性名称的厂商名字去除作为i2c_client的name。例如：compatible = “maxim,ds1338”,则i2c_client-\u0026gt;name = “ds1338”。\n8. Device_Tree与sysfs kernel启动流程为start_kernel()→rest_init()→kernel_thread():kernel_init()→do_basic_setup()→driver_init()→of_core_init()，在of_core_init()函数中在sys/firmware/devicetree/base目录下面为设备树展开成sysfs的目录和二进制属性文件，所有的node节点就是一个目录，所有的property属性就是一个二进制属性文件。\n9. 特此感谢 感谢原创作者的文章，文章图片表达清晰，代码注释详细，对我帮助很大。 ———————————————— 版权声明：本文为CSDN博主「smcdef」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/smcdef/article/details/77387975\n","date":1594893659,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1594893659,"objectID":"6700822a5e8f541b5cc4a0436a16cd29","permalink":"https://strivefar.github.io/project/post/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3-imx6ull/","publishdate":"2020-07-16T18:00:59+08:00","relpermalink":"/project/post/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3-imx6ull/","section":"project","summary":"1. Device Tree简介 2. Device Tree编译 3. Device Tree头信息 4. DTB文件结构 5. kernel解析Device Tree 6. platform_device和devi","tags":["linux","IMX6ULL"],"title":"设备树详解","type":"project"},{"authors":["youngfar"],"categories":null,"content":" 1. 前言 2. 关键词解释：  2.1. 变量的存储方式  2.1.1. 静态存储变量 2.1.2. 动态存储变量   2.2. 生存期的区别   3. static 全局变量与普通全局变量的区别 ？ 4. static局部变量和普通局部变量有什么区别 ？ 5. static函数与普通函数有什么区别？ 6. 巧用static,默认初始化为0 7. 总结：static关键字的作用 8. 参考来源：  1. 前言 Linux内核源码中使用的大量的static关键字来修饰变量和函数，有效的防止了不同文件间的相同变量或函数名引起的冲突，关于static的作用，现解释如下，如有问题，欢迎批评指正。\n2. 关键词解释： 2.1. 变量的存储方式  可分为：“静态存储”和“动态存储”两种。  2.1.1. 静态存储变量  通常是在变量定义时就分定存储单元并一直保持不变，直至整个程序结束，即在程序运行期间分配固定的存储空间。 全局变量即属于此类存储方式。  2.1.2. 动态存储变量  在程序执行过程中，使用它时才分配存储单元，使用完毕立即释放。  典型的例子是函数的形式参数，在函数定义时并不给行参分配存储单元，只是在函数被调用时，才予以分配，调用函数完毕立即释放。 如果一个函数被多次调用时，则反复地分配、释放形参变量的存储单元。\n2.2. 生存期的区别  静态存储变量是一直存在的，而动态存储变量则时而存在时而消失。通常把由于变量存储方式不同而产生的特性称为变量的生存期。  3. static 全局变量与普通全局变量的区别 ？  普通全局变量加上static修饰后就变成了static全局变量 二者都是存储在静态变量区，即以静态存储方式进行存储， 区别：全局变量加上static之后就被限制了可见范围   未加static之前，全局变量在所有的源程序都可见，只要加上extern即可使用其他文件中定义的全局变量；     加上static之后，变为了静态全局变量，静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。    4. static局部变量和普通局部变量有什么区别 ？  保持变量内容的持久，存储在静态数据区的变量会在程序编译时分配固定的存储空间，程序刚开始运行时就完成初始化，也是唯一的一次初始化。 举例如下：  #include \u0026lt;stdio.h\u0026gt; int fun(void) { /*static局部变量只被初始化一次，下一次使用时在上一次结果值的基础上进行改变*/ static int count = 10; return count--; } int count = 1; int main(void) { printf(\u0026quot;global\\t\\tlocal static\\n\u0026quot;); for(; count \u0026lt;= 10; ++count) printf(\u0026quot;%d\\t\\t%d\\n\u0026quot;, count, fun()); return 0; } 程序的运行结果是： global local static 1 10 2 9 3 8 4 7 5 6 6 5 7 4 8 3 9 2 10 1  5. static函数与普通函数有什么区别？ 这有些类似于static 全局变量与普通全局变量的区别，同样的，static函数仅对定义该函数的当前文件可见，无法像普通函数一样加上extern声明就能在其他文件中使用。\n也就是说static修饰后成为了内部函数，应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件.\n6. 巧用static,默认初始化为0 static的第三个作用是默认初始化为0。其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加\u0026rsquo;\\ 0'太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是\u0026rsquo;\\0\u0026rsquo;。不妨做个小实验验证一下。\n#include \u0026lt;stdio.h\u0026gt; int a; int main(void) { int i; static char str[10]; printf(\u0026quot;integer: %d; string: (begin)%s(end)\u0026quot;, a, str); return 0; }  运行结果如下：\ninteger: 0; string: (begin)(end)  7. 总结：static关键字的作用  1.隐藏（限制作用域） 2.保持变量内容的持久（静态局部变量） 3.默认初始化为0  8. 参考来源： 特此感谢： https://blog.csdn.net/tr_ainiyangyang/article/details/80965574 https://blog.csdn.net/qq_37858386/article/details/79064900\n","date":1594530352,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1594530352,"objectID":"0cb0c3d345cb042e2e7834ee9dcb0c1b","permalink":"https://strivefar.github.io/project/post/static%E7%9A%84%E4%BD%9C%E7%94%A8/","publishdate":"2020-07-12T13:05:52+08:00","relpermalink":"/project/post/static%E7%9A%84%E4%BD%9C%E7%94%A8/","section":"project","summary":"1. 前言 2. 关键词解释： 2.1. 变量的存储方式 2.1.1. 静态存储变量 2.1.2. 动态存储变量 2.2. 生存期的区别 3. static 全局变量与普通全局变量的区别 ？ 4. static局部变量和普通","tags":["C"],"title":"Static的作用","type":"project"},{"authors":["youngfar"],"categories":null,"content":" 1. 板子启动后查看设备树  1.1. 文件说明   2. 编译/反编译 设备树文件  2.1. 手动编译 2.2. 在内核根目录下自动编译  2.2.1. 过程解析     3. led驱动模板——设备树改造  3.1. 给开发板更换设备树文件 3.2. 内核驱动程序的改造  3.2.1. platform_device（包含来自设备树的） 如何与 platform_driver 配对:  3.2.1.1. 使用设备树信息来判断 dev 和 drv 是否配对时     3.3. 按照这种转换关系，代码改造如下 3.4. 匹配成功后，会调用chip_demo_gpio_probe 注册分配的各种资源 3.5. 注销分配的各种资源： 3.6. 然后是模块加载和卸载函数： 3.7. 进入开发板的/mnt目录下 3.8. 将leddrv.ko 和 chip_demo_gpio.ko 注册进内核 3.9. 执行一下命令来进行点灯的操作 3.10. 前后对比，观察一下转化关系   4. 参考来源 5. 程序  1. 板子启动后查看设备树 注意：开发板中仅存放dtb 二进制文件，所以想直接查看开发板中的dts文件是查看不到的，需要先通过网络文件系统将开发板中dtb 二进制文件的copy到虚拟机，在虚拟机中反编译得到dts文件\n板子启动后执行下面的命令：\nls /sys/firmware/ devicetree fdt  1.1. 文件说明 /sys/firmware/devicetree 目录下是以目录结构程现的 dtb 文件, 根结点对应 base 目录, 每一个结点对应一个目录, 每一个属性对应一个文件。\n这些属性的值如果是字符串，可以使用 cat 命令把它打印出来；对于数值可以用 hexdump 把它打印出来。\n还可以看到/sys/firmware/fdt 文件，它就是 dtb 格式的设备树文件，可以把它复制出来放到 ubuntu上，执行下面的命令反编译出来(-I dtb：输入格式是 dtb，-O dts：输出格式是 dts)：\ncd 板子所用的内核源码目录 ./scripts/dtc/dtc -I dtb -O dts /从板子上/复制出来的/fdt -o tmp.dts  2. 编译/反编译 设备树文件 2.1. 手动编译 内核目录下 scripts/dtc/dtc 是设备树的编译工具，直接使用它的话，包含其他文件时不能使用 “#include”，而必须使用“/incldue”。\n编译、反编译的示例命令如下，“-I”指定输入格式，“-O”指定输出格式，“-o”指定输出文件：\n./scripts/dtc/dtc -I dts -O dtb -o tmp.dtb arch/arm/boot/dts/xxx.dts // 编译 dts 为 dtb ./scripts/dtc/dtc -I dtb -O dts -o tmp.dts arch/arm/boot/dts/xxx.dtb // 反编译 dtb 为 dts  2.2. 在内核根目录下自动编译 V=1 察看编译过程,不关心过程省略即可\nmake dtbs V=1 mkdir -p arch/arm/boot/dts/ ; arm-linux-gnueabihf-gcc -E -Wp,-MD,arch/arm/boot/dts/.imx6ull-14x14-ebf-mini.dtb.d.pre.tmp -nostdinc -I./arch/arm/boot/dts -I./arch/arm/boot/dts/include -I./drivers/of/testcase-data -undef -D__DTS__ -x assembler-with-cpp -o arch/arm/boot/dts/.imx6ull-14x14-ebf-mini.dtb.dts.tmp arch/arm/boot/dts/imx6ull-14x14-ebf-mini.dts ; ./scripts/dtc/dtc -O dtb -o arch/arm/boot/dts/imx6ull-14x14-ebf-mini.dtb -b 0 -i arch/arm/boot/dts/ -Wno-unit_address_vs_reg -d arch/arm/boot/dts/.imx6ull-14x14-ebf-mini.dtb.d.dtc.tmp arch/arm/boot/dts/.imx6ull-14x14-ebf-mini.dtb.dts.tmp ;  2.2.1. 过程解析 它首先用 arm-linux-gnueabihf-gcc 预处理 dts 文件，把其中的.h 头文件包含进来，把宏展开。\n然后使用 scripts/dtc/dtc 生成 dtb 文件。\n可见，dts 文件之所以支持“#include”语法，是因为 arm-linux-gnueabihf-gcc 帮忙。\n如果只用 dtc 工具，它是不支持”#include”语法的，只支持“/include”语法。\n3. led驱动模板——设备树改造 3.1. 给开发板更换设备树文件 imx6ull 单板 设备树文件是：内核源码目录中：\n/home/book/100ask_imx6ull-sdk/Linux-4.9.88  其在内核源码目录中的路径为\narch/arm/boot/dts/100ask_imx6ull-14x14.dts  要更换板子上的设备树文件，启动板子后，更换这个文件：\n/boot/100ask_imx6ull-14x14.dtb     远程登录Linux服务器后：先搜索dts文件    book@100ask:~/100ask_imx6ull-sdk/Linux-4.9.88/arch/arm/boot/dts$ find -name 100ask_imx6ull-14x14.dts ./100ask_imx6ull-14x14.dts    然后打开后添加node（子结点）： 在根结点下添加100ask_led@0和100ask_led@1这两个子结点（由于dts篇幅较长，这里仅展示一部分）    /dts-v1/; #include \u0026lt;dt-bindings/input/input.h\u0026gt; #include \u0026quot;imx6ull.dtsi\u0026quot; #define GROUP_PIN(g,p) ((g\u0026lt;\u0026lt;16) | (p)) / { model = \u0026quot;Freescale i.MX6 ULL 14x14 EVK Board\u0026quot;; compatible = \u0026quot;fsl,imx6ull-14x14-evk\u0026quot;, \u0026quot;fsl,imx6ull\u0026quot;; chosen { stdout-path = \u0026amp;uart1; }; memory { reg = \u0026lt;0x80000000 0x20000000\u0026gt;; }; reserved-memory { #address-cells = \u0026lt;1\u0026gt;; #size-cells = \u0026lt;1\u0026gt;; ranges; linux,cma { compatible = \u0026quot;shared-dma-pool\u0026quot;; reusable; size = \u0026lt;0x14000000\u0026gt;; linux,cma-default; }; }; 100ask_led@0 { compatible = \u0026quot;100as,leddrv\u0026quot;; pin = \u0026lt;GROUP_PIN(5,3)\u0026gt;; }; 100ask_led@1 { compatible = \u0026quot;100as,leddrv\u0026quot;; pin = \u0026lt;GROUP_PIN(5,8)\u0026gt;; };    在内核源码目录中执行make dtbs编译dts得到dtb文件：    book@100ask:~/100ask_imx6ull-sdk/Linux-4.9.88/arch/arm/boot/dts$ cd /home/book/100ask_imx6ull-sdk/Linux-4.9.88 book@100ask:~/100ask_imx6ull-sdk/Linux-4.9.88$ make dtbs CHK include/config/kernel.release CHK include/generated/uapi/linux/version.h CHK include/generated/utsrelease.h CHK include/generated/bounds.h CHK include/generated/timeconst.h CHK include/generated/asm-offsets.h CALL scripts/checksyscalls.sh DTC arch/arm/boot/dts/100ask_imx6ull-14x14.dtb  上述编译结果中，DTC 后面的即为编译好的设备树的二进制文件\n然后通过网络传输一下：\nbook@100ask:~/100ask_imx6ull-sdk/Linux-4.9.88$ cp arch/arm/boot/dts/100ask_imx6ull-14x14.dtb ~/nfs_rootfs/    在开发板中（串口操作） 首先进入到/boot目录中    cd /boot  然后查看一下/boot/ 的内容\n[root@imx6ull:/boot]# ls 100ask_imx6ull-14x14.dtb zImage 100ask_imx6ull-14x14_back.dtb  这里的100ask_imx6ull-14x14_back.dtb 是原来的100ask_imx6ull-14x14.dtb的备份，建议备份一下\n然后重启开发板\n[root@imx6ull:/boot]# reboot  3.2. 内核驱动程序的改造 内核处理设备树的函数调用过程，这里不去分析；我们只需要得到如下结论：\n A. platform_device 中含有 resource 数组, 它来自 device_node 的 reg, interrupts 属性; B. platform_device.dev.of_node 指向 device_node, 可以通过它获得其他属性  在/home/book/100ask_imx6ull-sdk/Linux-4.9.88/include/linux/的device.h中 定义了一个struct device 结构体\n/** * struct device - The basic device structure * @of_node:\tAssociated device tree node. */ struct device { /* ...省略部分代码 */ struct device_node\t*of_node; /* associated device tree node */ struct fwnode_handle\t*fwnode; /* firmware device node */ /* ...省略部分代码 */ };  3.2.1. platform_device（包含来自设备树的） 如何与 platform_driver 配对: 3.2.1.1. 使用设备树信息来判断 dev 和 drv 是否配对时   首先，如果 of_match_table 中含有 compatible 值，就跟 dev 的 compatile 属性比较，若一致则成功，否则返回失败；\n  其次，如果 of_match_table 中含有 type 值，就跟 dev 的 device_type 属性比较，若一致则成功，否则返回失败；\n  最后，如果 of_match_table 中含有 name 值，就跟 dev 的 name 属性比较，若一致则成功，否则返回失败。\n  而设备树中建议不再使用 devcie_type 和 name 属性，所以基本上只使用设备节点的 compatible 属性 来寻找匹配的 platform_driver。\n  对上述关系还有一个非常有趣的拟人化解释，这个解释出自这位博主的博客，链接如下： https://blog.csdn.net/zqixiao_09/article/details/50888795\n打个比方，就好比相亲，总线是红娘，设备是男方，驱动是女方：\na \u0026ndash; 红娘（总线）负责男方（设备）和女方（驱动）的撮合； b \u0026ndash; 男方（女方）找到红娘，说我来登记一下，看有没有合适的姑娘（汉子）—— 设备或驱动的注册；\nc \u0026ndash; 红娘这时候就需要看看有没有八字（二者的name 字段）匹配的姑娘（汉子）——match 函数进行匹配，看name是否相同；\nd \u0026ndash; 如果八字不合，就告诉男方（女方）没有合适的对象，先等着，别急着乱做事 —— 设备和驱动会等待，直到匹配成功；\ne \u0026ndash; 终于遇到八字匹配的了，那就结婚呗！接完婚，男方就向女方交代，我有多少存款，我的房子在哪，钱放在哪等等（ struct resource *resource），女方说好啊，于是去房子里拿钱，去给男方买菜啦，给自己买衣服、化妆品、首饰啊等等（int (*probe)(struct platform_device *) 匹配成功后驱动执行的第一个函数），当然如果男的跟小三跑了（设备卸载），女方也不会继续待下去的（ int (*remove)(struct platform_device *)）。\n3.3. 按照这种转换关系，代码改造如下 /* of_device_id */ static const struct of_device_id ask100_leds[] = { { .compatible = \u0026quot;100as,leddrv\u0026quot; }, { }, //标志结束，不可省略 }; static struct platform_driver chip_demo_gpio_driver = { .probe = chip_demo_gpio_probe, .remove = chip_demo_gpio_remove, .driver = { .name = \u0026quot;mytest_led\u0026quot;, .of_match_table = ask100_leds, //得到of_device_id }, };  3.4. 匹配成功后，会调用chip_demo_gpio_probe 注册分配的各种资源 static int chip_demo_gpio_probe(struct platform_device *pdev) { struct device_node *np; int err = 0; int led_pin; np = pdev-\u0026gt;dev.of_node; if (!np) return -1; /* 从设备树转化过来的平台设备中提取pin资源 */ err = of_property_read_u32(np, \u0026quot;pin\u0026quot;, \u0026amp;led_pin); /* 利用设备的资源依次注册设备 */ g_ledpins[g_ledcnt] = led_pin; led_class_create_device(g_ledcnt); g_ledcnt++; return 0; }  3.5. 注销分配的各种资源： static int chip_demo_gpio_remove(struct platform_device *pdev) { int i = 0; int err; struct device_node *np; int led_pin; np = pdev-\u0026gt;dev.of_node; if (!np) return -1; /* 判断一下是否为之前已解析到的pin属性 */ err = of_property_read_u32(np, \u0026quot;pin\u0026quot;, \u0026amp;led_pin); for (i = 0; i \u0026lt; g_ledcnt; i++) { /* 如果是，则销毁设备，并把存放引脚属性的数组对应元素置为-1 */ if (g_ledpins[i] == led_pin) { led_class_destroy_device(i); g_ledpins[i] = -1; break; }; } /* 遍历一遍引脚属性数组，如果均为-1，说明都已经销毁掉了 */ for (i = 0; i \u0026lt; g_ledcnt; i++) { if (g_ledpins[i] != -1) break; } /*如果均已销毁，引脚属性数组为空，则把已注册的LED灯的个数置为0，方便下次注册 */ if (i == g_ledcnt) g_ledcnt = 0; return 0; }  3.6. 然后是模块加载和卸载函数： static int __init chip_demo_gpio_drv_init(void) { int err; err = platform_driver_register(\u0026amp;chip_demo_gpio_driver); register_led_operations(\u0026amp;board_demo_led_opr); return 0; } static void __exit lchip_demo_gpio_drv_exit(void) { platform_driver_unregister(\u0026amp;chip_demo_gpio_driver); } module_init(chip_demo_gpio_drv_init); module_exit(lchip_demo_gpio_drv_exit); MODULE_LICENSE(\u0026quot;GPL\u0026quot;);  可以看到,模块加载和卸载函数仅仅通过paltform_driver_register()、paltform_driver_unregister() 函数进行 platform_driver 的注册和注销，而原先注册和注销字符设备的工作已经被移交到 platform_driver 的 probe() 和 remove() 成员函数中。\n3.7. 进入开发板的/mnt目录下 [root@imx6ull:/mnt]# ls 100ask_imx6ull-14x14.dtb leddrv.ko chip_demo_gpio.ko ledtest  3.8. 将leddrv.ko 和 chip_demo_gpio.ko 注册进内核 [root@imx6ull:/mnt]# insmod leddrv.ko [root@imx6ull:/mnt]# insmod chip_demo_gpio.ko  进入到如下目录来查看一下，匹配之后的目录结构如下： 3.9. 执行一下命令来进行点灯的操作 [root@imx6ull:/mnt]# ./ledtest /dev/mytest_led0 on [root@imx6ull:/mnt]# ./ledtest /dev/mytest_led0 off  注意：这里设备名之所以是mytest_ledx，是因为上层驱动中的device_create函数以\u0026quot;mytest_led%d\u0026quot;进行设备的创建\nvoid led_class_create_device(int minor) { device_create(led_class, NULL, MKDEV(major, minor), NULL, \u0026quot;mytest_led%d\u0026quot;, minor); /* /dev/mytest_led0,1,... */ }  文末给出了具体的chip_demo_gpio.c 和 应用层的led_test.c等代码\n3.10. 前后对比，观察一下转化关系 关于内核对设备树文件的解析，可以参考设备树详解中的内容。这里仅针对目录结构对应的转化关系来看看结果。\n  根结点下的子结点（一级结点）中的属性名，将来会成为开发板中/sys/firmware/devicetree/base目录下的文件，base则对应为根结点;   对于根结点下的二级结点，同样会以一级结点名作为目录，二级结点中的属性名将成为该目录下的文件 以reserved-memory结点为例，其包含linux,cma这一子结点：   [root@imx6ull:/sys/firmware/devicetree/base/reserved-memory]# cd linux,cma [root@imx6ull:/sys/firmware/devicetree/base/reserved-memory/linux,cma]# ls compatible name size linux,cma-default reusable   对于结点中包含的属性，按照不同类型的值转换为不同类型的文件   这些属性的值如果是字符串，可以使用 cat 命令把它打印出来；    [root@imx6ull:/sys/firmware/devicetree/base/reserved-memory]# ls #address-cells #size-cells linux,cma name ranges [root@imx6ull:/sys/firmware/devicetree/base/reserved-memory]# cat name reserved-memory     对于数值，可以用 hexdump 把它打印出来    [root@imx6ull:/sys/firmware/devicetree/base/reserved-memory/linux,cma]# ls compatible name size linux,cma-default reusable izeot@imx6ull:/sys/firmware/devicetree/base/reserved-memory/linux,cma]# hexdump s 0000000 0014 0000 0000004  4. 参考来源 本文参考了并学习了韦东山老师的视频和配套的文档，特此感谢\n5. 程序  chip_demo_gpio.c  #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/fs.h\u0026gt; #include \u0026lt;linux/errno.h\u0026gt; #include \u0026lt;linux/miscdevice.h\u0026gt; #include \u0026lt;linux/kernel.h\u0026gt; #include \u0026lt;linux/major.h\u0026gt; #include \u0026lt;linux/mutex.h\u0026gt; #include \u0026lt;linux/proc_fs.h\u0026gt; #include \u0026lt;linux/seq_file.h\u0026gt; #include \u0026lt;linux/stat.h\u0026gt; #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/device.h\u0026gt; #include \u0026lt;linux/tty.h\u0026gt; #include \u0026lt;linux/kmod.h\u0026gt; #include \u0026lt;linux/gfp.h\u0026gt; #include \u0026lt;linux/platform_device.h\u0026gt; #include \u0026lt;linux/of.h\u0026gt; #include \u0026lt;asm/io.h\u0026gt; #include \u0026quot;led_opr.h\u0026quot; #include \u0026quot;leddrv.h\u0026quot; #include \u0026quot;led_resource.h\u0026quot; static int g_ledpins[100]; static int g_ledcnt = 0; static volatile unsigned int val; static volatile unsigned int* CCM_CCGR1; static volatile unsigned int* IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3; static volatile unsigned int* GPIO5_GDIR; static volatile unsigned int* GPIO5_DR; static int board_demo_led_init(int which) /* 初始化LED, which-哪个LED */ { //printk(\u0026quot;%s %s line %d, led %d\\n\u0026quot;, __FILE__, __FUNCTION__, __LINE__, which); printk(\u0026quot;init gpio: group %d, pin %d\\n\u0026quot;, GROUP(g_ledpins[which]), PIN(g_ledpins[which])); switch (GROUP(g_ledpins[which])) { case 0: { printk(\u0026quot;init pin of group 0 ...\\n\u0026quot;); break; } case 1: { printk(\u0026quot;init pin of group 1 ...\\n\u0026quot;); break; } case 2: { printk(\u0026quot;init pin of group 2 ...\\n\u0026quot;); break; } case 3: { printk(\u0026quot;init pin of group 3 ...\\n\u0026quot;); break; } case 4: { printk(\u0026quot;init pin of group 4 ...\\n\u0026quot;); break; } case 5: { printk(\u0026quot;init pin of group 5 ...\\n\u0026quot;); if (!CCM_CCGR1) { CCM_CCGR1 = ioremap(0x20C406C, 4); IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = ioremap(0x2290014, 4); GPIO5_GDIR = ioremap(0x020AC000 + 0x4, 4); GPIO5_DR = ioremap(0x020AC000 + 0, 4); } /* GPIO5_IO03 */ /* a. 使能GPIO5 * set CCM to enable GPIO5 * CCM_CCGR1[CG15] 0x20C406C * bit[31:30] = 0b11 */ *CCM_CCGR1 |= (3 \u0026lt;\u0026lt; 30); /* b. 设置GPIO5_IO03用于GPIO * set IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 * to configure GPIO5_IO03 as GPIO * IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 0x2290014 * bit[3:0] = 0b0101 alt5 */ val = *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3; val \u0026amp;= ~(0xf); val |= (5); *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = val; /* b. 设置GPIO5_IO03作为output引脚 * set GPIO5_GDIR to configure GPIO5_IO03 as output * GPIO5_GDIR 0x020AC000 + 0x4 * bit[3] = 0b1 */ *GPIO5_GDIR |= (1 \u0026lt;\u0026lt; 3); break; } } return 0; } static int board_demo_led_ctl(int which, char status) /* 控制LED, which-哪个LED, status:1-亮,0-灭 */ { //printk(\u0026quot;%s %s line %d, led %d, %s\\n\u0026quot;, __FILE__, __FUNCTION__, __LINE__, which, status ? \u0026quot;on\u0026quot; : \u0026quot;off\u0026quot;); printk(\u0026quot;set led %s: group %d, pin %d\\n\u0026quot;, status ? \u0026quot;on\u0026quot; : \u0026quot;off\u0026quot;, GROUP(g_ledpins[which]), PIN(g_ledpins[which])); switch (GROUP(g_ledpins[which])) { case 0: { printk(\u0026quot;set pin of group 0 ...\\n\u0026quot;); break; } case 1: { printk(\u0026quot;set pin of group 1 ...\\n\u0026quot;); break; } case 2: { printk(\u0026quot;set pin of group 2 ...\\n\u0026quot;); break; } case 3: { printk(\u0026quot;set pin of group 3 ...\\n\u0026quot;); break; } case 4: { printk(\u0026quot;set pin of group 4 ...\\n\u0026quot;); break; } case 5: { switch (PIN(g_ledpins[which])) { case 0: /* code */ break; case 1: /* code */ break; case 2: /* code */ break; case 3: if (status) /* on: output 0*/ { /* d. 设置GPIO5_DR输出低电平 * set GPIO5_DR to configure GPIO5_IO03 output 0 * GPIO5_DR 0x020AC000 + 0 * bit[3] = 0b0 */ *GPIO5_DR \u0026amp;= ~(1 \u0026lt;\u0026lt; 3); } else /* off: output 1*/ { /* e. 设置GPIO5_IO3输出高电平 * set GPIO5_DR to configure GPIO5_IO03 output 1 * GPIO5_DR 0x020AC000 + 0 * bit[3] = 0b1 */ *GPIO5_DR |= (1 \u0026lt;\u0026lt; 3); } break; default: break; } printk(\u0026quot;set pin of group 5 ...\\n\u0026quot;); break; } } return 0; } static struct led_operations board_demo_led_opr = { .init = board_demo_led_init, .ctl = board_demo_led_ctl, }; struct led_operations *get_board_led_opr(void) { return \u0026amp;board_demo_led_opr; } static int chip_demo_gpio_probe(struct platform_device *pdev) { struct device_node *np; int err = 0; int led_pin; np = pdev-\u0026gt;dev.of_node; if (!np) return -1; /* 从设备树转化过来的平台设备中提取pin资源 */ err = of_property_read_u32(np, \u0026quot;pin\u0026quot;, \u0026amp;led_pin); /* 利用设备的资源依次注册设备 */ g_ledpins[g_ledcnt] = led_pin; led_class_create_device(g_ledcnt); g_ledcnt++; return 0; } static int chip_demo_gpio_remove(struct platform_device *pdev) { int i = 0; int err; struct device_node *np; int led_pin; np = pdev-\u0026gt;dev.of_node; if (!np) return -1; /* 判断一下是否为之前已解析到的pin属性 */ err = of_property_read_u32(np, \u0026quot;pin\u0026quot;, \u0026amp;led_pin); for (i = 0; i \u0026lt; g_ledcnt; i++) { /* 如果是，则销毁设备，并把存放引脚属性的数组对应元素置为-1 */ if (g_ledpins[i] == led_pin) { led_class_destroy_device(i); g_ledpins[i] = -1; break; }; } /* 遍历一遍引脚属性数组，如果均为-1，说明都已经销毁掉了 */ for (i = 0; i \u0026lt; g_ledcnt; i++) { if (g_ledpins[i] != -1) break; } /*如果均已销毁，引脚属性数组为空，则把已注册的LED灯的个数置为0，方便下次注册 */ if (i == g_ledcnt) g_ledcnt = 0; return 0; } static const struct of_device_id ask100_leds[] = { { .compatible = \u0026quot;100as,leddrv\u0026quot; }, { }, }; static struct platform_driver chip_demo_gpio_driver = { .probe = chip_demo_gpio_probe, .remove = chip_demo_gpio_remove, .driver = { .name = \u0026quot;mytest_led\u0026quot;, .of_match_table = ask100_leds, }, }; static int __init chip_demo_gpio_drv_init(void) { int err; err = platform_driver_register(\u0026amp;chip_demo_gpio_driver); register_led_operations(\u0026amp;board_demo_led_opr); return 0; } static void __exit lchip_demo_gpio_drv_exit(void) { platform_driver_unregister(\u0026amp;chip_demo_gpio_driver); } module_init(chip_demo_gpio_drv_init); module_exit(lchip_demo_gpio_drv_exit); MODULE_LICENSE(\u0026quot;GPL\u0026quot;);   上层驱动leddrv.c  #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/fs.h\u0026gt; #include \u0026lt;linux/errno.h\u0026gt; #include \u0026lt;linux/miscdevice.h\u0026gt; #include \u0026lt;linux/kernel.h\u0026gt; #include \u0026lt;linux/major.h\u0026gt; #include \u0026lt;linux/mutex.h\u0026gt; #include \u0026lt;linux/proc_fs.h\u0026gt; #include \u0026lt;linux/seq_file.h\u0026gt; #include \u0026lt;linux/stat.h\u0026gt; #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/device.h\u0026gt; #include \u0026lt;linux/tty.h\u0026gt; #include \u0026lt;linux/kmod.h\u0026gt; #include \u0026lt;linux/gfp.h\u0026gt; #include \u0026quot;led_opr.h\u0026quot; /* 1. 确定主设备号 */ static int major = 0; static struct class *led_class; struct led_operations *p_led_opr; #define MIN(a, b) (a \u0026lt; b ? a : b) //void led_class_create_device(int minor) //{ //\tdevice_create(led_class, NULL, MKDEV(major, minor), NULL, \u0026quot;100ask_led%d\u0026quot;, minor); /* /dev/100ask_led0,1,... */ //} void led_class_create_device(int minor) { device_create(led_class, NULL, MKDEV(major, minor), NULL, \u0026quot;mytest_led%d\u0026quot;, minor); /* /dev/mytest_led0,1,... */ } void led_class_destroy_device(int minor) { device_destroy(led_class, MKDEV(major, minor)); } void register_led_operations(struct led_operations *opr) { p_led_opr = opr; } EXPORT_SYMBOL(led_class_create_device); EXPORT_SYMBOL(led_class_destroy_device); EXPORT_SYMBOL(register_led_operations); /* 3. 实现对应的open/read/write等函数，填入file_operations结构体 */ static ssize_t led_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset) { printk(\u0026quot;%s %s line %d\\n\u0026quot;, __FILE__, __FUNCTION__, __LINE__); return 0; } /* write(fd, \u0026amp;val, 1); */ static ssize_t led_drv_write (struct file *file, const char __user *buf, size_t size, loff_t *offset) { int err; char status; struct inode *inode = file_inode(file); int minor = iminor(inode); printk(\u0026quot;%s %s line %d\\n\u0026quot;, __FILE__, __FUNCTION__, __LINE__); err = copy_from_user(\u0026amp;status, buf, 1); /* 根据次设备号和status控制LED */ p_led_opr-\u0026gt;ctl(minor, status); return 1; } static int led_drv_open (struct inode *node, struct file *file) { int minor = iminor(node); printk(\u0026quot;%s %s line %d\\n\u0026quot;, __FILE__, __FUNCTION__, __LINE__); /* 根据次设备号初始化LED */ p_led_opr-\u0026gt;init(minor); return 0; } static int led_drv_close (struct inode *node, struct file *file) { printk(\u0026quot;%s %s line %d\\n\u0026quot;, __FILE__, __FUNCTION__, __LINE__); return 0; } /* 2. 定义自己的file_operations结构体 */ static struct file_operations led_drv = { .owner\t= THIS_MODULE, .open = led_drv_open, .read = led_drv_read, .write = led_drv_write, .release = led_drv_close, }; /* 4. 把file_operations结构体告诉内核：注册驱动程序 */ /* 5. 谁来注册驱动程序啊？得有一个入口函数：安装驱动程序时，就会去调用这个入口函数 */ static int __init led_init(void) { int err; printk(\u0026quot;%s %s line %d\\n\u0026quot;, __FILE__, __FUNCTION__, __LINE__); major = register_chrdev(0, \u0026quot;100ask_led\u0026quot;, \u0026amp;led_drv); /* /dev/led */ led_class = class_create(THIS_MODULE, \u0026quot;100ask_led_class\u0026quot;); err = PTR_ERR(led_class); if (IS_ERR(led_class)) { printk(\u0026quot;%s %s line %d\\n\u0026quot;, __FILE__, __FUNCTION__, __LINE__); unregister_chrdev(major, \u0026quot;100ask_led\u0026quot;); return -1; } return 0; } /* 6. 有入口函数就应该有出口函数：卸载驱动程序时，就会去调用这个出口函数 */ static void __exit led_exit(void) { printk(\u0026quot;%s %s line %d\\n\u0026quot;, __FILE__, __FUNCTION__, __LINE__); class_destroy(led_class); unregister_chrdev(major, \u0026quot;100ask_led\u0026quot;); } /* 7. 其他完善：提供设备信息，自动创建设备节点 */ module_init(led_init); module_exit(led_exit); MODULE_LICENSE(\u0026quot;GPL\u0026quot;);   应用程序  #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; /* * ./ledtest /dev/100ask_led0 on * ./ledtest /dev/100ask_led0 off */ int main(int argc, char **argv) { int fd; char status; /* 1. 判断参数 */ if (argc != 3) { printf(\u0026quot;Usage: %s \u0026lt;dev\u0026gt; \u0026lt;on | off\u0026gt;\\n\u0026quot;, argv[0]); return -1; } /* 2. 打开文件 */ fd = open(argv[1], O_RDWR); if (fd == -1) { printf(\u0026quot;can not open file %s\\n\u0026quot;, argv[1]); return -1; } /* 3. 写文件 */ if (0 == strcmp(argv[2], \u0026quot;on\u0026quot;)) { status = 1; write(fd, \u0026amp;status, 1); } else { status = 0; write(fd, \u0026amp;status, 1); } close(fd); return 0; }   Makefile  # 1. 使用不同的开发板内核时, 一定要修改KERN_DIR # 2. KERN_DIR中的内核要事先配置、编译, 为了能编译内核, 要先设置下列环境变量: # 2.1 ARCH, 比如: export ARCH=arm64 # 2.2 CROSS_COMPILE, 比如: export CROSS_COMPILE=aarch64-linux-gnu- # 2.3 PATH, 比如: export PATH=$PATH:/home/book/100ask_roc-rk3399-pc/ToolChain-6.3.1/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin # 注意: 不同的开发板不同的编译器上述3个环境变量不一定相同, # 请参考各开发板的高级用户使用手册 KERN_DIR = /home/book/100ask_imx6ull-sdk/Linux-4.9.88 all: make -C $(KERN_DIR) M=`pwd` modules $(CROSS_COMPILE)gcc -o ledtest ledtest.c clean: make -C $(KERN_DIR) M=`pwd` modules clean rm -rf modules.order rm -f ledtest # 参考内核源码drivers/char/ipmi/Makefile # 要想把a.c, b.c编译成ab.ko, 可以这样指定: # ab-y := a.o b.o # obj-m += ab.o obj-m += leddrv.o chip_demo_gpio.o  ","date":1594008063,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1594008063,"objectID":"db335458a84e7b8c29480e0b67d1e028","permalink":"https://strivefar.github.io/project/post/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%AD%E6%B3%95/","publishdate":"2020-07-06T12:01:03+08:00","relpermalink":"/project/post/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%AD%E6%B3%95/","section":"project","summary":"1. 板子启动后查看设备树 1.1. 文件说明 2. 编译/反编译 设备树文件 2.1. 手动编译 2.2. 在内核根目录下自动编译 2.2.1. 过程解析 3. led驱动模板——设备树改造 3.1. 给开发板","tags":["linux"],"title":"Linux 设备驱动开发————设备树应用实例（imx6ull）","type":"project"},{"authors":["youngfar"],"categories":null,"content":"绘制思维导图如下： ","date":1593878657,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1593878657,"objectID":"6e413c37a8c5286085da52312ab08d06","permalink":"https://strivefar.github.io/project/post/%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/","publishdate":"2020-07-05T00:04:17+08:00","relpermalink":"/project/post/%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/","section":"project","summary":"绘制思维导图如下：","tags":["linux"],"title":"总线设备驱动模型","type":"project"},{"authors":["youngfar"],"categories":null,"content":" 前言 参数的调用方式  11.1. 传值调用 11.2. 传址调用 11.3. 传引用调用 11.4. 示例说明   使用二级指针/一级指针创建链表时的对比  12.1. 主函数中作此调用 12.2. 使用二级指针创建链表 12.3. 使用一级指针创建链表会成功吗   销毁链表时二级指针和一级指针的对比  13.1. 使用二级指针销毁链表 13.2. 使用一级指针销毁链表会成功吗   总结 完整代码 参考来源  前言 我们在学习数据结构时，在链表初始化或者销毁链表的时候，经常使用二级指针或者一级指针的引用，这是为什么呢？同样是指向内存单元的地址，为什么就不能使用一级指针呢？使用一级指针去初始化或者是销毁链表的时候，究竟会发生什么呢？到底什么时候该用二级指针，什么时候该用一级指针？\n如果你对这些问题有疑问，可以参考本篇文章，以下是我个人对这些问题的理解，如有问题，欢迎随时联系我。\n参数的调用方式 我们通常使用的函数调用方式无非两种，一种是传值调用，一种是传址调用。 谈起指针我们可能瞬间就会把它和传址调用联系在一起，但实际上，对于指针来讲，它也存在着这两种调用方式，传值调用和传值调用。\n11.1. 传值调用 传值调用是指在调用参数时,不是对原参数进行操作,而是创建参数的拷贝并对其进行操作,这种调用有利于保护数据。\n11.2. 传址调用 传址调用的过程中把函数外部创建的变量的内存地址传递给函数参数，这种调用可以让函数和函数外边的变量建立起联系，函数内部可以直接操作函数外部；\n11.3. 传引用调用 适用于C++，不适用于C语言\n11.4. 示例说明 注意： 传递一级指针变量本身等价于在传递指针变量的值，虽然有指针参与其中，但在函数内部，也只是创建了指针的copy，无非就是把传过来的实参的值给指针的copy用一用，并没有对实参（原指针变量）进行操作\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string.h\u0026gt; using namespace std; void fun1(char* str) { str = new char[5]; strcpy (str, \u0026quot;test string\u0026quot;); } void fun2(char** str) { *str = new char[5]; strcpy (*str, \u0026quot;test string\u0026quot;); } int main() { char* s = NULL; cout \u0026lt;\u0026lt; \u0026quot;call function fun1\u0026quot; \u0026lt;\u0026lt; endl; fun1 (s); if (!s) cout \u0026lt;\u0026lt; \u0026quot;s is null!\u0026quot; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;call function fun2\u0026quot; \u0026lt;\u0026lt; endl; fun2 (\u0026amp;s); if (!s) cout \u0026lt;\u0026lt; \u0026quot;s is null!\u0026quot; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } ———————————————— 版权声明：本文为CSDN博主「踏莎行hyx」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/u012234115/article/details/39717215  输出结果： 使用二级指针/一级指针创建链表时的对比 12.1. 主函数中作此调用 int main() { LinkList L; ElemType e; Status i; int j, k; //InitList1(L); //一级指针方式创建表头，失败 InitList2(\u0026amp;L); //二级指针方式创建表头，成功 }  12.2. 使用二级指针创建链表 //初始化表头，用二级指针 Status InitList2(LinkList *L) //等价于Node **L { *L = (LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */ if (!(*L)) /* 存储分配失败 */ return ERROR; (*L)-\u0026gt;next = NULL; /* 指针域为空 */ return OK; }  用图片说明更为直观： 函数内部可以直接操作函数外部\n简明描述为： 如果没有头结点： ![在这里插入图片描述]12.3. 使用一级指针创建链表会成功吗 //初始化表头，用一级指针（此方式无效） Status InitList1(LinkList L) //等价于Node *L { L = (LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */ if (!L) /* 存储分配失败 */ return ERROR; L-\u0026gt;next = NULL; /* 指针域为空 */ return OK; }  用图片说明更为直观： ![在这里插入图片描述]很明显，把传过来的实参的值给指针的copy用一用，并没有对实参（原指针变量）进行操作，这样创建的链表是毫无意义的，main.c后面再使用L时，用的依旧是个垃圾值，是有隐患的。\n销毁链表时二级指针和一级指针的对比 main.c中：\nprintf(\u0026quot;销毁链表\\n\u0026quot;); //DestroyList1(L); //一级指针方式销毁链表，失败,且出现满屏乱码 DestroyList2(\u0026amp;L); //二级指针方式销毁链表，成功  13.1. 使用二级指针销毁链表 //销毁链表，使用二级指针 Status DestroyList2(LinkList *L) { LinkList p, q; p = (*L)-\u0026gt;next; /* p指向第一个结点 */ while (p) /* 没到表尾 */ { q = p-\u0026gt;next; free(p); p = q; } free(*L); //头结点彻底没有掉才是销毁 *L = NULL; return OK; }  用图片说明更为直观：\n![在这里插入图片描述]简单来说： 销毁链表就是让头指针为空，然后这个链表就彻底湮没在内存中了\n![在这里插入图片描述]13.2. 使用一级指针销毁链表会成功吗 //销毁链表，使用一级指针(此方式无效) Status DestroyList1(LinkList L) { LinkList p, q; p = L-\u0026gt;next; /* p指向第一个结点 */ while (p) /* 没到表尾 */ { q = p-\u0026gt;next; free(p); p = q; } free(L); L = NULL; return OK; }  用图片说明更为直观：\n![在这里插入图片描述]可见这种方式的确很危险，实际测试中也的确出现了乱码\n总结 1.初始化链表头部指针需要用二级指针或者一级指针的引用。\n2.销毁链表需要用到二级指针或者一级指针的引用。\n3.插入、删除、遍历、清空结点用一级指针即可。\n完整代码 #include \u0026quot;stdio.h\u0026quot; #include \u0026quot;stdlib.h\u0026quot; #include \u0026quot;time.h\u0026quot; #define OK 1 #define ERROR 0 #define TRUE 1 #define FALSE 0 #define MAXSIZE 20 /* 存储空间初始分配量 */ typedef int Status; /* Status是函数的类型,其值是函数结果状态代码，如OK等 */ typedef int ElemType; /* ElemType类型根据实际情况而定，这里假设为int */ Status visit(ElemType c) { printf(\u0026quot;%d \u0026quot;, c); return OK; } typedef struct Node { ElemType data; struct Node *next; } Node; typedef struct Node *LinkList; /* 定义LinkList */ //初始化表头，用一级指针（此方式无效） Status InitList1(LinkList L) //等价于Node *L { L = (LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */ if (!L) /* 存储分配失败 */ return ERROR; L-\u0026gt;next = NULL; /* 指针域为空 */ return OK; } //初始化表头，用二级指针 Status InitList2(LinkList *L) //等价于Node **L { *L = (LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */ if (!(*L)) /* 存储分配失败 */ return ERROR; (*L)-\u0026gt;next = NULL; /* 指针域为空 */ return OK; } //初始化表头，用一级指针引用 Status InitList3(LinkList \u0026amp;L) //等价于Node *\u0026amp;L { L = (LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */ if (!L) /* 存储分配失败 */ return ERROR; L-\u0026gt;next = NULL; /* 指针域为空 */ return OK; } //清空链表，使用二级指针 Status ClearList1(LinkList *L) { LinkList p, q; p = (*L)-\u0026gt;next; /* p指向第一个结点 */ while (p) /* 没到表尾 */ { q = p-\u0026gt;next; free(p); p = q; } (*L)-\u0026gt;next = NULL; /* 头结点指针域为空 */ return OK; } //清空链表，使用一级指针 Status ClearList2(LinkList L) { LinkList p, q; p = L-\u0026gt;next; /* p指向(这里的第一个结点只头结点) */ while (p) /* 没到表尾 */ { q = p-\u0026gt;next; free(p); p = q; } L-\u0026gt;next = NULL; /* 头结点指针域为空 */ return OK; } //销毁链表，使用一级指针(此方式无效) Status DestroyList1(LinkList L) { LinkList p, q; p = L-\u0026gt;next; /* p指向第一个结点 */ while (p) /* 没到表尾 */ { q = p-\u0026gt;next; free(p); p = q; } free(L); L = NULL; return OK; } //销毁链表，使用二级指针 Status DestroyList2(LinkList *L) { LinkList p, q; p = (*L)-\u0026gt;next; /* p指向头结点(第一个结点) */ while (p) /* 没到表尾 */ { q = p-\u0026gt;next; free(p); p = q; } free(*L); //头结点彻底没有掉才是销毁 *L = NULL; return OK; } //销毁链表，使用一级指针引用 Status DestroyList3(LinkList \u0026amp;L) { LinkList p, q; p = L-\u0026gt;next; /* p指向第一个结点 */ while (p) /* 没到表尾 */ { q = p-\u0026gt;next; free(p); p = q; } free(L); L = NULL; return OK; } /* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */ /* 操作结果：用e返回L中第i个数据元素的值 */ Status GetElem(LinkList L, int i, ElemType *e) { int j; LinkList p; /* 声明一结点p */ p = L-\u0026gt;next; /* 让p指向链表L的第一个结点 */ j = 1; /* j为计数器 */ while (p \u0026amp;\u0026amp; j \u0026lt; i) /* p不为空或者计数器j还没有等于i时，循环继续 */ { p = p-\u0026gt;next; /* 让p指向下一个结点 */ ++j; } if (!p || j \u0026gt; i) return ERROR; /* 第i个元素不存在 */ *e = p-\u0026gt;data; /* 取第i个元素的数据 */ return OK; } //在中间插入元素，用二级指针 Status ListInsert1(LinkList *L, int i, ElemType e) { int j; LinkList p, s; p = *L; j = 1; while (p \u0026amp;\u0026amp; j \u0026lt; i) /* 寻找第i个结点 */ { p = p-\u0026gt;next; ++j; } if (!p || j \u0026gt; i) return ERROR; /* 第i个元素不存在 */ s = (LinkList)malloc(sizeof(Node)); /* 生成新结点(C语言标准函数) */ s-\u0026gt;data = e; s-\u0026gt;next = p-\u0026gt;next; /* 将p的后继结点赋值给s的后继 */ p-\u0026gt;next = s; /* 将s赋值给p的后继 */ return OK; } //在中间插入元素，用一级指针 Status ListInsert2(LinkList L, int i, ElemType e) { int j; LinkList p, s; p = L; j = 1; while (p \u0026amp;\u0026amp; j \u0026lt; i) /* 寻找第i个结点 */ { p = p-\u0026gt;next; ++j; } if (!p || j \u0026gt; i) return ERROR; /* 第i个元素不存在 */ s = (LinkList)malloc(sizeof(Node)); /* 生成新结点(C语言标准函数) */ s-\u0026gt;data = e; s-\u0026gt;next = p-\u0026gt;next; /* 将p的后继结点赋值给s的后继 */ p-\u0026gt;next = s; /* 将s赋值给p的后继 */ return OK; } //删除一个元素，用二级指针 Status ListDelete1(LinkList *L, int i, ElemType *e) { int j; LinkList p, q; p = *L; j = 1; while (p-\u0026gt;next \u0026amp;\u0026amp; j \u0026lt; i) /* 遍历寻找第i个元素 */ { p = p-\u0026gt;next; ++j; } if (!(p-\u0026gt;next) || j \u0026gt; i) return ERROR; /* 第i个元素不存在 */ q = p-\u0026gt;next; p-\u0026gt;next = q-\u0026gt;next; /* 将q的后继赋值给p的后继 */ *e = q-\u0026gt;data; /* 将q结点中的数据给e */ free(q); /* 让系统回收此结点，释放内存 */ return OK; } //删除一个元素，用一级指针 Status ListDelete2(LinkList L, int i, ElemType *e) { int j; LinkList p, q; p = L; j = 1; while (p-\u0026gt;next \u0026amp;\u0026amp; j \u0026lt; i) /* 遍历寻找第i个元素 */ { p = p-\u0026gt;next; ++j; } if (!(p-\u0026gt;next) || j \u0026gt; i) return ERROR; /* 第i个元素不存在 */ q = p-\u0026gt;next; p-\u0026gt;next = q-\u0026gt;next; /* 将q的后继赋值给p的后继 */ *e = q-\u0026gt;data; /* 将q结点中的数据给e */ free(q); /* 让系统回收此结点，释放内存 */ return OK; } /* 初始条件：顺序线性表L已存在 */ /* 操作结果：依次对L的每个数据元素输出 */ Status ListTraverse(LinkList L) { LinkList p = L-\u0026gt;next; while (p) { visit(p-\u0026gt;data); p = p-\u0026gt;next; } printf(\u0026quot;\\n\u0026quot;); return OK; } int main() { LinkList L; ElemType e; Status i; int j, k; //InitList1(L); //一级指针方式创建表头，失败 //InitList2(\u0026amp;L); //二级指针方式创建表头，成功 InitList3(L); //一级指针引用方式创建表头，成功 for (j = 1; j \u0026lt;= 7; j++) ListInsert2(L, 1, j); printf(\u0026quot;一级指针方式在L的表头依次插入1～7后：\u0026quot;); ListTraverse(L); ListInsert1(\u0026amp;L, 3, 12); printf(\u0026quot;二级指针方式在L的中间插入12后：\u0026quot;); ListTraverse(L); ListInsert2(L, 5, 27); printf(\u0026quot;一级指针在L的中间插入27后：\u0026quot;); ListTraverse(L); GetElem(L, 5, \u0026amp;e); printf(\u0026quot;第5个元素的值为：%d\\n\u0026quot;, e); ListDelete1(\u0026amp;L, 5, \u0026amp;e); /* 删除第5个数据 */ printf(\u0026quot;二级指针方式删除第%d个的元素值为：%d\\n\u0026quot;, 5, e); printf(\u0026quot;依次输出L的元素：\u0026quot;); ListTraverse(L); ListDelete2(L, 3, \u0026amp;e); /* 删除第3个数据 */ printf(\u0026quot;一级指针方式删除第%d个的元素值为：%d\\n\u0026quot;, 3, e); printf(\u0026quot;依次输出L的元素：\u0026quot;); ListTraverse(L); printf(\u0026quot;二级指针方式清空链表\\n\u0026quot;); ClearList1(\u0026amp;L); printf(\u0026quot;依次输出L的元素：\u0026quot;); ListTraverse(L); for (j = 1; j \u0026lt;= 7; j++) ListInsert2(L, j, j); printf(\u0026quot;在L的表尾依次插入1～7后：\u0026quot;); ListTraverse(L); printf(\u0026quot;一级指针方式清空链表\\n\u0026quot;); ClearList2(L); printf(\u0026quot;依次输出L的元素：\u0026quot;); ListTraverse(L); printf(\u0026quot;销毁链表\\n\u0026quot;); //DestroyList1(L); //一级指针方式销毁链表，失败,且出现满屏乱码 DestroyList2(\u0026amp;L); //二级指针方式销毁链表，成功 DestroyList3(L); //一级指针引用方式销毁链表，成功 return 0; }  参考来源 本文参考了以下博文，结合自己的理解，总结记录了相关知识，特此感谢 https://blog.csdn.net/u012234115/article/details/39717215 https://blog.csdn.net/DX_Jone/article/details/102817995\n","date":1591352808,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1591352808,"objectID":"023659301634c78eb2c3f28ed9be9e54","permalink":"https://strivefar.github.io/project/post/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/","publishdate":"2020-06-05T18:26:48+08:00","relpermalink":"/project/post/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/","section":"project","summary":"前言 参数的调用方式 11.1. 传值调用 11.2. 传址调用 11.3. 传引用调用 11.4. 示例说明 使用二级指针/一级指针创建链表时的对比 12.1. 主函数中作此调用 12.2. 使用二级指针创建链表 12.3.","tags":["Data_Structure"],"title":"链表中为何使用二级指针或者一级指针的引用","type":"project"},{"authors":["youngfar"],"categories":null,"content":"参考链接 GCC生成动态链接库（.so文件）：-shared和-fPIC选项 GCC创建和使用静态链接库（.a文件） gcc的使用方法；动态编译和静态编译；Linux制作动态库和静态库\n命名规则 静态库命名规则如下： libxxx.o lib:前缀 .o:静态库 动态链接库（shared object file，共享对象文件）命名规则如下： libxxx.so lib:前缀 .so:动态库\n静态库参数 gcc 常用编译选项 动态库和静态库的对比 我们先来说一下静态库； Linux下的静态库是以.a结尾的二进制文件，它作为一个程序的模块，它在链接期间就被组合到了程序中，比如说我有一个主程序mian.c，那么我把它和静态库链接的时候，它就直接把这个静态库组合到了我的main.c里面生成的一个二进制文件.a。 而与静态链接库相对的是动态链接库，同样的是把主函数mian.c和动态库进行链接，与静态库不同的是,这个动态库在程序运行的阶段才会被加载进内存,参与主函数运行 下面用几张图来说明一下： 还可以加上-static选项，让链接静态库后的math.out彻底的独立起来，“完全静态”，因此，得到的二进制文件会非常大。 使用静态/动态链接库的优缺点： 静态库： 编译后的执行程序不需要外部的函数库支持，因为所有使用的函数都经被编译进去了。当然这也会成为他的缺点，因为如果静态函数库改变了，那么你的程序必须重新编译。\n静态库的代码在编译时链接到应用程序中，因此编译时库文件必须存在并且需要通过“-L”参数传递给编译器，应用程序在开始执行时，库函数代码将随程序一 起调入进程内存段直到进程结束，其执行过程不需要原静态库存在。\n动态库： 动态函数库在编译的时候并没有被编译进目标代码中，你的程序执行到相关函数时才调用该函数库里的相应函数，因此动态函数库所产生的可执行文件比较小。由于函数库没有被整合进你的程序，而是程序运行时动态的申请并调用，所以程序的运行环境中必须提供相应的库。动态函数库的改变并不影响你的程序，所以动态函数库的升级比较方便。\n不同的INIX系统链接动态库方法，实现细节不一样，编译PIC型.o中间文件的方法一般是采用C语言编译器的-KPIC或者 -fPIC选项 最主要的是GCC命令行的一个选项: -shared:该选项指定生成动态连接库(让连接器生成T类型的导出符号表，有时候也生成弱连接W类 型的导出符号) ,不用该标志外部程序无法连接。相当于一个可执行文件 -fPIC:表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的,所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。\n制作链接库的目的（商业角度）： 这就和商业项目挂钩了: 假如我们是一个项目的外包方，我们是有专利的，希望别人使用我们已经实现的功能，但又不希望别人看到我们的源代码，所以这对商业机构是非常友好的。\nMakefile中的使用实例： ","date":1589328000,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1589328000,"objectID":"1871c95961991aff494bda9a3a308f67","permalink":"https://strivefar.github.io/project/post/getting-started/","publishdate":"2020-05-13T00:00:00Z","relpermalink":"/project/post/getting-started/","section":"project","summary":"参考链接 GCC生成动态链接库（.so文件）：-shared和-fPIC选项 GCC创建和使用静态链接库（.a文件） gcc的使用方法；动态编译和","tags":["linux"],"title":"动态编译和静态编译——制作动态库和静态库","type":"project"},{"authors":["YoungFar"],"categories":null,"content":" Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature.   Supplementary notes can be added here, including code and math.\n","date":1554595200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1554595200,"objectID":"557dc08fd4b672a0c08e0a8cf0c9ff7d","permalink":"https://strivefar.github.io/publication/preprint/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/preprint/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example preprint / working paper","type":"publication"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Academic Academic | Documentation\n Features  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides   Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E   Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)   Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\n Fragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}}  Press Space to play!\nOne  Two  Three \n A fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears   Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}}  Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view    Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links    night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links   Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/img/boards.jpg\u0026quot; \u0026gt;}} {{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}} {{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}   Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; }   Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"https://strivefar.github.io/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Academic's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":["YoungFar","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.    Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature.   Supplementary notes can be added here, including code and math.\n","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1441065600,"objectID":"966884cc0d8ac9e31fab966c4534e973","permalink":"https://strivefar.github.io/publication/journal-article/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/journal-article/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example journal article","type":"publication"},{"authors":["YoungFar","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.    Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature.   Supplementary notes can be added here, including code and math.\n","date":1372636800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1372636800,"objectID":"69425fb10d4db090cfbd46854715582c","permalink":"https://strivefar.github.io/publication/conference-paper/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/conference-paper/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example conference paper","type":"publication"}]