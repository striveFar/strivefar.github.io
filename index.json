[{"authors":["youngfar"],"categories":null,"content":"","date":1554595200,"expirydate":-62135596800,"kind":"taxonomy","lang":"zh","lastmod":1554595200,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://strivefar.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"","tags":null,"title":"YoungFar","type":"authors"},{"authors":null,"categories":null,"content":"Flexibility This feature can be used for publishing content such as:\n Online courses Project or software documentation Tutorials  The courses folder may be renamed. For example, we can rename it to docs for software/project documentation or tutorials for creating an online course.\nDelete tutorials To remove these pages, delete the courses folder and see below to delete the associated menu link.\nUpdate site menu After renaming or deleting the courses folder, you may wish to update any [[main]] menu links to it by editing your menu configuration at config/_default/menus.toml.\nFor example, if you delete this folder, you can remove the following from your menu configuration:\n[[main]] name = \u0026quot;Courses\u0026quot; url = \u0026quot;courses/\u0026quot; weight = 50  Or, if you are creating a software documentation site, you can rename the courses folder to docs and update the associated Courses menu configuration to:\n[[main]] name = \u0026quot;Docs\u0026quot; url = \u0026quot;docs/\u0026quot; weight = 50  Update the docs menu If you use the docs layout, note that the name of the menu in the front matter should be in the form [menu.X] where X is the folder name. Hence, if you rename the courses/example/ folder, you should also rename the menu definitions in the front matter of files within courses/example/ from [menu.example] to [menu.\u0026lt;NewFolderName\u0026gt;].\n","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"zh","lastmod":1536451200,"objectID":"59c3ce8e202293146a8a934d37a4070b","permalink":"https://strivefar.github.io/courses/example/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/courses/example/","section":"courses","summary":"正在努力学习中...","tags":null,"title":"Overview","type":"docs"},{"authors":null,"categories":null,"content":"In this tutorial, I\u0026rsquo;ll share my top 10 tips for getting started with Academic:\nTip 1 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\nTip 2 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"74533bae41439377bd30f645c4677a27","permalink":"https://strivefar.github.io/courses/example/example1/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/courses/example/example1/","section":"courses","summary":"In this tutorial, I\u0026rsquo;ll share my top 10 tips for getting started with Academic:\nTip 1 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim.","tags":null,"title":"Example Page 1","type":"docs"},{"authors":null,"categories":null,"content":"Here are some more tips for getting started with Academic:\nTip 3 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\nTip 4 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1557010800,"objectID":"1c2b5a11257c768c90d5050637d77d6a","permalink":"https://strivefar.github.io/courses/example/example2/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/courses/example/example2/","section":"courses","summary":"Here are some more tips for getting started with Academic:\nTip 3 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus.","tags":null,"title":"Example Page 2","type":"docs"},{"authors":[],"categories":null,"content":" Click on the Slides button above to view the built-in slides feature.   Slides can be added in a few ways:\n Create slides using Academic\u0026rsquo;s Slides feature and link using slides parameter in the front matter of the talk file Upload an existing slide deck to static/ and link using url_slides parameter in the front matter of the talk file Embed your slides (e.g. Google Slides) or presentation video on this page using shortcodes.  Further talk details can easily be added to this page using Markdown and $\\rm \\LaTeX$ math code.\n","date":1906549200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1906549200,"objectID":"96344c08df50a1b693cc40432115cbe3","permalink":"https://strivefar.github.io/talk/example/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/talk/example/","section":"talk","summary":"An example talk using Academic's Markdown slides feature.","tags":[],"title":"Example Talk","type":"talk"},{"authors":[],"categories":[],"content":" 1. file_operations结构体 2. 入口函数 3. 注册函数  3.1. register_framebuffer 3.2. do_register_framebuffer   4. 驱动调用关系  4.1. fbmem.c的作用 4.2. 调用示例   5. 结合app分析LCD驱动程序  5.1. 应用层调用分析 5.2. 驱动层调用分析  5.2.1. fb_open 5.2.2. fb_ioctl 5.2.3. fb_mmap      1. file_operations结构体 static const struct file_operations fb_fops = { .owner =\tTHIS_MODULE, .read =\tfb_read, .write =\tfb_write, .unlocked_ioctl = fb_ioctl, #ifdef CONFIG_COMPAT .compat_ioctl = fb_compat_ioctl, #endif .mmap =\tfb_mmap, .open =\tfb_open, .release =\tfb_release, #ifdef HAVE_ARCH_FB_UNMAPPED_AREA .get_unmapped_area = get_fb_unmapped_area, #endif #ifdef CONFIG_FB_DEFERRED_IO .fsync =\tfb_deferred_io_fsync, #endif .llseek =\tdefault_llseek, }; EXPORT_SYMBOL(fb_class);  2. 入口函数 由module_init(fbmem_init);可知，fbmem_init是驱动入口函数，在入口函数中，将分配并设置好的file_operations结构体fb_fops向上层驱动注册。\nstatic int __init fbmem_init(void) { int ret; if (!proc_create(\u0026quot;fb\u0026quot;, 0, NULL, \u0026amp;fb_proc_fops)) return -ENOMEM; /* 注册file_operations */ ret = register_chrdev(FB_MAJOR, \u0026quot;fb\u0026quot;, \u0026amp;fb_fops); if (ret) { printk(\u0026quot;unable to get major %d for fb devs\\n\u0026quot;, FB_MAJOR); goto err_chrdev; } /* 创建graphics类 */ fb_class = class_create(THIS_MODULE, \u0026quot;graphics\u0026quot;); if (IS_ERR(fb_class)) { ret = PTR_ERR(fb_class); pr_warn(\u0026quot;Unable to create fb class; errno = %d\\n\u0026quot;, ret); fb_class = NULL; goto err_class; } return 0; err_class: unregister_chrdev(FB_MAJOR, \u0026quot;fb\u0026quot;); err_chrdev: remove_proc_entry(\u0026quot;fb\u0026quot;, NULL); return ret; }  3. 注册函数 注册一个frame buffer 设备，依据relation给出的信息判断，该函数由上层驱动调用，一般放在某一个具体的fb设备驱动的probe函数中。\n3.1. register_framebuffer /** *\tregister_framebuffer - registers a frame buffer device *\t@fb_info: frame buffer info structure * *\tRegisters a frame buffer device @fb_info. * *\tReturns negative errno on error, or zero for success. * */ int register_framebuffer(struct fb_info *fb_info) { int ret; mutex_lock(\u0026amp;registration_lock); ret = do_register_framebuffer(fb_info); mutex_unlock(\u0026amp;registration_lock); return ret; } EXPORT_SYMBOL(register_framebuffer);  注意：framebuffer设备的创建是在设备信息注册时才创建的，差异性的体现，具体如下\n3.2. do_register_framebuffer /* 初始化传入的framebuffer设备信息，并放入registered_fb[i]中完成注册 */ static int do_register_framebuffer(struct fb_info *fb_info) { int i, ret; struct fb_event event; struct fb_videomode mode; ... num_registered_fb++; /* 寻找空的registered_fb中的元素 */ for (i = 0 ; i \u0026lt; FB_MAX; i++) if (!registered_fb[i]) break; fb_info-\u0026gt;node = i; atomic_set(\u0026amp;fb_info-\u0026gt;count, 1); mutex_init(\u0026amp;fb_info-\u0026gt;lock); mutex_init(\u0026amp;fb_info-\u0026gt;mm_lock); /* 创建fb%d设备 */ fb_info-\u0026gt;dev = device_create(fb_class, fb_info-\u0026gt;device, MKDEV(FB_MAJOR, i), NULL, \u0026quot;fb%d\u0026quot;, i); ... /* 使用散列表管理模式链表 */ if (!fb_info-\u0026gt;modelist.prev || !fb_info-\u0026gt;modelist.next) INIT_LIST_HEAD(\u0026amp;fb_info-\u0026gt;modelist); ... /* 将填充的好的fb_info放入注册表中 */ registered_fb[i] = fb_info; ... return 0; }  4. 驱动调用关系 4.1. fbmem.c的作用 fbmem.c起到一个管理中转的作用，具体的设备操作函数在struct fb_ops结构体中，fb_info继承了fb_ops，并由register_framebuffer函数完成fb_info的注册：\n4.2. 调用示例 在内核中找了一个例子，分析了调用关系，以帮助我们更好的理解调用和封装的关系 5. 结合app分析LCD驱动程序 5.1. 应用层调用分析 /* 设备描述符 */ static int fd_fb; /* 用于接收fb_var_screeninfo（可变的屏幕信息），fb_var_screeninfo包含于内核fb.h的fb_info中 */ static struct fb_var_screeninfo var; /* Current var */ /* 待计算的屏幕信息 */ static int screen_size; static unsigned char *fb_base; static unsigned int line_width; static unsigned int pixel_width; /* 应用层framebuffer设备初始化 */ static int FbDeviceInit(void) { /* 应用层调用open ，导致驱动层调用fb_open() */ fd_fb = open(\u0026quot;/dev/fb0\u0026quot;, O_RDWR); if (fd_fb \u0026lt; 0) { printf(\u0026quot;can't open /dev/fb0\\n\u0026quot;); return -1; } /* 应用层调用ioctl ，导致驱动层调用fb_ioctl() */ if (ioctl(fd_fb, FBIOGET_VSCREENINFO, \u0026amp;var)) { printf(\u0026quot;can't get var\\n\u0026quot;); return -1; } /* 利用获取到屏幕参数计算屏幕信息 */ line_width = var.xres * var.bits_per_pixel / 8; pixel_width = var.bits_per_pixel / 8; screen_size = var.xres * var.yres * var.bits_per_pixel / 8; /* 获取framebuffer */ fb_base = (unsigned char *)mmap(NULL, screen_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd_fb, 0); if (fb_base == (unsigned char *)-1) { printf(\u0026quot;can't mmap\\n\u0026quot;); return -1; } return 0; }  5.2. 驱动层调用分析 应用层首先打开对应的设备驱动，使用ioctl()查询已注册的LCD设备的信息，主要包含了屏幕的每一行的像素宽度，每一列的像素宽度，以及rgb的格式，至此便可以调用mmap()，应用层系统调用最终将调用到驱动中fbmem.c中的file_operation结构体指定的对应的函数，如下：\nstatic const struct file_operations fb_fops = { .owner =\tTHIS_MODULE, ... .unlocked_ioctl = fb_ioctl, .mmap =\tfb_mmap, .open =\tfb_open, ... };  驱动fbmem.c注册\nmodule_init(fbmem_init) -\u0026gt; fbmem_init() -\u0026gt; register_chrdev(FB_MAJOR, \u0026quot;fb\u0026quot;, \u0026amp;fb_fops);  下面来看一下驱动中的fb_open、fb_ioctl、fb_mmap分别做了什么\n5.2.1. fb_open static int fb_open(struct inode *inode, struct file *file) __acquires(\u0026amp;info-\u0026gt;lock) __releases(\u0026amp;info-\u0026gt;lock) { /* 根据子设备号获得具体的设备 */ int fbidx = iminor(inode); struct fb_info *info; int res = 0; /* 从已注册的registered_fb[] 中取出具体的设备 */ info = get_fb_info(fbidx); ... /* 将得到的info放入私有数据中 */ file-\u0026gt;private_data = info; /* 如果在info中发现有驱动提供的fb_open操作函数就运行这个 */ if (info-\u0026gt;fbops-\u0026gt;fb_open) { res = info-\u0026gt;fbops-\u0026gt;fb_open(info,1); if (res) module_put(info-\u0026gt;fbops-\u0026gt;owner); } ... }  5.2.2. fb_ioctl static long do_fb_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg) { struct fb_ops *fb; struct fb_var_screeninfo var; struct fb_fix_screeninfo fix; ... void __user *argp = (void __user *)arg; long ret = 0; switch (cmd) { /* 得到屏幕虚拟信息 */ case FBIOGET_VSCREENINFO: /* 加互斥锁保护，如果没有fbops表明设备不存在 */ if (!lock_fb_info(info)) return -ENODEV; /* 得到fb_info 中的可变信息variable */ var = info-\u0026gt;var; unlock_fb_info(info); /* 向用户空间copy屏幕的可变信息 */ ret = copy_to_user(argp, \u0026amp;var, sizeof(var)) ? -EFAULT : 0; break; ... /* 得到屏幕的固定信息，同上 */ case FBIOGET_FSCREENINFO: if (!lock_fb_info(info)) return -ENODEV; /* 得到fb_info 中的固定信息fix */ fix = info-\u0026gt;fix; unlock_fb_info(info); /* 向用户空间copy屏幕的固定信息 */ ret = copy_to_user(argp, \u0026amp;fix, sizeof(fix)) ? -EFAULT : 0; break; ...  5.2.3. fb_mmap static int fb_mmap(struct file *file, struct vm_area_struct * vma) { struct fb_info *info = file_fb_info(file); struct fb_ops *fb; unsigned long mmio_pgoff; unsigned long start; u32 len; if (!info) return -ENODEV; fb = info-\u0026gt;fbops; if (!fb) return -ENODEV; mutex_lock(\u0026amp;info-\u0026gt;mm_lock); /* 如果有自己的fb_mmap函数，就执行自己的 */ if (fb-\u0026gt;fb_mmap) { int res; res = fb-\u0026gt;fb_mmap(info, vma); mutex_unlock(\u0026amp;info-\u0026gt;mm_lock); return res; } /* * 备选方案 * Ugh. This can be either the frame buffer mapping, or * if pgoff points past it, the mmio mapping. */ start = info-\u0026gt;fix.smem_start; len = info-\u0026gt;fix.smem_len; mmio_pgoff = PAGE_ALIGN((start \u0026amp; ~PAGE_MASK) + len) \u0026gt;\u0026gt; PAGE_SHIFT; if (vma-\u0026gt;vm_pgoff \u0026gt;= mmio_pgoff) { if (info-\u0026gt;var.accel_flags) { mutex_unlock(\u0026amp;info-\u0026gt;mm_lock); return -EINVAL; } vma-\u0026gt;vm_pgoff -= mmio_pgoff; start = info-\u0026gt;fix.mmio_start; len = info-\u0026gt;fix.mmio_len; } mutex_unlock(\u0026amp;info-\u0026gt;mm_lock); vma-\u0026gt;vm_page_prot = vm_get_page_prot(vma-\u0026gt;vm_flags); fb_pgprotect(file, vma, start); /*返回映射好的framebuffer的地址。*/ return vm_iomap_memory(vma, start, len); }  ","date":1613129163,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1613129163,"objectID":"b805f1497cc8df1ba59a1ad75458fd9d","permalink":"https://strivefar.github.io/project/post/fbmem%E5%88%86%E6%9E%90/","publishdate":"2021-02-12T19:26:03+08:00","relpermalink":"/project/post/fbmem%E5%88%86%E6%9E%90/","section":"project","summary":"1. file_operations结构体 2. 入口函数 3. 注册函数 3.1. register_framebuffer 3.2. do_register_framebuffer 4. 驱动调用关系 4.1. fbmem.c的作用 4.2. 调用示例 5. 结合app分析LCD驱动程","tags":[],"title":"Fbmem分析","type":"project"},{"authors":["youngfar"],"categories":[],"content":" 1. class：设备的大管家  1.1. 设备管理流程   2. 创建一个class  2.1. class_create宏   3. 在class下添加kobject对象  3.1. device_create()函数    1. class：设备的大管家  硬件设备分类管理 与udev协作，自动创建设备文件  1.1. 设备管理流程   先调用register_chrdev()注册设备（提交fileo_preation结构体）\n  再调用class_create() 创建类用于相同类型的设备管理\n  最后调用device_create()，将注册的设备归于某一类下，记得传入设备号，这样才能找到第一步注册的设备\n  2. 创建一个class include/linux/device.h\n2.1. class_create宏 #define class_create(owner, name)\t\\ ({\t\\ static struct lock_class_key __key;\t\\ __class_create(owner, name, \u0026amp;__key);\\ })   owner：一般设置为THIS_MODULE name：kobject对象的名字  struct class *__class_create(struct module *owner, const char *name, struct lock_class_key *key)   struct class里面\u0026quot;继承\u0026quot;了kobject对象  3. 在class下添加kobject对象 include/linux/device.h\n3.1. device_create()函数 struct device *device_create(struct class *class, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...)    class：新构建的class\n  parent：新kobject对象的上一层节点，一般为NULL\n  dev_t：属性文件记录该设备号\n  drvdata：私有数据，一般为NULL\n  fmt：变参参数，一般用来设置kobject对象的名字\n  ","date":1613122095,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1613122095,"objectID":"812b4e462da62f768a192ae8769255b0","permalink":"https://strivefar.github.io/project/post/class%E8%AE%BE%E5%A4%87%E5%A4%A7%E7%AE%A1%E5%AE%B6/","publishdate":"2021-02-12T17:28:15+08:00","relpermalink":"/project/post/class%E8%AE%BE%E5%A4%87%E5%A4%A7%E7%AE%A1%E5%AE%B6/","section":"project","summary":"1. class：设备的大管家 1.1. 设备管理流程 2. 创建一个class 2.1. class_create宏 3. 在class下添加kobject对象 3.1. device","tags":["linux"],"title":"Class设备大管家","type":"project"},{"authors":["youngfar"],"categories":[],"content":" 1. 怎么确定“系统目录”？ 2. Linux编译程序时找不到头文件的解决办法  2.1. Linux编译程序时如果找不到头文件会提示如下错误： 2.2. 解决方法：   3. 安装过程  3.1. 注意： 3.2. 首先安装zlib库  3.2.1. copy编译好的库到“系统目录”   3.3. 其次安装libpng库  3.3.1. copy编译好的库到“系统目录”   3.4. 最后安装freetype库  3.4.1. copy编译好的库到“系统目录”     4. Makefile配置： 5. 参考来源：  1. 怎么确定“系统目录”？ echo 'main(){}'| arm-linux-gnueabihf-gcc -E -v -  系统头文件目录 以stdio.h为例：\n/home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/include  系统库目录LIBRARY_PATH：\n/home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/lib  2. Linux编译程序时找不到头文件的解决办法 2.1. Linux编译程序时如果找不到头文件会提示如下错误： error: xxx.h: No such file or directory #include \u0026lt;xxx.h\u0026gt; ^  2.2. 解决方法： 下面叙述以Ubuntu系统为例。\n 先查找 xxx.h 所在路径：  $ sudo find / -name xxx.h /usr/local/include/xxx/xxx.h   库的来源问题：\n假设这个库文件是我们自己写的，那么只要在编译时用-I选项指定自定义头文件的dir即可，或者规范一些，可以把这个头文件放入系统目录的中，方便后续使用#include \u0026lt;xxx.h\u0026gt;，直接系统目录下查找。\n假设这个库文件不是我们自己写的，即对于系统目录，#include \u0026lt;xxx.h\u0026gt; 我们执行find命令有可能查出不止一个xxx.h,他们的名字相同，但是目录不同，这样还是不知道是哪个目录。\n  查寻main()函数所需的系统库文件目录\n鉴于只执行find命令后出现了多个xxx.h所在路径，我们若想快速定位到我们所需的系统库文件的目录，就需要查一下运行main()函数时所依赖的系统库文件\n执行\necho 'main(){}'| arm-linux-gnueabihf-gcc -E -v -  系统会列出头文件目录、库目录(LIBRARY_PATH)\n  结合第1和3两者的打印信息，即可快速确定系统目录的路径\n  然后用-I选项把目录加上编译：\n$ gcc test.c -o test -I /home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/include    双引号是首先在使用include的源文件所在目录找，如果未找到，则到在编译器工作路径下继续寻找。“\u0026lt;\u0026gt;”在编译器工作路径下查找\nhttps://blog.csdn.net/vegetable_bird_001/article/details/50905244\nhttps://my.oschina.net/2bit/blog/389556\n3. 安装过程 3.1. 注意：   这里make和install如果无权限受限问题尽量不要使用管理员权限进行安装，即不要加sudo，否则编译时，输入make指令后，系统有可能出现make:arm-linux-gnueabihf-gcc: Command not found这样的错误。\n可能的原因：在root权限下，环境变量中没有添加arm-linux-gnueabihf-gcc所在的路径。\n如果您就是需要在root路径下运行的话可以参考这篇文章https://blog.csdn.net/whocarea/article/details/103365339\n  编译其他库的时候要看其他库的configure的参数是否支持\u0026ndash;host，不支持的话需要export CC设置为你的arm工具链\n  切记：不要安装共享文件夹中共享的文件\n在虚拟机中编译freetype时不要使用共享文件夹去共享库，否则会报错如下：\nln: failed to create symbolic link ‘libavutil.so’: Operation not supported\n这个问题主要原因是在使用ln创建软连接时候失败了，因为这个文件系统是NTFS，windows上的，通过虚拟机挂载到linux上，所以并不支持ln操作。\n解决方法：\n1.安装VMTools，把freetype和其相关的依赖包拷贝到linux中再编译。\n2.通过FileZilla把freetype和其相关的依赖包通过sftp传输到linux系统中，就可以直接编译了。\n  3.2. 首先安装zlib库 zlib的官网地址：http://www.zlib.net/\n编译zlib库时，./configure不允许传入–host参数；不支持的话需要export CC设置为你的arm工具链 这里通过 $ export CC=arm-linux-gnueabihf-gcc（根据自己的交叉编译工具链修改arm-linux-gnueabihf-gcc） 进行配置交叉编译工具。\ncd zlib-1.2.11 export CC=arm-linux-gnueabihf-gcc ./configure --prefix=$PWD/tmp make make install  3.2.1. copy编译好的库到“系统目录” book@100ask:~/mytest/zlib-1.2.11$ cd tmp/include/ book@100ask:~/mytest/zlib-1.2.11/tmp/include$ cp -rf * /home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/include book@100ask:~/mytest/zlib-1.2.11/tmp/include$ cd ../lib/ book@100ask:~/mytest/zlib-1.2.11/tmp/lib$ cp -drf * /home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/lib  3.3. 其次安装libpng库 安装好zlib库后，再进行libpng库的安装。\ncd libpng-1.6.37 export LDFLAGS=\u0026quot;-L/home/book/mytest/zlib-1.2.11\u0026quot; export CPPFLAGS=\u0026quot;-L/home/book/mytest/zlib-1.2.11\u0026quot; ./configure --host=arm-linux-gnueabihf --prefix=$PWD/tmp make sudo make install  注意：这里的LDFLAGS和CPPFLAGS要使用刚刚的zlib-1.2.11的绝对路径,否则libpng报错：zlib not installed。\n3.3.1. copy编译好的库到“系统目录” book@100ask:~/mytest/libpng-1.6.37$ cd tmp/ book@100ask:~/mytest/libpng-1.6.37/tmp$ ls bin include lib share book@100ask:~/mytest/libpng-1.6.37/tmp$ cd include/ book@100ask:~/mytest/libpng-1.6.37/tmp/include$ ls libpng16 pngconf.h png.h pnglibconf.h book@100ask:~/mytest/libpng-1.6.37/tmp/include$ cp -rf * /home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/include book@100ask:~/mytest/libpng-1.6.37/tmp/include$ cd ../lib/ book@100ask:~/mytest/libpng-1.6.37/tmp/lib$ ls libpng16.a libpng16.la libpng16.so libpng16.so.16 libpng16.so.16.37.0 libpng.a libpng.la libpng.so pkgconfig book@100ask:~/mytest/libpng-1.6.37/tmp/lib$ cp -drf * /home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/lib  3.4. 最后安装freetype库 cd freetype-2.10.2 ./configure --host=arm-linux-gnueabihf --prefix=$PWD/tmp make make install  3.4.1. copy编译好的库到“系统目录” book@100ask:~/mytest/freetype-2.10.2$ cd tmp book@100ask:~/mytest/freetype-2.10.2/tmp$ ls include lib share book@100ask:~/mytest/freetype-2.10.2/tmp$ cd include/ book@100ask:~/mytest/freetype-2.10.2/tmp/include$ cp -rf * /home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/include book@100ask:~/mytest/freetype-2.10.2/tmp/include$ cd ../lib/ book@100ask:~/mytest/freetype-2.10.2/tmp/lib$ cp -drf * /home/book/100ask_imx6ull-sdk/ToolChain/gcc-linaro-6.2.1-2016.11-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/usr/lib  4. Makefile配置： CFLAGS := -Wall -O2 -g CFLAGS += -I $(shell pwd)/include LDFLAGS := -lfreetype export CFLAGS LDFLAGS  此处Makefile中要指定链接库-lfreetype\n详见：https://www.cnblogs.com/taskiller/archive/2012/12/14/2817650.html\nCFLAGS 表示用于 C 编译器的选项， CXXFLAGS 表示用于 C++ 编译器的选项。 这两个变量实际上涵盖了编译和汇编两个步骤。\nCFLAGS： 指定头文件（.h文件）的路径，如：CFLAGS=-I/usr/include -I/path/include。同样地，安装一个包时会在安装路径下建立一个include目录，当安装过程中出现问题时，试着把以前安装的包的include目录加入到该变量中来。\nLDFLAGS：gcc 等编译器会用到的一些优化参数，也可以在里面指定库文件的位置。用法：LDFLAGS=-L/usr/lib -L/path/to/your/lib。每安装一个包都几乎一定的会在安装目录里建立一个lib目录。如果明明安装了某个包，而安装另一个包时，它愣是说找不到，可以抒那个包的lib路径加入的LDFALGS中试一下。\nLIBS：告诉链接器要链接哪些库文件，如LIBS = -lpthread -liconv\n简单地说，LDFLAGS是告诉链接器从哪里寻找库文件，而LIBS是告诉链接器要链接哪些库文件。不过使用时链接阶段这两个参数都会加上，所以你即使将这两个的值互换，也没有问题。\n最后，简单测试一下：执行make\n5. 参考来源： 特此感谢！\n韦东山老师的视频教程\n交叉编译libpng报错：configure: error: zlib not installed\nMakefile选项CFLAGS,LDFLAGS,LIBS\n#include\u0026lt;\u0026gt; 和 #include\u0026quot;\u0026ldquo;的区别\n关于C语言include尖括号和双引号的对话\n","date":1610266509,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1610266509,"objectID":"dc7051efda79dd21a65f2e4c3629296d","permalink":"https://strivefar.github.io/project/post/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E5%BA%93%E6%96%87%E4%BB%B6/","publishdate":"2021-01-10T16:15:09+08:00","relpermalink":"/project/post/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E5%BA%93%E6%96%87%E4%BB%B6/","section":"project","summary":"1. 怎么确定“系统目录”？ 2. Linux编译程序时找不到头文件的解决办法 2.1. Linux编译程序时如果找不到头文件会提示如下错误： 2.2. 解决方法： 3. 安装","tags":["嵌入式","linux","IMX6ULL"],"title":"交叉编译安装库文件","type":"project"},{"authors":["youngfar"],"categories":[],"content":" 1. LCD英文输出 2. LCD 中文输出 3. LCD中英文混合输出（ANSI编码+ASCII码) 4. 调用 5. 编译程序——编码格式与编译格式  5.1. 指定编码格式 5.2. 编译命令： 5.3. Makefile中指定编译选项   6. 显示效果 7. 本节全部代码gitee仓库地址 8. 参考链接  1. LCD英文输出 /********************************************************************** * 函数名称： lcd_put_ascii * 功能描述： 在LCD指定位置上显示一个8*16的字符 * 输入参数： x坐标，y坐标，c:ascii码, disp_color字符颜色， bak_grd_color背景颜色 * 输出参数： 无 * 返 回 值： 无 * 修改日期 版本号 修改人\t修改内容 * ----------------------------------------------- * 2020/05/12\tV1.0\tzh(angenao)\t创建 ***********************************************************************/ void lcd_put_ascii(int x, int y, char c, unsigned int disp_color, unsigned int bak_grd_color) { unsigned int i, j; const unsigned char *dots = \u0026amp;fontdata_8x16[c*16]; unsigned char data, bit; for(j = y; j \u0026lt; y+16; j++ ) { data = *dots++; bit = 7; for(i = x; i \u0026lt; x+8; i++) { /* 根据点阵的某位决定是否描颜色 */ if(data \u0026amp; (1 \u0026lt;\u0026lt; bit) \u0026amp;\u0026amp; (j \u0026lt; var.yres)) lcd_put_pixel(i, j, disp_color);/* 字符颜色 */ else if ((j \u0026lt; var.yres)) lcd_put_pixel(i, j, bak_grd_color);/* 背景色 */ bit--; } } }  2. LCD 中文输出 /********************************************************************** * 函数名称： lcd_put_chinese * 功能描述： 在LCD指定位置上显示一个16*16的汉字 * 输入参数： x坐标，y坐标，str中文字符串，disp_color字符颜色， bak_grd_color背景颜色 * 输出参数： 无 * 返 回 值： 无 * 修改日期 版本号 修改人\t修改内容 * ----------------------------------------------- * 2020/05/12\tV1.0\tzh(angenao)\t创建 ***********************************************************************/ void lcd_put_chinese(int x, int y, unsigned char *str, unsigned int disp_color, unsigned int bak_grd_color) { unsigned int area = str[0] - 0xA1; unsigned int where = str[1] - 0xA1; unsigned char *dots = hzkmem + (area * 94 + where)*32; unsigned char byte; int i, j, b; for (i = 0; i \u0026lt; 16; i++) for (j = 0; j \u0026lt; 2; j++) { byte = dots[i*2 + j]; for (b = 7; b \u0026gt;=0; b--) /* 对x做限制 */ { if (byte \u0026amp; (1\u0026lt;\u0026lt;b) \u0026amp;\u0026amp; (y+i) \u0026lt; var.yres) { /* show */ lcd_put_pixel(x+j*8+7-b, y+i, disp_color); /* 字符颜色 */ } else if (((y+i) \u0026lt; var.yres)) { /* hide */ lcd_put_pixel(x+j*8+7-b, y+i, bak_grd_color); /* 背景色 */ }\t} } }  3. LCD中英文混合输出（ANSI编码+ASCII码) /********************************************************************** * 函数名称： lcd_put_mix_str * 功能描述： 在LCD指定位置输出混合的中英文字符，比如“中国china”，支持自动换行,优化了边框显示，使所有字符显示完整。 * 输入参数： x坐标，y坐标，str中英文混合字符串，disp_color字符颜色， bak_grd_color背景颜色 * 输出参数： 无 * 返 回 值： 无 * 修改日期 版本号 修改人\t修改内容 * ----------------------------------------------- * 2021/01/01\tV1.0\tyoungfar\t创建 ***********************************************************************/ void lcd_put_mix_str(int x, int y, unsigned char *str, unsigned int disp_color, unsigned int bak_grd_color) { unsigned char *p = str; unsigned int pixel = 0, j = 0, i = 0; unsigned char *tmp = (unsigned char *)malloc(sizeof(unsigned char) * ANSI + 1); memset(tmp, '\\0', sizeof(unsigned char) * ANSI + 1); /* j \u0026lt;= (var.yres - 16)：对边框显示做处理,字符是8X16或16X16的像素面积，当(i,j)落在距离屏幕底部的像素距离\u0026lt;16时，字符会显示不全，即便显示全也会访问越界出现段错误，此时停止显示 */ for (i = (x + pixel) % var.xres, j = y + 16 * ((x + pixel) / var.xres); *p != '\\0' \u0026amp;\u0026amp; j \u0026lt;= (var.yres - 16); i = (x + pixel) % var.xres, j = y + 16 * ((x + pixel) / var.xres)) { if (!((*p) \u0026gt;\u0026gt; 7) \u0026amp; 1) { /* 调试时用，显示打印在屏幕上的字符 */ //printf(\u0026quot;%c\u0026quot;, *p); /* 对边框做处理,ASCII字符是8X16的像素面积，当(i,j)落在距离屏幕右下角8X16的像素面积内时，字符会显示不全，即便显示全也会访问越界出现段错误，此时停止显示 */ if (i \u0026lt;= var.xres - BORDER_WIDTH_ASCII) lcd_put_ascii(i, j, *p++, disp_color, bak_grd_color); /*在屏幕中间显示8*16的字母A*/ pixel += 8; } else { memcpy(tmp, p, sizeof(unsigned char) * ANSI); p = p + ANSI; /* 对边框做处理,中文字符是16X16的像素面积，当(i,j)落在距离屏幕右下角16X16的像素面积内时，字符会显示不全，即便显示全也会访问越界出现段错误，此时停止显示 */ if (i \u0026lt;= var.xres - BORDER_WIDTH_ANSI) lcd_put_chinese(i, j, tmp, disp_color, bak_grd_color); pixel += 16; /* 调试时用，显示打印在屏幕上的字符 */ //printf(\u0026quot;chinese code: %02x %02x\\n\u0026quot;, tmp[0], tmp[1]); } } free(tmp); }  4. 调用 int main(int argc, char **argv) { unsigned char str[] =\u0026quot;对边框做处理,ASCII字符是8X16的像素面积，当(i,j)落在距离屏幕右下角8X16的像素面积内时，字符会显示不全，即便显示全也会访问越界,出现段错误，此时停止显示\u0026quot;; fd_fb = open(\u0026quot;/dev/fb0\u0026quot;, O_RDWR); if (fd_fb \u0026lt; 0) { printf(\u0026quot;can't open /dev/fb0\\n\u0026quot;); return -1; } if (ioctl(fd_fb, FBIOGET_VSCREENINFO, \u0026amp;var)) { printf(\u0026quot;can't get var\\n\u0026quot;); return -1; } line_width = var.xres * var.bits_per_pixel / 8; pixel_width = var.bits_per_pixel / 8; screen_size = var.xres * var.yres * var.bits_per_pixel / 8; fbmem = (unsigned char *)mmap(NULL , screen_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd_fb, 0); if (fbmem == (unsigned char *)-1) { printf(\u0026quot;can't mmap\\n\u0026quot;); return -1; } fd_hzk16 = open(\u0026quot;HZK16\u0026quot;, O_RDONLY); if (fd_hzk16 \u0026lt; 0) { printf(\u0026quot;can't open HZK16\\n\u0026quot;); return -1; } /* 由文件描述符获取文件信息到hzk_stat结构体。http://c.biancheng.net/cpp/html/314.html */ if(fstat(fd_hzk16, \u0026amp;hzk_stat)) { printf(\u0026quot;can't get fstat\\n\u0026quot;); return -1; } hzkmem = (unsigned char *)mmap(NULL , hzk_stat.st_size, PROT_READ, MAP_SHARED, fd_hzk16, 0); if (hzkmem == (unsigned char *)-1) { printf(\u0026quot;can't mmap for hzk16\\n\u0026quot;); return -1; } /* 清屏: 全部设为黑色 */ memset(fbmem, 0, screen_size); /* 在LCD指定位置上显示黑色的中英文混合字符串（背景色为护眼绿） */ lcd_put_mix_str(0, var.yres-16, str, black, Green_bean); munmap(fbmem , screen_size); close(fd_fb); /* 撤销定义，防止冲突 */ #undef ANSI #undef black #undef Green_bean #undef tangerine return 0;\t}  5. 编译程序——编码格式与编译格式 5.1. 指定编码格式 使用点阵字库时，中文字符的显示原理跟ASCII字符是一样的。要注意的地方在于中文的编码：在C源文件中它的编码方式是GB2312还是UTF-8？编译出的可执行程序，其中的汉字编码方式是GB2312还是UTF-8？ 注意：一般不会使用UTF-16的编码方式，在这种方式下ASCII字符也是用2字节来表示，而其中一个字节是0，但是在C语言中0表示字符串的结束符，会引起误会。 我们编写C程序时，可以使用ANSI编码，或是UTF-8编码；在编译程序时，可以使用以下的选项告诉编译器：\n-finput-charset=GB2312\n-finput-charset=UTF-8\n如果不指定“-finput-charset”，GCC就会默认C程序的编码方式为UTF-8，即使你是以ANSI格式保存，也会被当作UTF-8来对待。 对于编译出来的可执行程序，可以指定它里面的字符是以什么方式编码，可以使用以下的选项编译器： -fexec-charset=GB2312 -fexec-charset=UTF-8 如果不指定“-fexec-charset”，GCC就会默认编译出的可执行程序中字符的编码方式为UTF-8。\n如果“-finput-charset”与“-fexec-charset”不一样，编译器会进行格式转换。\n5.2. 编译命令： arm-linux-gnueabihf-gcc -o show_chinese show_chinese.c 注意：不同的板子，编译工具的前缀可能不一样。 注意：使用上述命令时show_chinese.c的编码格式必须是ANSI(GB2312)，否则编译时需要指定-fexec-charset=GB2312\n5.3. Makefile中指定编译选项 # finput:即使以ANSI格式保存，也会被当作UTF-8来对待; 指定可执行程序中的字符以ANSI方式编码。 CFLAGS := -Wall -O2 -g -finput-charset=UTF-8 -fexec-charset=GB2312  6. 显示效果 7. 本节全部代码gitee仓库地址 点此进入本节gitee仓库\n8. 参考链接 1.韦东山老师的嵌入式视频\n2.由文件描述符获取文件信息到hzk_stat结构体\n3.ANSI是什么编码？\n特此感谢！\n","date":1609504333,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1609504333,"objectID":"69ebc1a2d11cb086721a644e1b78aa6e","permalink":"https://strivefar.github.io/project/post/framebuffer%E4%B8%AD%E8%8B%B1%E6%96%87%E6%B7%B7%E5%90%88%E8%BE%93%E5%87%BA/","publishdate":"2021-01-01T20:32:13+08:00","relpermalink":"/project/post/framebuffer%E4%B8%AD%E8%8B%B1%E6%96%87%E6%B7%B7%E5%90%88%E8%BE%93%E5%87%BA/","section":"project","summary":"1. LCD英文输出 2. LCD 中文输出 3. LCD中英文混合输出（ANSI编码+ASCII码) 4. 调用 5. 编译程序——编码格式与编译格式 5.1. 指定编码格式 5.2. 编译命","tags":["嵌入式","linux","IMX6ULL"],"title":"Framebuffer中英文混合输出","type":"project"},{"authors":["youngfar"],"categories":["嵌入式","linux"],"content":" 1. inode——索引 2. struct file 3. cdev  3.1. 在Linux内核中： 3.2. 在Linux字符设备驱动中: 3.3. 用户空间访问该设备的程序: 3.4. 源码解析   4. 设备号分配  4.1. 两种方法分配设备号  4.1.1. 动态分配 4.1.2. 静态申请   4.2. 自动分配设备号+注册cdev   5. class 介绍  创建一个class  class_create宏   在class下添加kobject对象  device_create()函数     6. 字符设备驱动入口函数初始化流程 7. open函数如何查找file_operation的接口 参考来源  1. inode——索引 参考：http://blog.itpub.net/28291944/viewspace-2143703/\ninode 译成中文就是索引节点。每个存储设备或存储设备的分区（存储设备是硬盘、软盘、U盘 \u0026hellip; \u0026hellip; ）被格式化为文件系统后，应该有两部份，一部份是inode，另一部份是Block，Block是用来存储数据用的。而inode呢，就是用来存储这些数据的信息，这些信息包括文件大小、属主、归属的用户组、读写权限等。inode为每个文件进行信息索引，所以就有了inode的数值。操作系统根据指令，能通过inode值最快的找到相对应的文件。 做个比喻，比如一本书，存储设备或分区就相当于这本书，Block相当于书中的每一页，inode 就相当于这本书前面的目录，一本书有很多的内容，如果想查找某部份的内容，我们可以先查目录，通过目录能最快的找到我们想要看的内容。\n当我们用ls 查看某个目录或文件时，如果加上-i 参数，就可以看到inode节点了；比如ls -li lsfile.sh ，最前面的数值就是inode信息\n2. struct file struct file结构体定义在include/linux/fs.h中定义。文件结构体代表一个打开的文件，系统中的每个打开的文件在内核空间都有一个关联的 struct file。它由内核在打开文件时创建，并传递给在文件上进行操作的任何函数。在文件的所有实例都关闭后，内核释放这个数据结构。在内核创建和驱动源码中，struct file的指针通常被命名为file或filp。\n3. cdev 此部分转自Linux 字符设备驱动结构（一）—— cdev 结构体、设备号相关知识解析，强烈建议大家看一下，这位博主写的非常好！\n3.1. 在Linux内核中： a \u0026ndash; 使用cdev结构体来描述字符设备;\nb \u0026ndash; 通过其成员dev_t来定义设备号（分为主、次设备号）以确定字符设备的唯一性;\nc \u0026ndash; 通过其成员file_operations来定义字符设备驱动提供给VFS的接口函数，如常见的open()、read()、write()等;\n3.2. 在Linux字符设备驱动中: a \u0026ndash; 模块加载函数通过 register_chrdev_region( ) 或 alloc_chrdev_region( )来静态或者动态获取设备号;\nb \u0026ndash; 通过 cdev_init( ) 建立cdev与 file_operations之间的连接，通过 cdev_add( ) 向系统添加一个cdev以完成注册;\nc \u0026ndash; 模块卸载函数通过cdev_del( )来注销cdev，通过 unregister_chrdev_region( )来释放设备号;\n3.3. 用户空间访问该设备的程序: a \u0026ndash; 通过Linux系统调用，如open( )、read( )、write( )，来“调用”file_operations来定义字符设备驱动提供给VFS的接口函数;\n3.4. 源码解析 这里简单说一下cdev_add()将新的struct probe 添加到散列表中，其中的void* data则和cdev绑定，方便后续open系统调用使用。\nint cdev_add(struct cdev *p, dev_t dev, unsigned count) { int error; p-\u0026gt;dev = dev; p-\u0026gt;count = count; error = kobj_map(cdev_map, dev, count, NULL, exact_match, exact_lock, p); if (error) return error; kobject_get(p-\u0026gt;kobj.parent); return 0; }  重点来看一下kobj_map函数：\n4. 设备号分配 4.1. 两种方法分配设备号 register_chrdev_region和alloc_chrdev_region是新版本推荐使用的主设备号注册函数，优点是注册的次设备号的数量可以自己决定，缺点就是需要自己完成cdev的init 和 add。二者的对比如下：\n4.1.1. 动态分配 alloc_chrdev_region：内核自动分配设备号，用于动态注册（因为内部调用__register_chrdev_region()时传入的主设备号为0），优先从254~234范围内进行主设备号的分配，如果不在此范围内，内核会给出警告\nint alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name) { struct char_device_struct *cd; cd = __register_chrdev_region(0, baseminor, count, name); if (IS_ERR(cd)) return PTR_ERR(cd); *dev = MKDEV(cd-\u0026gt;major, cd-\u0026gt;baseminor); return 0; }  4.1.2. 静态申请 register_chrdev_region：用于静态注册，用于设备号已知的情况下进行静态注册，如果传入的主设备号为0，则也相当于动态注册，原因就在于无论是register_chrdev_region还是alloc_chrdev_region ，其内部都调用了__register_chrdev_region()函数。\nint register_chrdev_region(dev_t from, unsigned count, const char *name) { struct char_device_struct *cd; dev_t to = from + count; dev_t n, next; for (n = from; n \u0026lt; to; n = next) { next = MKDEV(MAJOR(n)+1, 0); if (next \u0026gt; to) next = to; cd = __register_chrdev_region(MAJOR(n), MINOR(n), next - n, name); if (IS_ERR(cd)) goto fail; } return 0; fail: to = n; for (n = from; n \u0026lt; to; n = next) { next = MKDEV(MAJOR(n)+1, 0); kfree(__unregister_chrdev_region(MAJOR(n), MINOR(n), next - n)); } return PTR_ERR(cd); }  __register_chrdev_region(): Register a single major with a specified minor range.\n注册单个主设备号及旗下指定范围的次设备号。\nif (major == 0) { for (i = ARRAY_SIZE(chrdevs)-1; i \u0026gt; 0; i--) { if (chrdevs[i] == NULL) break; } if (i \u0026lt; CHRDEV_MAJOR_DYN_END) pr_warn(\u0026quot;CHRDEV \\\u0026quot;%s\\\u0026quot; major number %d goes below the dynamic allocation range\\n\u0026quot;, name, i); if (i == 0) { ret = -EBUSY; goto out; } major = i; }  __register_chrdev_region()调用图解，填充chrdevs散列表，记录主次设备号。\n4.2. 自动分配设备号+注册cdev register_chrdev是老版本的内核常用的，缺点就是一次申请255个次设备号，占用内存多，容易造成资源浪费。之所以一次注册255个次设备号是因为其内部调用__register_chrdev_region()函数时传入了如下参数：\nstatic inline int register_chrdev(unsigned int major, const char *name, const struct file_operations *fops) { return __register_chrdev(major, 0, 256, name, fops); }  优点就是这个函数不仅帮我们完成了设备号的分配，内部还调用了cdev_add()和cdev_init()函数自动的完成了struct probe *probes[255]散列表的初始化和注册，probes用来管理cdev，虽然做了很多无用功，但这样让代码看起来更简洁。\n参数及返回值：\n传入 0 则自动分配主设备号，否则使用自定义主设备号+申请255个次设备号\n5. class 介绍 参考：https://blog.csdn.net/hustyangju/article/details/21018103\n一个类是一个设备的高级视图, 它抽象出低级的实现细节. 驱动可以见到一个SCSI 磁盘或者一个 ATA 磁盘, 在类的级别, 它们都是磁盘. 类允许用户空间基于它们做什么来使用设备, 而不是它们如何被连接或者它们如何工作.\n几乎所有的类都在 sysfs 中在 /sys/class 下出现. 因此, 例如, 所有的网络接口可在 /sys/class/net 下发现, 不管接口类型. 输入设备可在 /sys/class/input 下, 以及串行设备在 /sys/class/tty. 一个例外是块设备, 由于历史的原因在 /sys/block.\ncdev_add()执行后将会在/proc/devices文件中看到字符设备，但是在/dev/目录下没有生成相应的设备文件。直到class_device_create()执行后才会在/dev/目录下生成设备文件。而class_create()执行后会在/sys/class/目录下生成目录。\n创建一个class include/linux/device.h\nclass_create宏 #define class_create(owner, name)\t\\ ({\t\\ static struct lock_class_key __key;\t\\ __class_create(owner, name, \u0026amp;__key);\\ })   owner：一般设置为THIS_MODULE name：kobject对象的名字  struct class *__class_create(struct module *owner, const char *name, struct lock_class_key *key)   struct class里面\u0026quot;继承\u0026quot;了kobject对象  在class下添加kobject对象 include/linux/device.h\ndevice_create()函数 struct device *device_create(struct class *class, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...)    class：新构建的class\n  parent：新kobject对象的上一层节点，一般为NULL\n  dev_t：属性文件记录该设备号\n  drvdata：私有数据，一般为NULL\n  fmt：变参参数，一般用来设置kobject对象的名字\n  6. 字符设备驱动入口函数初始化流程 有了以上基础，下面用几个例子来说明一下关于字符设备的入口函数中函数的调用流程\n如果想方便省事，不在乎这点资源的浪费可以这样设计\nstatic int __init led_init(void) { int err; printk(\u0026quot;%s %s line %d\\n\u0026quot;, __FILE__, __FUNCTION__, __LINE__); major = register_chrdev(0, \u0026quot;100ask_led\u0026quot;, \u0026amp;led_drv); /* /dev/led */ led_class = class_create(THIS_MODULE, \u0026quot;100ask_led_class\u0026quot;); /* 这里之所以没有调用device_create()函数，是因为此框架下将具体单板的资源设备下层，通用的驱动设为上层，实现了驱动的上下分离 */ err = PTR_ERR(led_class); if (IS_ERR(led_class)) { printk(\u0026quot;%s %s line %d\\n\u0026quot;, __FILE__, __FUNCTION__, __LINE__); unregister_chrdev(major, \u0026quot;100ask_led\u0026quot;); return -1; } return 0; }  动态分配主设备号alloc_chrdev_region() + cdev_init() + cdev_add()\n/* 入口函数 */ static int adxl34x_drv_init(void) { int ret; dev_t adxl34x_devid; //printk(KERN_INFO\u0026quot;%s OK.\\n\u0026quot;,__func__); if(alloc_chrdev_region(\u0026amp;adxl34x_devid, 0, 1, \u0026quot;adxl345\u0026quot;) \u0026lt; 0) { printk(KERN_ERR\u0026quot;Unable to alloc_chrdev_region.\\n\u0026quot;); return -EINVAL; } adxl34x_major = MAJOR(adxl34x_devid); cdev_init(\u0026amp;adxl34x_cdev, \u0026amp;adxl34x_fops); ret = cdev_add(\u0026amp;adxl34x_cdev, adxl34x_devid, 1); if (ret \u0026lt; 0) { printk(KERN_ERR \u0026quot;Unable to cdev_add.\\n\u0026quot;); goto error; } adxl34x_class = class_create(THIS_MODULE, \u0026quot;adxl345\u0026quot;); device_create(adxl34x_class, NULL, MKDEV(adxl34x_major, 0), NULL, \u0026quot;adxl345\u0026quot;); return 0; error: unregister_chrdev_region(MKDEV(adxl34x_major, 0), 1); return -EINVAL; } /* 修饰入口函数 */ module_init(adxl34x_drv_init);  自定义静态分配主设备号示例：\nstatic int __init raw_init(void) { dev_t dev = MKDEV(RAW_MAJOR, 0); int ret; if (max_raw_minors \u0026lt; 1 || max_raw_minors \u0026gt; 65536) { printk(KERN_WARNING \u0026quot;raw: invalid max_raw_minors (must be\u0026quot; \u0026quot; between 1 and 65536), using %d\\n\u0026quot;, MAX_RAW_MINORS); max_raw_minors = MAX_RAW_MINORS; } raw_devices = vzalloc(sizeof(struct raw_device_data) * max_raw_minors); if (!raw_devices) { printk(KERN_ERR \u0026quot;Not enough memory for raw device structures\\n\u0026quot;); ret = -ENOMEM; goto error; } ret = register_chrdev_region(dev, max_raw_minors, \u0026quot;raw\u0026quot;); if (ret) goto error; cdev_init(\u0026amp;raw_cdev, \u0026amp;raw_fops); ret = cdev_add(\u0026amp;raw_cdev, dev, max_raw_minors); if (ret) goto error_region; raw_class = class_create(THIS_MODULE, \u0026quot;raw\u0026quot;); if (IS_ERR(raw_class)) { printk(KERN_ERR \u0026quot;Error creating raw class.\\n\u0026quot;); cdev_del(\u0026amp;raw_cdev); ret = PTR_ERR(raw_class); goto error_region; } raw_class-\u0026gt;devnode = raw_devnode; device_create(raw_class, NULL, MKDEV(RAW_MAJOR, 0), NULL, \u0026quot;rawctl\u0026quot;); return 0; error_region: unregister_chrdev_region(dev, max_raw_minors); error: vfree(raw_devices); return ret; }  还可以结合一下，做一个判断：\nif (major) { devid = MKDEV(major, 0); rc = register_chrdev_region(devid, PC8736X_GPIO_CT, DEVNAME); } else { rc = alloc_chrdev_region(\u0026amp;devid, 0, PC8736X_GPIO_CT, DEVNAME); major = MAJOR(devid); } ··· cdev_init(\u0026amp;pc8736x_gpio_cdev, \u0026amp;pc8736x_gpio_fileops); cdev_add(\u0026amp;pc8736x_gpio_cdev, devid, PC8736X_GPIO_CT);  于是，在入口函数中，我们将自定义的file_operations结构体的地址传给cdev_init()函数，函数内部将其与cdev结构体的ops绑定\nvoid cdev_init(struct cdev *cdev, const struct file_operations *fops) { memset(cdev, 0, sizeof *cdev); INIT_LIST_HEAD(\u0026amp;cdev-\u0026gt;list); kobject_init(\u0026amp;cdev-\u0026gt;kobj, \u0026amp;ktype_cdev_default); /* 指向传入的file_operations结构体 */ cdev-\u0026gt;ops = fops; }  那么，用户空间调用open函数是如何查找file_operation的接口的呢？\n7. open函数如何查找file_operation的接口 简单来讲，用户空间调用open函数，最终会导致内VFS调用chardev_open()函数，之后，struct file对象的f_op指向cdev的ops， 之后应用层调用read write等函数时便可以通过struct file的ops对象直接找到对应的驱动读写函数，对应最后一个框图中的“ 绿色通道 ”。\n  get_unused_fd_flags\n 为本次操作分配一个未使用过的文件描述符    do_file_opendd\n 生成一个空白struct file结构体 从文件系统中查找到文件对应的inode    do_dentry_open\n  static int do_dentry_open(struct file *f, struct inode *inode, int (*open)(struct inode *, struct file *)) { ... /*把inode的i_fop赋值给struct file的f_op*/ f-\u0026gt;f_op = fops_get(inode-\u0026gt;i_fop); ... if (!open) open = f-\u0026gt;f_op-\u0026gt;open; if (open) { error = open(inode, f); if (error) goto cleanup_all; } ... }    def_chr_fops-\u0026gt;chrdev_open\n​\tebf-buster-linux/fs/char_dev.c\n  static int chrdev_open(struct inode *inode, struct file *filp) { const struct file_operations *fops; struct cdev *p; struct cdev *new = NULL; ... struct kobject *kobj; int idx; /*从内核哈希表cdev_map中，根据设备号查找自己注册的sturct cdev，获取cdev中的file_operation接口*/ kobj = kobj_lookup(cdev_map, inode\u0026gt;i_rdev,\u0026amp;idx); new = container_of(kobj, struct cdev, kobj); ... inode-\u0026gt;i_cdev = p = new; ... fops = fops_get(p-\u0026gt;ops); ... /*把cdev中的file_operation接口赋值给struct file的f_op*/ replace_fops(filp, fops); /*调用自己实现的file_operation接口中的open函数*/ if (filp-\u0026gt;f_op-\u0026gt;open) { ret = filp-\u0026gt;f_op-\u0026gt;open(inode, filp); if (ret) goto out_cdev_put; } ... }  参考来源 http://blog.itpub.net/28291944/viewspace-2143703/\nhttps://blog.csdn.net/zqixiao_09/article/details/50839042\nhttps://blog.csdn.net/hustyangju/article/details/21018103\n野火嵌入式Linux视频\n","date":1608606045,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1608606045,"objectID":"08c604a40314ad93928249194aed8ca2","permalink":"https://strivefar.github.io/project/post/linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/","publishdate":"2020-12-22T11:00:45+08:00","relpermalink":"/project/post/linux%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90/","section":"project","summary":"1. inode——索引 2. struct file 3. cdev 3.1. 在Linux内核中： 3.2. 在Linux字符设备驱动中: 3.3. 用户空间访问该设备的程序: 3.4. 源码解析 4. 设备号分配 4.1. 两种方","tags":["嵌入式","linux"],"title":"Linux字符设备驱动——入口函数完全解析","type":"project"},{"authors":["youngfar"],"categories":[],"content":" 1. 什么是原子操作 2. 为什么要引入原子操作  2.1. 失败例子1 2.2. 失败例子2 2.3. 失败例子3   3. 原子操作实现——atomic.h解析 4. 内联汇编实现原子操作 5. 原子变量内核操作函数汇总  5.1. 设置原子变量的值 5.2. 操作原子变量 5.3. 操作原子变量中的某一位   6. 参考来源  1. 什么是原子操作 原子（atom）指化学反应不可再分的基本微粒，原子在化学反应中不可分割。\n在操作系统中，用原子的这一特性形象生动的描述了一种操作————原子操作，顾名思义，原子操作是不可分割的， 在执行完毕之前不被任何其它任务或事件中断或即便被中断但不影响最终结果的操作都可以称之为原子操作。\n在单处理器系统（UniProcessor）中，能够在单条指令中完成的操作都可以认为是\u0026rdquo; 原子操作\u0026rdquo;，因为中断只能发生于指令之间；那么多条指令可不可以构成原子操作呢，当然可以，只要确保这几条指令执行时不被抢占就好了，关闭总中断就可以做到。\n在多处理器SMP系统（Symmetric Multi-Processor）中，关中断可就不好使了，因为A处理器无法关闭它处理器的中断，A处理器只能关闭自己的中断。那么此时多条指令的执行还可以是“ 原子 ”的吗，其实也能，虽然被抢占是再所难免的，但只要保证被抢占者不会影响原执行者的最终结果不就好了。\n2. 为什么要引入原子操作 先明确两个概念：同步和互斥\n 同步，又称直接制约关系，是指多个线程（或进程）为了合作完成任务，必须严格按照规定的 某种先后次序来运行。 互斥，又称间接制约关系，是指系统中的某些共享资源，一次只允许一个线程访问。当一个线程正在访问该临界资源时，其它线程必须等待。  这里举几个同步与互斥失败的例子来说明构建原子操作的必要性，该部分内容完全摘自韦东山老师的教程文档。\n2.1. 失败例子1 01 static int valid = 1; 02 03 static ssize_t gpio_key_drv_open (struct inode *node, struct file *file) 04 { 05 if (!valid) 06 { 07 return -EBUSY; 08 } 09 else 10 { 11 valid = 0; 12 } 13 14 return 0; //成功 15 } 16 17 static int gpio_key_drv_close (struct inode *node, struct file *file) 18 { 19 valid = 1; 20 return 0; 21 }  看第5行，我们使用一个全局变量valid来实现互斥访问。这有问题吗？很大概率没问题，但是并非万无一失。 注意：编写驱动程序时，要有系统的概念，程序A调用驱动程序时，它可能被程序B打断，程序B也去调用这个驱动程序。 下图是一个例子，程序A在调用驱动程序的中途被程序B抢占了CPU资源： 程序A执行到第11行之前，被程序B抢占了，这时valid尚未被改成0； 程序B调用gpio_key_drv_open时，发现valid等于1，所以成功返回0； 当程序A继续从第11行执行时，它最终也成功返回0； 这样程序A、B都成功打开了驱动程序。 注意：在内核态，程序A不是主动去休眠、主动放弃CPU资源；而是被优先级更高的程序B抢占了，这种行为被称为“preempt”(抢占)。\n2.2. 失败例子2 上面的例子是不是第5行到第11行的时间跨度大长了？再优化一下程序行不行？代码如下：\n01 static int valid = 1; 02 03 static ssize_t gpio_key_drv_open (struct inode *node, struct file *file) 04 { 05 if (--valid) 06 { 07 valid++; 08 return -EBUSY; 09 } 10 return 0; 11 } 12 13 static int gpio_key_drv_close (struct inode *node, struct file *file) 14 { 15 valid = 1; 16 return 0; 17 }  第5行先减1再判断，这样可以更大概率地避免问题，但是还是不能确保万无一失。对数据的修改分为3步：读出来、修改、写进去。请看下图：\n进程A在读出valid时发现它是1，减1后为0，这时if不成立；但是修改后的值尚未写回内存； 假设这时被程序B抢占，程序B读出valid仍为1，减1后为0，这时if不成立，最后成功返回； 轮到A继续执行，它把0值写到valid变量，最后也成功返回。 这样程序A、B都成功打开了驱动程序。\n2.3. 失败例子3 前面2个例子，都是在修改valid的过程中被别的进程抢占了，那么在修改valid的时候直接关中断不就可以了吗？\n01 static int valid = 1; 02 03 static ssize_t gpio_key_drv_open (struct inode *node, struct file *file) 04 { 05 unsigned long flags; 06 raw_local_irq_save(flags); // 关中断 07 if (--valid) 08 { 09 valid++; 10 raw_local_irq_restore(flags); // 恢复之前的状态 11 return -EBUSY; 12 } 13 raw_local_irq_restore(flags); // 恢复之前的状态 14 return 0; 15 } 16 17 static int gpio_key_drv_close (struct inode *node, struct file *file) 18 { 19 valid = 1; 20 return 0; 21 }  第06行直接关中断，这样别的线程、中断都不能来打扰本线程了，在它读取、修改valid变量的过程中无人打扰。\n没有问题了？\n对于单CPU核的系统上述代码是没问题的；但是对于SMP系统，你只能关闭当前CPU核的中断，别的CPU核还可以运行程序，它们也可以来执行这个函数，同样导致问题，如下图： 假设CPU0上进程A、CPU1上进程B同时运行到上图中读出valid的地方，它们同时发现valid都是1，减减后都等于0，在第07行判断条件都不成立，所以在第14行都可以返回0，都可以成功打开驱动。\n3. 原子操作实现——atomic.h解析 为方便说明，这里对一些非关键的条件编译不做展开说明，完整的atomic.h文件路径为arch/arm/include/asm/atomic.h，您也可以点击下方链接，在线查看arch/arm/include/asm/atomic.h源码\natomic.h源码在线阅读\n#ifndef __ASM_ARM_ATOMIC_H #define __ASM_ARM_ATOMIC_H #include \u0026lt;linux/compiler.h\u0026gt; #include \u0026lt;linux/prefetch.h\u0026gt; #include \u0026lt;linux/types.h\u0026gt; #include \u0026lt;linux/irqflags.h\u0026gt; #include \u0026lt;asm/barrier.h\u0026gt; #include \u0026lt;asm/cmpxchg.h\u0026gt; #define ATOMIC_INIT(i) \\ { \\ (i) \\ } #ifdef __KERNEL__ /* 读写操作只需要一条指令即可完成，本身就是原子的 */ #define atomic_read(v) READ_ONCE((v)-\u0026gt;counter) #define atomic_set(v, i) WRITE_ONCE(((v)-\u0026gt;counter), (i)) /*******************************************************************/ /* * 根据不同架构版本做设置不同的#define宏函数 * ARMV6 以下，单核，无需内联汇编，直接关中断 * ARMv6 及以上，支持多核，一律内联汇编！ */ #if __LINUX_ARM_ARCH__ \u0026gt;= 6 ... Section A #else ... Section B #endif /* __LINUX_ARM_ARCH__ */ /*******************************************************************/ /* * ATOMIC_OPS 表示 ops即operations 表示一系列原子操作， * ATOMIC_OP， ATOMIC_OP_RETURN，ATOMIC_FETCH_OP这几个宏 在 省略部分A 和 省略部分B 各有不同的定义 */ #define ATOMIC_OPS(op, c_op, asm_op) \\ ATOMIC_OP(op, c_op, asm_op) \\ //这个宏还是没变 ATOMIC_OP_RETURN(op, c_op, asm_op) \\ ATOMIC_FETCH_OP(op, c_op, asm_op) ATOMIC_OPS(add, +=, add) ATOMIC_OPS(sub, -=, sub) #define atomic_andnot atomic_andnot /*******************************************************************/ /* 删除原来的ATOMIC_OPS宏 */ #undef ATOMIC_OPS /* 重新定义新的一系列原子操作 */ #define ATOMIC_OPS(op, c_op, asm_op) \\ ATOMIC_OP(op, c_op, asm_op) \\ //这个宏还是没变 ATOMIC_FETCH_OP(op, c_op, asm_op) ATOMIC_OPS(and, \u0026amp;=, and) ATOMIC_OPS(andnot, \u0026amp;= ~, bic) ATOMIC_OPS(or, |=, orr) ATOMIC_OPS(xor, ^=, eor) /*******************************************************************/ /* 删除原来的各个宏，将已定义的这些宏的作用域限制在了改行以上，在该行之后，如又调用该标识符，则程序会编译出错 */ #undef ATOMIC_OPS #undef ATOMIC_FETCH_OP #undef ATOMIC_OP_RETURN #undef ATOMIC_OP #define atomic_xchg(v, new) (xchg(\u0026amp;((v)-\u0026gt;counter), new)) #define atomic_inc(v) atomic_add(1, v) #define atomic_dec(v) atomic_sub(1, v) #define atomic_inc_and_test(v) (atomic_add_return(1, v) == 0) #define atomic_dec_and_test(v) (atomic_sub_return(1, v) == 0) #define atomic_inc_return_relaxed(v) (atomic_add_return_relaxed(1, v)) #define atomic_dec_return_relaxed(v) (atomic_sub_return_relaxed(1, v)) #define atomic_sub_and_test(i, v) (atomic_sub_return(i, v) == 0) #define atomic_add_negative(i, v) (atomic_add_return(i, v) \u0026lt; 0) /********************************************************************/ /*如果是64位的系统，则重复32位的流程，只是让操作适配64位系统*/ #ifndef CONFIG_GENERIC_ATOMIC64 ... 省略 #endif /* !CONFIG_GENERIC_ATOMIC64 */ /********************************************************************/ #endif /* end of __KERNEL__ */ #endif /* end of __ASM_ARM_ATOMIC_H */  刚刚省略掉的Section A 的代码如下：\n/* * ARMv6 UP and SMP safe atomic ops. We use load exclusive and * store exclusive to ensure that these are atomic. We may loop * to ensure that the update happens. * * ARMv6 UP和SMP安全原子操作。我们使用加载独占和存储独占来确保它们是原子的。 * 我们可以循环以确保更新发生。 */ /* * 这部分主要定义了宏操作，然后二次封装进ATOMIC_OPS宏中， * 这样就可以使用类似ATOMIC_OPS(and, \u0026amp;=, and)这样的操作做置换了 */ #define ATOMIC_OP(op, c_op, asm_op) \\ static inline void atomic_##op(int i, atomic_t *v) \\ { \\ unsigned long tmp; \\ int result; \\ \\ prefetchw(\u0026amp;v-\u0026gt;counter); \\ __asm__ __volatile__(\u0026quot;@ atomic_\u0026quot; #op \u0026quot;\\n\u0026quot; \\ \u0026quot;1:\tldrex\t%0, [%3]\\n\u0026quot; \\ \u0026quot;\t\u0026quot; #asm_op \u0026quot;\t%0, %0, %4\\n\u0026quot; \\ \u0026quot;\tstrex\t%1, %0, [%3]\\n\u0026quot; \\ \u0026quot;\tteq\t%1, #0\\n\u0026quot; \\ \u0026quot;\tbne\t1b\u0026quot; \\ : \u0026quot;=\u0026amp;r\u0026quot;(result), \u0026quot;=\u0026amp;r\u0026quot;(tmp), \u0026quot;+Qo\u0026quot;(v-\u0026gt;counter) \\ : \u0026quot;r\u0026quot;(\u0026amp;v-\u0026gt;counter), \u0026quot;Ir\u0026quot;(i) \\ : \u0026quot;cc\u0026quot;); \\ } #define ATOMIC_OP_RETURN(op, c_op, asm_op) \\ static inline int atomic_##op##_return_relaxed(int i, atomic_t *v) \\ { \\ unsigned long tmp; \\ int result; \\ \\ prefetchw(\u0026amp;v-\u0026gt;counter); \\ \\ __asm__ __volatile__(\u0026quot;@ atomic_\u0026quot; #op \u0026quot;_return\\n\u0026quot; \\ \u0026quot;1:\tldrex\t%0, [%3]\\n\u0026quot; \\ \u0026quot;\t\u0026quot; #asm_op \u0026quot;\t%0, %0, %4\\n\u0026quot; \\ \u0026quot;\tstrex\t%1, %0, [%3]\\n\u0026quot; \\ \u0026quot;\tteq\t%1, #0\\n\u0026quot; \\ \u0026quot;\tbne\t1b\u0026quot; \\ : \u0026quot;=\u0026amp;r\u0026quot;(result), \u0026quot;=\u0026amp;r\u0026quot;(tmp), \u0026quot;+Qo\u0026quot;(v-\u0026gt;counter) \\ : \u0026quot;r\u0026quot;(\u0026amp;v-\u0026gt;counter), \u0026quot;Ir\u0026quot;(i) \\ : \u0026quot;cc\u0026quot;); \\ \\ return result; \\ } #define ATOMIC_FETCH_OP(op, c_op, asm_op) \\ static inline int atomic_fetch_##op##_relaxed(int i, atomic_t *v) \\ { \\ unsigned long tmp; \\ int result, val; \\ \\ prefetchw(\u0026amp;v-\u0026gt;counter); \\ \\ __asm__ __volatile__(\u0026quot;@ atomic_fetch_\u0026quot; #op \u0026quot;\\n\u0026quot; \\ \u0026quot;1:\tldrex\t%0, [%4]\\n\u0026quot; \\ \u0026quot;\t\u0026quot; #asm_op \u0026quot;\t%1, %0, %5\\n\u0026quot; \\ \u0026quot;\tstrex\t%2, %1, [%4]\\n\u0026quot; \\ \u0026quot;\tteq\t%2, #0\\n\u0026quot; \\ \u0026quot;\tbne\t1b\u0026quot; \\ : \u0026quot;=\u0026amp;r\u0026quot;(result), \u0026quot;=\u0026amp;r\u0026quot;(val), \u0026quot;=\u0026amp;r\u0026quot;(tmp), \u0026quot;+Qo\u0026quot;(v-\u0026gt;counter) \\ : \u0026quot;r\u0026quot;(\u0026amp;v-\u0026gt;counter), \u0026quot;Ir\u0026quot;(i) \\ : \u0026quot;cc\u0026quot;); \\ \\ return result; \\ } /* 这里不是很清楚为什么要重复封装，可能是为了方便修改接口吧，还请评论区指点 */ #define atomic_add_return_relaxed atomic_add_return_relaxed #define atomic_sub_return_relaxed atomic_sub_return_relaxed #define atomic_fetch_add_relaxed atomic_fetch_add_relaxed #define atomic_fetch_sub_relaxed atomic_fetch_sub_relaxed #define atomic_fetch_and_relaxed atomic_fetch_and_relaxed #define atomic_fetch_andnot_relaxed atomic_fetch_andnot_relaxed #define atomic_fetch_or_relaxed atomic_fetch_or_relaxed #define atomic_fetch_xor_relaxed atomic_fetch_xor_relaxed static inline int atomic_cmpxchg_relaxed(atomic_t *ptr, int old, int new) { int oldval; unsigned long res; prefetchw(\u0026amp;ptr-\u0026gt;counter); do { __asm__ __volatile__(\u0026quot;@ atomic_cmpxchg\\n\u0026quot; \u0026quot;ldrex\t%1, [%3]\\n\u0026quot; \u0026quot;mov\t%0, #0\\n\u0026quot; \u0026quot;teq\t%1, %4\\n\u0026quot; \u0026quot;strexeq %0, %5, [%3]\\n\u0026quot; : \u0026quot;=\u0026amp;r\u0026quot;(res), \u0026quot;=\u0026amp;r\u0026quot;(oldval), \u0026quot;+Qo\u0026quot;(ptr-\u0026gt;counter) : \u0026quot;r\u0026quot;(\u0026amp;ptr-\u0026gt;counter), \u0026quot;Ir\u0026quot;(old), \u0026quot;r\u0026quot;(new) : \u0026quot;cc\u0026quot;); } while (res); return oldval; } /* 这里不是很清楚为什么要重复封装，可能是为了方便修改接口吧，还请评论区指点 */ #define atomic_cmpxchg_relaxed atomic_cmpxchg_relaxed static inline int __atomic_add_unless(atomic_t *v, int a, int u) { int oldval, newval; unsigned long tmp; smp_mb(); prefetchw(\u0026amp;v-\u0026gt;counter); //写预取 __asm__ __volatile__(\u0026quot;@ atomic_add_unless\\n\u0026quot; \u0026quot;1:\tldrex\t%0, [%4]\\n\u0026quot; \u0026quot;\tteq\t%0, %5\\n\u0026quot; \u0026quot;\tbeq\t2f\\n\u0026quot; \u0026quot;\tadd\t%1, %0, %6\\n\u0026quot; \u0026quot;\tstrex\t%2, %1, [%4]\\n\u0026quot; \u0026quot;\tteq\t%2, #0\\n\u0026quot; \u0026quot;\tbne\t1b\\n\u0026quot; \u0026quot;2:\u0026quot; : \u0026quot;=\u0026amp;r\u0026quot;(oldval), \u0026quot;=\u0026amp;r\u0026quot;(newval), \u0026quot;=\u0026amp;r\u0026quot;(tmp), \u0026quot;+Qo\u0026quot;(v-\u0026gt;counter) : \u0026quot;r\u0026quot;(\u0026amp;v-\u0026gt;counter), \u0026quot;r\u0026quot;(u), \u0026quot;r\u0026quot;(a) : \u0026quot;cc\u0026quot;); if (oldval != u) smp_mb(); //*_mb()是读写访问内存屏障，它保证在屏障（调用*_mb()的位置处）之后的任何读操作在执行之前，屏障之前的所有读操作都已经完成。 return oldval; }  刚刚省略掉的Section B 的代码如下：\n/* * #error 是一种预编译器指示字，用于生成一个编译错误消息。 * 之前说了，对于SMP系统，关中断是无法实现原子操作的，所以这里会报错 */ #ifdef CONFIG_SMP #error SMP not supported on pre-ARMv6 CPUs #endif /* * raw_local_irq_save(flags); // 中断控制相关,保存并关闭中断 * raw_local_irq_restore(flags); //中断控制相关,恢复中断 */ #define ATOMIC_OP(op, c_op, asm_op) \\ static inline void atomic_##op(int i, atomic_t *v) \\ { \\ unsigned long flags; \\ \\ raw_local_irq_save(flags); \\ v-\u0026gt;counter c_op i; \\ raw_local_irq_restore(flags); \\ } #define ATOMIC_OP_RETURN(op, c_op, asm_op) \\ static inline int atomic_##op##_return(int i, atomic_t *v) \\ { \\ unsigned long flags; \\ int val; \\ \\ raw_local_irq_save(flags); \\ v-\u0026gt;counter c_op i; \\ val = v-\u0026gt;counter; \\ raw_local_irq_restore(flags); \\ \\ return val; \\ } #define ATOMIC_FETCH_OP(op, c_op, asm_op) \\ static inline int atomic_fetch_##op(int i, atomic_t *v) \\ { \\ unsigned long flags; \\ int val; \\ \\ raw_local_irq_save(flags); \\ val = v-\u0026gt;counter; \\ v-\u0026gt;counter c_op i; \\ raw_local_irq_restore(flags); \\ \\ return val; \\ } static inline int atomic_cmpxchg(atomic_t *v, int old, int new) { int ret; unsigned long flags; raw_local_irq_save(flags); ret = v-\u0026gt;counter; if (likely(ret == old)) v-\u0026gt;counter = new; raw_local_irq_restore(flags); return ret; } static inline int __atomic_add_unless(atomic_t *v, int a, int u) { int c, old; c = atomic_read(v); while (c != u \u0026amp;\u0026amp; (old = atomic_cmpxchg((v), c, c + a)) != c) c = old; return c; }  4. 内联汇编实现原子操作 上面的代码只是大体让我们了解了一下原子操作的基本架构，单核系统我们不在深究，主要细究一下多核系统如何实现原子操作的。\n我们以Section A 的 __atomic_add_unless 函数为例，对其中使用到的内联汇编做深度解析 该函数体如下：\n1 static inline int __atomic_add_unless(atomic_t *v, int a, int u) 2 { 3 int oldval, newval; 4 unsigned long tmp; 5 6 smp_mb(); 7 prefetchw(\u0026amp;v-\u0026gt;counter); //写预取 8 9 __asm__ __volatile__(\u0026quot;@ atomic_add_unless\\n\u0026quot; 10 \u0026quot;1: ldrex %0, [%4]\\n\u0026quot; //读取counter到oldval，并标记[%4]所指的内存为独占访问 11 \u0026quot; teq %0, %5\\n\u0026quot; //比较oldval和u是否相等 12 \u0026quot; beq 2f\\n\u0026quot; //相等则跳转至标签2，跳出该函数，不相等则继续顺序执行下—条指令 13 \u0026quot; add %1, %0, %6\\n\u0026quot; //newval = oldval + a，这里oldval 就是原来的counter，这是第①步的影响 14 \u0026quot; strex %2, %1, [%4]\\n\u0026quot; //如果执行这条指令的时候发现counter的独占访问标记还在，则把newval新值更新到[%4]所指的内存，并把tmp设为0，指令执行成功后，会清除独占访问标记位, //而如果这条指令执行时发现独占标记没有了，则该条指令不执行，不会更新内存，且将tmp的值设置成1,表明中途被打断，操作失败 15 \u0026quot; teq %2, #0\\n\u0026quot; //测试tmp的值是否为0，为0表示一切正常，为1表示对counter的访问不是独占的，就不会更新counter的值 16 \u0026quot; bne 1b\\n\u0026quot; //如果不相等则跳转到lable 1处重新执行，总有─次能成功 17 \u0026quot;2:\u0026quot; 18 : \u0026quot;=\u0026amp;r\u0026quot;(oldval), \u0026quot;=\u0026amp;r\u0026quot;(newval), \u0026quot;=\u0026amp;r\u0026quot;(tmp), \u0026quot;+Qo\u0026quot;(v-\u0026gt;counter) 19 : \u0026quot;r\u0026quot;(\u0026amp;v-\u0026gt;counter), \u0026quot;r\u0026quot;(u), \u0026quot;r\u0026quot;(a) 20 : \u0026quot;cc\u0026quot;); 21 22 if (oldval != u) 23 smp_mb(); //*_mb()是读写访问内存屏障，它保证在屏障（调用*_mb()的位置处）之后的任何读操作在执行之前，屏障之前的所有读操作都已经完成。 24 25 return oldval; 26 }    第十行和第14行：独占访问指令(参考来源：https://blog.csdn.net/Roland_Sun/article/details/47670099) 我们先来看看LDREX和STREX两条指令的语义。其实LDREX和STREX指令，是将单纯的更新内存的原子操作分成了两个独立的步骤。\n1)LDREX用来读取内存中的值，并标记对该段内存的独占访问：\nLDREX Rx, [Ry]  上面的指令意味着，读取寄存器Ry指向的4字节内存值，将其保存到Rx寄存器中，同时标记对Ry指向内存区域的独占访问。\n如果执行LDREX指令的时候发现已经被标记为独占访问了，并不会对指令的执行产生影响。\n2）而STREX在更新内存数值时，会检查该段内存是否已经被标记为独占访问，并以此来决定是否更新内存中的值：\nSTREX Rx, Ry, [Rz]  如果执行这条指令的时候发现已经被标记为独占访问了，则将寄存器Ry中的值更新到寄存器Rz指向的内存，并将寄存器Rx设置成0。指令执行成功后，会将独占访问标记位清除。\n而如果执行这条指令的时候发现没有设置独占标记，则不会更新内存，且将寄存器Rx的值设置成1。\n  一旦某条STREX指令执行成功后，以后再对同一段内存尝试使用STREX指令更新的时候，会发现独占标记已经被清空了，就不能再更新了，从而实现独占访问的机制。 2. 第7行：有一个共识是:程序访问的变量如果都能在系统内存cache中则能提升性能，prefetchw是内核中一个预热内存函数，这样下次遍历时就能高效命中内存cache，从而提升程序性能。 3. 第9行到第20行，见代码注释 4. 第6行和23行： _mb()是读写访问内存屏障，它保证在屏障（调用_mb()的位置处）之后的任何读操作在执行之前，屏障之前的所有读操作都已经完成。\n仔细一分析，该函数的功能就是：\n 只要v-\u0026gt;counter还不等于u,就以原子的方式将a加到v-\u0026gt;counter中，最终返回原始的v-\u0026gt;counter的值，即临时变量oldval的值。 由于过程中独占访问内存，所以如果写回内存时发现独占访问标记消失，则表明该进程被其他处理器中的进程抢占执行了，则会重头再来，总有一次能成功，这就保证了被抢占者不会影响原执行者的最终结果，甚是巧妙！  5. 原子变量内核操作函数汇总 其它的函数也大同小异，这里记录如下\n5.1. 设置原子变量的值 void atomic_set(atomic_t *v, int i); /设置原子变量的值为i,即v-\u0026gt;counter = i/\natomic_t v = ATOMIC_INIT(i); /定义原子变量v并初始化为 i/\n5.2. 操作原子变量    函数名 作用     atomic_read(atomic_t *v) 读出原子变量的值，即v-\u0026gt;counter   atomic_inc(atomic_t *v) v-\u0026gt;counter++   atomic_dec(atomic_t *v) v-\u0026gt;counter\u0026ndash;   atomic_add(int i,atomic_t *v) v-\u0026gt;counter += i   atomic_sub(int i,atomic_t *v) v-\u0026gt;counter -= i   atomic_inc_and_test(atomic_t *v) 先加1，再判断新值是否等于0；等于0的话，返回值为1   atomic_dec_and_test(atomic_t *v) 先减1，再判断新值是否等于0；等于0的话，返回值为1    5.3. 操作原子变量中的某一位    函数名 作用     set_bit(nr,p) 设置(*p)的bit nr为1   clear_bit(nr,p) 清除(*p)的bit nr为0   change_bit(nr,p) 改变(*p)的bit nr，从1变为0，或是从0变为1   test_and_set_bit(nr,p) 设置(*p)的bit nr为1，返回该位的老值   test_and_clear_bit(nr,p) 清除(*p)的bit nr为0，返回该位的老值   test_and_change_bit(nr,p) 改变(*p)的bit nr，从1变为0，或是从0变为1；返回该位的老值    使用实例：\nstatic atomic_t xxx_available = ATOMIC_INIT(1); static int XXX_open(struct inode* inode,struct file *flip) { ... if(!atomic_dec_and_test(\u0026amp;xxx_available)) { atomic_inc(\u0026amp;xxx_available); return - EBUSY; /* 已经打开 */ } ... return 0; /* 成功 */ } static int XXX_close(struct inode *inode, struct file *flip) { atomic_inc(\u0026amp;xxx_available); /* 释放设备 */ return 0; }  6. 参考来源   https://blog.csdn.net/Roland_Sun/article/details/47670099\n  本文是学习韦东山老师的Linux课程整理的笔记，特此感谢！！！\n  宋宝华. Linux设备驱动开发详解：基于最新的Linux4.0内核 (电子与嵌入式系统设计丛书) (Kindle 位置 3426-3427). 机械工业出版社. Kindle 版本.\n  ","date":1603974550,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1603974550,"objectID":"80687a9d311524ed3f00a8050dded0b2","permalink":"https://strivefar.github.io/project/post/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/","publishdate":"2020-10-29T20:29:10+08:00","relpermalink":"/project/post/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C/","section":"project","summary":"1. 什么是原子操作 2. 为什么要引入原子操作 2.1. 失败例子1 2.2. 失败例子2 2.3. 失败例子3 3. 原子操作实现——atomic.h解析 4. 内联汇编实现原子操作 5. 原子","tags":["linux"],"title":"原子操作 atomic.h 详解","type":"project"},{"authors":[],"categories":[],"content":" 1. 内联汇编做了什么  1.1. 优化对比测试  1.1.1. 非内联汇编 1.1.2. 内联汇编   1.2. 结论   2. 语法规则  2.1. 内联汇编规则 2.2. 示例 2.3. imx6ull测试结果   3. 参考来源  1. 内联汇编做了什么 在Linux内核中，我们时常见到内嵌汇编语言的函数，向这种在C语言函数内部嵌入汇编代码的做法我们称之为内联汇编。尽管现在的编译器对程序的优化都很优秀了，但在某些对效率要求较高的场合仍需要手动优化，我们暂时先不关心具体的内联汇编的规则，先来看看内联汇编是如何提高效率的。\n1.1. 优化对比测试 测试环境：imx6ull\n编译器：arm-linux-gnueabihf-gcc\n反汇编：arm-linux-gnueabihf-objdump\nMakefile:\ntest: main.c arm-linux-gnueabihf-gcc -o $@ $^ arm-linux-gnueabihf-objdump -D test \u0026gt; test.dis clean: rm test *.dis  1.1.1. 非内联汇编 写测试函数如下： main.c:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int add(int a, int b) { return a + b; } int main(int argc, char **argv) { int a; int b; char *endptr; if (argc != 3) { printf(\u0026quot;Usage: %s \u0026lt;val1\u0026gt; \u0026lt;val2\u0026gt;\\n\u0026quot;, argv[0]); return -1; } a = (int)strtol(argv[1], NULL, 0); b = (int)strtol(argv[2], NULL, 0); printf(\u0026quot;%d + %d = %d\\n\u0026quot;, a, b, add(a, b));\t}  查看反汇编：\n这是我们写的add函数：\n00010404 \u0026lt;add\u0026gt;: 10404: b480 push {r7} 10406: b083 sub sp, #12 10408: af00 add r7, sp, #0 1040a: 6078 str r0, [r7, #4] 1040c: 6039 str r1, [r7, #0] 1040e: 687a ldr r2, [r7, #4] 10410: 683b ldr r3, [r7, #0] 10412: 4413 add r3, r2 10414: 4618 mov r0, r3 10416: 370c adds r7, #12 10418: 46bd mov sp, r7 1041a: f85d 7b04 ldr.w r7, [sp], #4 1041e: 4770 bx lr  然后在main函数中被调用：\n00010420 \u0026lt;main\u0026gt;: #...省略 10470: f7ff ffc8 bl 10404 \u0026lt;add\u0026gt; #...省略  1.1.2. 内联汇编 写测试函数如下： main.c:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int add(int a, int b) { int sum; __asm__ volatile ( \u0026quot;add %0, %1, %2\u0026quot; :\u0026quot;=r\u0026quot;(sum) :\u0026quot;r\u0026quot;(a), \u0026quot;r\u0026quot;(b) :\u0026quot;cc\u0026quot; ); return sum; } int main(int argc, char **argv) { int a; int b; if (argc != 3) { printf(\u0026quot;Usage: %s \u0026lt;val1\u0026gt; \u0026lt;val2\u0026gt;\\n\u0026quot;, argv[0]); return -1; } a = (int)strtol(argv[1], NULL, 0);\tb = (int)strtol(argv[2], NULL, 0);\tprintf(\u0026quot;%d + %d = %d\\n\u0026quot;, a, b, add(a, b)); return 0; }  00010474 \u0026lt;add\u0026gt;: 10474: 1840 adds r0, r0, r1 10476: 4770 bx lr  然后在main函数中被调用：\n00010404 \u0026lt;main\u0026gt;: #...省略 10454: f000 f80e bl 10474 \u0026lt;add\u0026gt; #...省略  1.2. 结论 可见，实现相同的功能，内联汇编add函数的指令相比纯C语言写的add函数大大简化，效率自然大大提高。\n2. 语法规则 2.1. 内联汇编规则 asm [Qualifiers] ( ``AssemblerTemplate`` : ``OutputOperands`` : ``InputOperands`` : ``Clobbers`` ) asm [Qualifiers] goto ( ``AssemblerTemplate`` : /* No outputs. */ : ``InputOperands`` : ``Clobbers`` : ``GotoLabels`` )    asm\n也可以写作 __asm__ ，如果关键词 asm 和我们程序的一些标识符冲突了，我们可以使用 __asm__ ,表示这是一段内联汇编。\n  Qualifiers： 包含 volatile 和 inline 这两个限定符\n  volatile\nvolatile这一可选的限定符号无效，所有基本的asm块都是隐式的volatile\n  inline 1\n如果使用inline限定符，那么出于内联的目的，asm语句的大小要尽可能的小。\n    AssemblerTemplate\n汇编模板，用双引号包含起来，每条指令都需要使用系统汇编代码中的分隔符进行分隔，如分号\u0026rdquo; ; \u0026ldquo;或\u0026rdquo; \\n\\t \u0026ldquo;等, 在大多数地方都可以使用的组合是换行符和制表符(写为\u0026rdquo; \\n\\t \u0026ldquo;)。 有些汇编程序允许分号(;)作为行分隔符。但是，请注意，一些汇编语言使用分号来表示注释的开始。\n示例：\n\u0026quot;add %0, %1, %2\u0026quot; :\u0026quot;=r\u0026quot;(sum) :\u0026quot;r\u0026quot;(a), \u0026quot;r\u0026quot;(b)  %n代表输出操作数和输入操作数中按顺序出现第n个的变量 本示例中：\n%0 代表 sum\n%1 代表 a\n%0 代表 b\n  OutputOperands\n输出操作数，内联汇编执行时，输出的结果保存在哪里。 格式如下，当有多个变量时，用逗号隔开：\n  [ [asmSymbolicName] ] constraint (cvariablename)\n  asmSymbolicName 符号名，随便取，也可以不写。 constraint表示约束，有如下常用取值：\n   约束 constraint 描述     m memory operand，表示要传入有效的地址，只要CPU能支持该地址，就可以传入   r register operand，寄存器操作数，使用寄存器来保存这些操作数   i immediate integer operand，表示可以传入一个立即数    constraint前还可以加上一些修饰字符，比如“=r”、“+r”、“=\u0026amp;r”，含义如下：\n   constraint Modifier Characters 描述     = 表示内联汇编会修改这个操作数，即：写   + 这个操作数既被读，也被写   \u0026amp; 它是一个earlyclobber操作数      cvariablename C语言的变量名。\n有了以上规则，请回看之前的示例代码，就会豁然开朗了:D。\n      goto\n  允许汇编指令跳转到C语言定义的GotoLabels任一个，多个GotoLabels用逗号分割。\n  goto跳转的汇编块不允许包含输出。这是由于编译器的内部限制：控制传递指令不能具有输出。\n  asm goto语句是隐式volatile的。\n  goto语句引用标签：\n 在汇编模板中引用标签，格式为 %l(n+i) (l是小写的L), n为输入操作数的个数(下标从0开始)，i为第几个GotoLabels(下标从1开始)。\n 比如，asm块具有三个输入操作数并引用了两个Goto标签，则n=2(下标从0开始),因此将第一个Goto标签（下标从1开始，所以i = 1）在汇编模板中写为％l3，将第二个Goto标签（下标从1开始，所以i = 2）在汇编模板中写为％l4）。\n  如下代码示例显示了内联跳转。\n  2.2. 示例 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int test(int a, int b) { __asm__ goto ( \u0026quot;cmp %1, %0\\n\\t\u0026quot; /* BLE指令：b比a小则跳转 */ \u0026quot;blt %l2\u0026quot; : /* No outputs. */ : \u0026quot;r\u0026quot;(a), \u0026quot;r\u0026quot;(b) : \u0026quot;cc\u0026quot; : carry); return 0; carry: return 1; } int main(int argc, char **argv) { int a; int b; if (argc != 3) { printf(\u0026quot;Usage: %s \u0026lt;val1\u0026gt; \u0026lt;val2\u0026gt;\\n\u0026quot;, argv[0]); return -1; } a = (int)strtol(argv[1], NULL, 0); b = (int)strtol(argv[2], NULL, 0); printf(\u0026quot;test return is %d\\n\u0026quot;,test(a, b)); return 0; }  2.3. imx6ull测试结果 BLE指令实现功能：b比a小则跳转\n./test 1 2 test return is 0 ./test 3 2 test return is 1 ./test 2 2 test return is 0  3. 参考来源 本文是学习韦东山老师的Linux课程整理的笔记，特此感谢！！！\n本文还参考了以下几篇博客，特此感谢！！！\nHow to Use Inline Assembly Language in C Code\n如何在C代码中使用内联汇编之基本的asm\n  并没有在内核源码中找到inline限定符使用实例 \u0026#x21a9;\u0026#xfe0e;\n   ","date":1603549081,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1603549081,"objectID":"5c5c09c2a5a5c05aa838467685321374","permalink":"https://strivefar.github.io/project/post/inline/","publishdate":"2020-10-24T22:18:01+08:00","relpermalink":"/project/post/inline/","section":"project","summary":"1. 内联汇编做了什么 1.1. 优化对比测试 1.1.1. 非内联汇编 1.1.2. 内联汇编 1.2. 结论 2. 语法规则 2.1. 内联汇编规则 2.2. 示例 2.3. imx6ull测试结果 3. 参考来源 1. 内联汇编做了什","tags":["linux"],"title":"内联汇编","type":"project"},{"authors":["youngfar"],"categories":[],"content":"auto 关键字  auto即C语言中局部变量的默认属性 auto表明将被修饰的变量存储于栈上 编译器默认所有的局部变量都是auto的 示例：  void f() { int i; //局部变量默认属性为 auto auto int j; //显示声明 auto 属性 }  register 关键字 用于向编译器申请在CPU寄存器上分配空间，以实现高速访问，但是要注意，申请不一定能成功，因为占用CPU寄存器是一件花销很大的事情，ARM算上影子寄存器加起来总共37个，下面我们看一下什么情况下编译器会拒绝该申请。\n#include \u0026lt;stdio.h\u0026gt; register unsigned int a; int main() { register unsigned int i; printf(\u0026quot;\u0026amp;i = %p\\n\u0026quot;, \u0026amp;i);] return 0; }  对于全局变量，在程序的整个运行期间内始终存活，编译器一旦允许，则会长时间的占用CPU寄存器，所以这种情况编译器直接拒绝了\n不能用 \u0026amp; 符获取register变量地址，地址是相对内存而言的，CPU寄存器尽管可以记录内存地址信息，但CPU寄存器本身没有地址的概念。\n上述两处错误给出提示如下：\n4-1.c: In function ‘main’: 4-1.c:9:5: error: address of register variable ‘i’ requested printf(\u0026quot;\u0026amp;i = %p\\n\u0026quot;, \u0026amp;i);] ^~~~~~ 4-1.c:9:29: error: expected statement before ‘]’ token printf(\u0026quot;\u0026amp;i = %p\\n\u0026quot;, \u0026amp;i);] ^ 4-1.c: At top level: 4-1.c:3:23: error: register name not specified for ‘a’ register unsigned int a; ^  所以对于register关键字，现总结如下：\n register关键字指明将局部变量存储于寄存器中 register只是请求寄存器变量，但不一定请求成功 register变量的必须是CPU寄存器可以接受的值 不能用\u0026amp;运算符获取register变量的地址  static关键字 这个在以前的博客中做过详细讨论，\n这里仅给出以下特性：\n static关键字指明变量的“静态”属性 static修饰的局部变量存储在程序静态区 static关键字同时具有“作用域限定符”的意义   static修饰的全局变量作用域只是声明的文件中     static修饰的函数作用域只是声明的文件中    ","date":1599639971,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1599639971,"objectID":"3d2222f646ae58b3d16c75742e3f2524","permalink":"https://strivefar.github.io/project/post/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","publishdate":"2020-09-09T16:26:11+08:00","relpermalink":"/project/post/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","section":"project","summary":"auto 关键字 auto即C语言中局部变量的默认属性 auto表明将被修饰的变量存储于栈上 编译器默认所有的局部变量都是auto的 示例： void f() { int i; //局","tags":["C"],"title":"类型转换","type":"project"},{"authors":["youngfar"],"categories":[],"content":" 1. C++中的 bool 类型  1.1. bool 类型参与数学运算（不建议但允许）   2. C++中的引用  2.1. C++对三目运算符的升级    1. C++中的 bool 类型 特点：\n bool 可取的值只有true 和 false 理论上bool只占用一个字节  注意：\ntrue 代表真值，编译器内部用 1 来表示 false 代表非真值，编译器内部用 0 来表示  1.1. bool 类型参与数学运算（不建议但允许） 为了兼容C语言，c++中的bool类型可以进行数学运算，g++编译器当遇到bool类型参与数学运算时，直接将其当做一个只占用一个字节的整型数来处理，但是会将最终的结果按照以下规则进行转换：\n 将非零值用true（1）来代替 将零值用 false（0）来代替  示例1：\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { bool b = false; printf(\u0026quot;sizeof(b) = %d\\n\u0026quot;, sizeof(b)); printf(\u0026quot;b = %d\\n\u0026quot;, b); b++; // b = 1; =\u0026gt; 非零值; printf(\u0026quot;b = %d\\n\u0026quot;, b); b = b - 3;// b = 1 - 3 = -2 =\u0026gt; 非零值; printf(\u0026quot;b = %d\\n\u0026quot;, b); return 0; }  编译：\ng++ -o test 4-1.cpp -m32 4-1.cpp: In function ‘int main(int, char**)’: 4-1.cpp:8:6: warning: use of an operand of type ‘bool’ in ‘operator++’ is deprecated [-Wdeprecated] b++; ^~  可见：编译器给出了警告，bool 类型参与数学运算，编译器的态度是不建议但允许\n运行:\n./test  输出结果如下：\nsizeof(b) = 1 b = 0 b = 1 b = 1  示例2：\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { bool b = false; int a = b; printf(\u0026quot;sizeof(b) = %d\\n\u0026quot;, sizeof(b)); printf(\u0026quot;b = %d, a = %d\\n\u0026quot;, b, a); b = 3; a = b; printf(\u0026quot;b = %d, a = %d\\n\u0026quot;, b, a); b = -5; a = b; printf(\u0026quot;b = %d, a = %d\\n\u0026quot;, b, a); a = 10; b = a; printf(\u0026quot;b = %d, a = %d\\n\u0026quot;, b, a); a = 0; b = a; printf(\u0026quot;b = %d, a = %d\\n\u0026quot;, b, a); return 0; }  编译：\ng++ -o test 4-2.cpp -m32  运行：\n./test  输出结果如下：\nsizeof(b) = 1 b = 0, a = 0 b = 1, a = 1 b = 1, a = 1 b = 1, a = 10 b = 0, a = 0  2. C++中的引用 在讨论引用之前，我们先来明确几个概念：\n 变量是一段实际连续存储空间的别名 程序中通过变量来申请并命名存储空间 通过变量的名字可以使用存储空间  但一段连续的存储空间不止可以有一个别名\n于是在C++中新增加了引用的概念\n  引用可以看作一个已定义变量的别名\n  引用的语法:\nType \u0026amp; name = var;    注意： C++是强类型的，普通引用在定义时必须用同类型的变量进行初始化。\n  2.1. C++对三目运算符的升级  当三目运算符的可能返回都是变量时，返回的是变量的引用 当三目运算符的可能返回中有常量时，返回的是值  示例3： 4-3.cpp\n#include \u0026lt;stdio.h\u0026gt; int main(int argc, char *argv[]) { int a = 1; int b = 2; float f = 0.123f; float \u0026amp;f_quote = f; printf(\u0026quot;f = %f, f_quote= %f\\n\u0026quot;, f, f_quote); printf(\u0026quot;\u0026amp;f = %p, \u0026amp;f_quote = %p\\n\u0026quot;, \u0026amp;f, \u0026amp;f_quote); (a \u0026lt; b ? a : b) = 3; //正确，返回a或b的引用，可作为左值 printf(\u0026quot;a = %d, b = %d\\n\u0026quot;, a, b); //printf(a \u0026lt; b ? 1 : b); //错误，返回1或b的值，不能作为左值 return 0; }  编译运行：\ngcc -o test 4-3.cpp -m32 ./test f = 0.123000, f_quote= 0.123000 \u0026amp;f = 0xfff78cec, \u0026amp;f_quote = 0xfff78cec a = 3, b = 2  注意：这里三目运算符的可能返回都是变量，返回的是变量的引用，也就是a的引用，也就是a的另外一个名字，我们先不管a变量空间的另外一个名字是啥，从概念上我们很容易知道，a的引用就是a变量本身\n仅保留三目运算符相关代码，将文件后缀改为.c 编译报错如下：\ngcc -o test 4-3.c -m32 4-3.c: In function ‘main’: 4-3.c:8:21: error: lvalue required as left operand of assignment (a \u0026lt; b ? a : b) = 3; //正确，返回a或b的引用，可作为左值 ^  由此可见： C语言不允许三目运算符做左值\n","date":1599440346,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1599440346,"objectID":"fb5547ed05f37a3f98a12d16b7faab57","permalink":"https://strivefar.github.io/project/post/%E7%AC%AC%E5%9B%9B%E8%AF%BE%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8/","publishdate":"2020-09-07T08:59:06+08:00","relpermalink":"/project/post/%E7%AC%AC%E5%9B%9B%E8%AF%BE%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8/","section":"project","summary":"1. C++中的 bool 类型 1.1. bool 类型参与数学运算（不建议但允许） 2. C++中的引用 2.1. C++对三目运算符的升级 1. C++中的 bool 类型 特点： bool 可取的值只有tru","tags":["plus_C"],"title":"布尔类型和引用","type":"project"},{"authors":["youngfar"],"categories":[],"content":" 1. 浮点数在内存中的存储方式 2. 浮点数存储示例  2.1. 实数8.25在内存中的float表示 2.2. 编程验证   3. 精度问题  3.1. 编程验证    1. 浮点数在内存中的存储方式 浮点数在内存中由以下三部分组成：\n 符号位 指数 尾数  无论是float类型还是double类型的数据，在计算机内部的表示方法是相同的，但由于所占的存储空间不同，其分别能够表示的数值范围和精度不同。\n   类型 符号位 指数 尾数     float 1位（第31位） 8位（第23~30位） 23位（第0~22位）   double 1位（第63位） 11位（第52~62位） 52位（第0~51位）    2. 浮点数存储示例 浮点数的转换\n   将浮点数转换成二进制    用科学计数法表示二进制浮点数    计算指数偏移后的值    注意∶\n   计算指数时需要加上偏移量，而偏移量的值与类型有关。    对于指数6，偏移后的值如下：\nfloat : 127 + 6 = 123 double: 1023 + 6 = 1030    小数用二进制如何表示    首先，给出一个任意实数，整数部分用普通的二进制便可以表示，这里只说小数部分如何表示\n例如0.6\n文字描述该过程如下：将该数字乘以2，取出整数部分作为二进制表示的第1位；然后再将小数部分乘以2，将得到的整数部分作为二进制表示的第2位；以此类推，知道小数部分为0。\n特殊情况： 小数部分出现循环，无法停止，则用有限的二进制位无法准确表示一个小数，这也是在编程语言中表示小数会出现误差的原因\n下面我们具体计算一下0.6的小数表示过程\n0.6 * 2 = 1.2 ——————- 1 0.2 * 2 = 0.4 ——————- 0 0.4 * 2 = 0.8 ——————- 0 0.8 * 2 = 1.6 ——————- 1 0.6 * 2 = 1.2 ——————- 1 …………  我们可以发现在该计算中已经出现了循环，0.6用二进制表示为 1001 1001 1001 1001 …… 如果是10.6，那个10.6的完整二进制表示为 1010.100110011001……\n参考：https://blog.csdn.net/xingtanzjr/article/details/50803832\n2.1. 实数8.25在内存中的float表示 2.2. 编程验证 #include \u0026lt;stdio.h\u0026gt; /**功能：输出内存片段中的每一位的值 * 参数： * p :指向占1、2、4、8字节内存的变量的指针 * size ：变量在内存中所占的字节数 */ void put_bin(void *p, char size) { char i; switch (size) { case 1: for (i = sizeof(unsigned char) * 8; i \u0026gt; 0; i--) { printf(\u0026quot;%d\u0026quot;, !!(*((unsigned char *)p) \u0026amp; (1 \u0026lt;\u0026lt; (i - 1)))); if (0 == (i - 1) % 4) printf(\u0026quot; \u0026quot;); } printf(\u0026quot;\\n\u0026quot;); break; case 2: for (i = sizeof(unsigned short) * 8; i \u0026gt; 0; i--) { printf(\u0026quot;%d\u0026quot;, !!(*((unsigned short *)p) \u0026amp; (1 \u0026lt;\u0026lt; (i - 1)))); if (0 == (i - 1) % 4) printf(\u0026quot; \u0026quot;); } printf(\u0026quot;\\n\u0026quot;); break; case 4: for (i = sizeof(unsigned int) * 8; i \u0026gt; 0; i--) { printf(\u0026quot;%d\u0026quot;, !!(*((unsigned int *)p) \u0026amp; (1 \u0026lt;\u0026lt; (i - 1)))); if (0 == (i - 1) % 4) printf(\u0026quot; \u0026quot;); } printf(\u0026quot;\\n\u0026quot;); break; case 8: for (i = sizeof(long long) * 8; i \u0026gt; 0; i--) { printf(\u0026quot;%d\u0026quot;, !!(*((unsigned long long int *)p) \u0026amp; (1 \u0026lt;\u0026lt; (i - 1)))); if (0 == (i - 1) % 4) printf(\u0026quot; \u0026quot;); } printf(\u0026quot;\\n\u0026quot;); break; default: break; } } int main() { float f = 8.25; unsigned int *p = (unsigned int *)\u0026amp;f; //占用内存大小相同 put_bin(p, sizeof(unsigned int)); //输出unsigned int内存片段中的每一位的值 printf(\u0026quot;0x%08x\\n\u0026quot;, *p); //16进制打印 return 0; }  输出结果：\ngcc -o test 3-1.c -m32 ./test 0100 0001 0000 0100 0000 0000 0000 0000 0x41040000  3. 精度问题 为了引出对这一问题的思考，我们先看一下int与float类型的范围 那么问题来了：\nint 和 float 都占4字节的内存，为什么float却比int的范围大呢？\n目前我们知道\n int和float都占4个字节的内存，因此float能表示的具体数字的个数与int相同 float类型所能表示的数字的范围却比int的范围大  因此：\n float可表示的数字之间不是连续的，存在间隙 float只是一种近似的表示法，不能作为精确数使用 由于内存表示法相对复杂，float的运算速度比int慢得多  3.1. 编程验证 #include \u0026lt;stdio.h\u0026gt; int main() { float f = 3.14159f; float fa = 123456789; printf(\u0026quot;%0.10f\\n\u0026quot;, f); printf(\u0026quot;%0.10f\\n\u0026quot;, fa); return 0; }  输出结果：\n3.1415901184 123456792.0000000000  注：本文为学习唐老师C进阶课程的笔记，如有问题，欢迎各位批评指正。\n","date":1599380611,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1599380611,"objectID":"f7a91717de807dbcd5e8bb342e3d324c","permalink":"https://strivefar.github.io/project/post/c_advanced/","publishdate":"2020-09-06T16:23:31+08:00","relpermalink":"/project/post/c_advanced/","section":"project","summary":"1. 浮点数在内存中的存储方式 2. 浮点数存储示例 2.1. 实数8.25在内存中的float表示 2.2. 编程验证 3. 精度问题 3.1. 编程验证 1. 浮点数在内存中的存储方式 浮点","tags":["C"],"title":"浮点数的秘密","type":"project"},{"authors":["youngfar"],"categories":[],"content":"在计算机中，数值类型分为整数型或实数型，其中整型又分为无符类型或有符类型，而实型则只有符类型。 字符类型也分为有符和无符类型。在程序中，用户可以自己定义是否需要一个非负整数；\n一、无符号数和有符号数的表示方式 以一个字节(char类型)为例：若想要表示正负号，一般需要一个位来标记，如取最高代表正负号，则有符号和无符号的数值最大值对比如下：\n 有符号：0111 1111 = 2^6+2^5+2^4+2^3+2^2+2^1+2^0 = 127; ==\u0026gt; 范围是 -128 ~ 127 无符号：1111 1111 = 2^7+2^6+2^5+2^4+2^3+2^2+2^1+2^0 = 255；==\u0026gt; 范围是 0 ~ 255  由上可看出：\n 同样一个字节大小，有符号和无符号表示的范围不同，但个数相同均为256个； 单纯这样存储是存在问题:   针对有符号数，0在内存中存在两种方式即＋0和－0；     针对负数的大小，-1(1000 0001)和-2(1000 0010)单纯的从二进制存储来比较，应该是-2(1000 0010)\u0026gt; -1(1000 0001)这与实际逻辑不吻合；   二进制补码避免了这个问题，这也是当今最常用的系统存储方式：即高位段0代表正数，1代表负数，表示正数为原码，而表示负数的方式采用：补码 = 反码+1  参考： 有符号数和无符号数\n以下为OneNote笔记截图，由于时间原因，以后再做整理 ","date":1598930331,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1598930331,"objectID":"5760538402619dcace07b32617bd6e55","permalink":"https://strivefar.github.io/project/post/unsigned%E4%B8%8Esigned/","publishdate":"2020-09-01T11:18:51+08:00","relpermalink":"/project/post/unsigned%E4%B8%8Esigned/","section":"project","summary":"在计算机中，数值类型分为整数型或实数型，其中整型又分为无符类型或有符类型，而实型则只有符类型。 字符类型也分为有符和无符类型。在程序中，用户可","tags":["C"],"title":"细究 unsigned 与 signed","type":"project"},{"authors":["youngfar"],"categories":null,"content":"\u0026amp; 在数组中的应用 以下面这个数组为例，我们先来明确一些概念\nint a[10];  a与\u0026amp;a[0]的关系   数组名a是数组0号元素的地址,也就是存在以下等价关系\na 等价于 \u0026amp;a[0]    \u0026amp;a[0] 表示对一个int型变量取地址，a[0]是一个int变量， 一个int变量的地址类型是 int* ,所以 \u0026amp;a[0] 为 int* 类型\n  于是有 a 等价于 \u0026amp;a[0]，且二者均为 int* 类型\n  a与\u0026amp;a的关系   \u0026amp;a 和 a 在数值上相同，但意义不同！\n  \u0026amp;a 代表数组地址，类型为 int(*)[10]\n  a 代表 数组0号元素的地址，类型为 int*   于是指向数组的指针可以定义为：\nint(*p_arr)[10] = \u0026amp;a;    指向数组成员的指针可以定义为：\nint *p = a; 或 int *p = \u0026amp;a[0];    a+i 中的隐式转换 我们经常在程序中看到类似这样的用法\nprintf(\u0026quot;%d\\n\u0026quot;, *(a+i));  a 为int类型，i为 int类型，a+i的结果是int类型，加几就越过几个sizeof(int)，所以\na+i 或 \u0026amp;a[0]+i = 被取址变量本身的地址 + i * sizeof(被取址的变量的类型)\n这个关系很重要，有的时候我们为使代码简洁，会直接对变量取址，进行上述操作后再解引用，而不是定义一个指针指来指去，下边的代码综合和柔性数组会遇到这种情况。\n示例代码1 以下示例代码包含了上边讨论的诸多情况，有助于对上述讨论内容的理解\n#include \u0026lt;stdio.h\u0026gt; int a[10] = {0}; int main() { int i; for (i = 0; i \u0026lt; 10; i++) { a[i] = i + 1; } int *p = a; int *p1 = \u0026amp;a[0]; int *p2 = \u0026amp;a[1]; int(*p_half)[5] = (int(*)[5]) \u0026amp; a; int(*p_2)[2] = (int(*)[2]) \u0026amp; a[1]; printf(\u0026quot; p = %p\\n\u0026quot;, a); printf(\u0026quot; p1 = %p\\n\u0026quot;, p1); printf(\u0026quot; p_half = %p\\n\u0026quot;, p_half); printf(\u0026quot; p2 = %p\\n\u0026quot;, p2); printf(\u0026quot; p_2 = %p\\n\u0026quot;, p_2); printf(\u0026quot;%d, %d, %d\\n\u0026quot;, p[0], p1[0], *((int *)p_half)); printf(\u0026quot;%d , %d\\n\u0026quot;, a[5], *((int *)(p_half + 1))); printf(\u0026quot;%d , %d\\n\u0026quot;, a[3], *((int *)(p_2 + 1))); }  在Linux执行\ngcc - o test test.c ./test  输出结果如下： 注意：\n  代码中的p_2 的类型为 int(*)[2]\n  \u0026amp;a[1]为int*类型，此处需要强制类型转换   \u0026amp;在结构体中的应用 结构和数组的联系与区别 数组和结构相似的地方是都不再是单一的原子类型，而是一个集合。区别在于数组是相同类型元素（元素可以是原子类型的整型、浮点型、字符型或者结构体、数组等）的集合，而结构是不同类型元素（元素可以是原子类型的整型、浮点型、字符型或者结构体、数组等）的集合。所以结构无所不包，当然结构中也可以定义相同类型的元素，而数组则不然，从这个角度，结构体的普世意义更为广泛，但是毫无疑问，如果结构定义为成员类型是相同的，那么相比定义数组要麻烦的多。\n(来自 https://blog.csdn.net/zhanshen112/article/details/80429861 )\n为更为彻底的体会\u0026amp;的妙用，我们的示例代码将涉及柔性数组(也叫零长度数组)\n示例代码2 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; struct test { int count; //reverse is array name;the array is no item; //the array address follow test struct int reverse[0]; }; int main() { int i; struct test *ptest = (struct test *)malloc(sizeof(struct test) + sizeof(int) * 10); for (i = 0; i \u0026lt; 10; i++) { ptest-\u0026gt;reverse[i] = i + 1; } for (i = 0; i \u0026lt; 10; i++) { printf(\u0026quot;reverse[%d]=%d \\n\u0026quot;, i, ptest-\u0026gt;reverse[i]); } printf(\u0026quot;\\n\\n\u0026quot;); printf(\u0026quot;sizeof(struct test) =%ld\\n\u0026quot;, sizeof(struct test)); /* a+i 或 \u0026amp;a[0]+i = 被取址变量本身的地址 + i * sizeof(被取址的变量的类型)*/ int a = *(\u0026amp;ptest-\u0026gt;count + 1); printf(\u0026quot;\u0026amp;ptest-\u0026gt;count = %p\\n\u0026quot;, \u0026amp;ptest-\u0026gt;count); printf(\u0026quot;\u0026amp;ptest-\u0026gt;count +1 = %p\\n\u0026quot;, (\u0026amp;ptest-\u0026gt;count + 1)); printf(\u0026quot;a=%d\\n\\n\\n\u0026quot;, a); int(*p)[5] = (int(*)[5])(\u0026amp;ptest-\u0026gt;reverse[0]); // int(*p)[5] = (\u0026amp;ptest-\u0026gt;reverse[0]); /* \u0026amp;ptest-\u0026gt;reverse[0]\u0026lt;=\u0026gt;数组0号元素的地址，类型为int* ，所以此处编译器会给出警告 */ /* 无论\u0026amp;取哪个成员的地址，只要加上正确的偏移，总能正确访问到目标 */ printf(\u0026quot;%d ,%d\\n\u0026quot;, *(\u0026amp;ptest-\u0026gt;count + 1), *((int *)p)); printf(\u0026quot;%d ,%d\\n\u0026quot;, *(\u0026amp;ptest-\u0026gt;count + 1 + 5), *((int *)(p + 1))); printf(\u0026quot;%d ,%d\\n\u0026quot;, *(\u0026amp;ptest-\u0026gt;reverse[0] + 5), *((int *)(p + 1))); printf(\u0026quot;%d ,%d\\n\u0026quot;, *(\u0026amp;ptest-\u0026gt;reverse[1] + 4), *((int *)(p + 1))); free(ptest); return 0; }  gcc - o test_1 test1.c ./test_1  ","date":1597910549,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1597910549,"objectID":"5f95e02ccd2ca835feef7be260f8a5b6","permalink":"https://strivefar.github.io/project/post/%E5%85%B3%E4%BA%8E%E5%8F%96%E5%9D%80%E7%AC%A6%E7%9A%84%E8%AE%A8%E8%AE%BA/","publishdate":"2020-08-20T16:02:29+08:00","relpermalink":"/project/post/%E5%85%B3%E4%BA%8E%E5%8F%96%E5%9D%80%E7%AC%A6%E7%9A%84%E8%AE%A8%E8%AE%BA/","section":"project","summary":"\u0026amp; 在数组中的应用 以下面这个数组为例，我们先来明确一些概念 int a[10]; a与\u0026amp;a[0]的关系 数组名a是数组0号元素的地址,也就是存在以下等价关系","tags":["C"],"title":"关于取址符'\u0026'的讨论","type":"project"},{"authors":["youngfar"],"categories":null,"content":" 1. 程序清单2.6  1.1. 2.6说明：    1. 程序清单2.6 // convert.cpp -- converts stone to pounds #include \u0026lt;iostream\u0026gt; int stonetolb(int); // function prototype int main() { using namespace std; int stone; cout \u0026lt;\u0026lt; \u0026quot;Enter the weight in stone: \u0026quot;; cin \u0026gt;\u0026gt; stone; int pounds = stonetolb(stone); cout \u0026lt;\u0026lt; stone \u0026lt;\u0026lt; \u0026quot; stone = \u0026quot;; cout \u0026lt;\u0026lt; pounds \u0026lt;\u0026lt; \u0026quot; pounds.\u0026quot; \u0026lt;\u0026lt; endl; return 0; } int stonetolb(int sts) { return 14 * sts; }  1.1. 2.6说明：  cout \u0026lt;\u0026lt; stone \u0026lt;\u0026lt; \u0026quot; stone = \u0026quot;;   输出到屏幕上的只能是字符串形式，所以在打印之前，cout必须将整数形式的数字转换为字符串形式。 cout 相比 printf 更“聪明”,知道stone是一个需要转换的整数，而printf则需要使用特殊代码进行指定要打印的是字符串还是整数 cout 的智能行为源自C++的面向对象的特性  printf(\u0026quot;Printing a string : %s\\n\u0026quot;,\u0026quot;25\u0026quot;); printf(\u0026quot;Printing an integer: %d\\n\u0026quot;, 25);  #define min(x,y) ({ \\ typeof(x) __min1 = (x); \\ typeof(y) __min2 = (y); \\ (void) (\u0026amp; __min1 == \u0026amp; __min2); \\ __min1 \u0026lt; __min2 ? __min1 :__min2})  ","date":1597109813,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1597109813,"objectID":"84bd799c37662bbb2f74238e6327644a","permalink":"https://strivefar.github.io/project/post/c++_primer_plus_chapter2/","publishdate":"2020-08-11T09:36:53+08:00","relpermalink":"/project/post/c++_primer_plus_chapter2/","section":"project","summary":"1. 程序清单2.6 1.1. 2.6说明： 1. 程序清单2.6 // convert.cpp -- converts stone to pounds #include \u0026lt;iostream\u0026gt; int stonetolb(int); // function prototype int main() { using namespace std; int stone; cout \u0026lt;\u0026lt; \u0026quot;Enter the weight in stone: \u0026quot;; cin \u0026gt;\u0026gt; stone; int pounds = stonetolb(stone); cout \u0026lt;\u0026lt; stone \u0026lt;\u0026lt; \u0026quot; stone = \u0026quot;; cout \u0026lt;\u0026lt;","tags":["plus_C"],"title":"C++_Primer_Plus_chapter2","type":"project"},{"authors":["youngfar"],"categories":null,"content":" 1. Device Tree简介 2. Device Tree编译 3. Device Tree头信息 4. DTB文件结构 5. kernel解析Device Tree 6. platform_device和device_node绑定 7. i2c_client和device_node绑定 8. Device_Tree与sysfs 9. 特此感谢  #内核对设备树的处理 dts在PC 上被编译为.dtb文件； uboot把dtb文件传给内核； 内核解析dtb 文件，把每一个节点都转换为 device_node 结构体； 对于某些device_node结构体，会被转换为platform_device结构体。\n1. Device Tree简介 Linus Torvalds在2011年3月17日的ARM Linux邮件列表宣称“this whole ARM thing is a fucking pain in the ass”，引发ARM Linux社区的地震，随后ARM社区进行了一系列的重大修正。在过去的ARM Linux中，arch/arm/plat-xxx和arch/arm/mach-xxx中充斥着大量的垃圾代码，相当多数的代码只是在描述板级细节，而这些板级细节对于内核来讲，不过是垃圾，如板上的platform设备、resource、i2c_board_info、spi_board_info以及各种硬件的platform_data。 社区必须改变这种局面，于是PowerPC等其他体系架构下已经使用的Flattened Device Tree（FDT）进入ARM社区的视野。Device Tree是一种描述硬件的数据结构，它起源于OpenFirmware(OF)。在Linux2.6中，ARM架构的板极硬件细节过多地被硬编码在arch/arm/plat-xxx和arch/arm/mach-xxx，采用Device Tree后，许多硬件的细节可以直接透过它传递给Linux，而不再需要在kernel中进行大量的冗余编码。\nDevice Tree由一系列被命名的结点（node）和属性（property）组成，而结点本身可包含子结点。所谓属性，其实就是成对出现的name和value。在Device Tree中，可描述的信息包括（原先这些信息大多被hard code到kernel中）:\n CPU的数量和类别 内存基地址和大小 总线和桥 外设连接 中断控制器和中断使用情况 GPIO控制器和GPIO使用情况  它基本上就是画一棵电路板上CPU、总线、设备组成的树，Bootloader会将这棵树传递给内核，然后内核可以识别这棵树，并根据它展开出Linux内核中的platform_device、i2c_client、spi_device等设备。这些设备用到的内存、IRQ等资源，也被传递给了kernel，kernel会将这些资源绑定给展开的相应的设备。\n2. Device Tree编译 Device Tree文件的格式为dts，包含的头文件格式为dtsi，dts文件是一种人可以看懂的编码格式。但是uboot和linux不能直接识别，他们只能识别二进制文件，所以需要把dts文件编译成dtb文件。dtb文件是一种可以被kernel和uboot识别的二进制文件。把dts编译成dtb文件的工具是dtc。Linux源码目录下scripts/dtc目录包含dtc工具的源码。在Linux的scripts/dtc目录下除了提供dtc工具外，也可以自己安装dtc工具，linux下执行：sudo apt-get install device-tree-compiler安装dtc工具。其中还提供了一个fdtdump的工具，可以反编译dtb文件。dts和dtb文件的转换如图1所示。\ndtc工具的使用方法是：\ndtc –I dts –O dtb –o xxx.dtb xxx.dts  即可生成dts文件对应的dtb文件了。\n3. Device Tree头信息 fdtdump工具使用，Linux终端执行ftddump –h，输出以下信息：\nfdtdump -h Usage: fdtdump [options] Options: -[dshV] -d, –debug Dump debug information while decoding the file -s, –scan Scan for an embedded fdt in file -h, –help Print this help and exit -V, –version Print version and exit  本文采用s5pv21_smc.dtb文件为例说明fdtdump工具的使用。Linux终端执行fdtdump –sd s5pv21_smc.dtb \u0026gt; s5pv21_smc.txt，打开s5pv21_smc.txt文件，部分输出信息如下所示：\n// magic: 0xd00dfeed // totalsize: 0xce4 (3300) // off_dt_struct: 0x38 // off_dt_strings: 0xc34 // off_mem_rsvmap: 0x28 // version: 17 // last_comp_version: 16 // boot_cpuid_phys: 0x0 // size_dt_strings: 0xb0 // size_dt_struct: 0xbfc  以上信息便是Device Tree文件头信息，存储在dtb文件的开头部分。\n在Linux内核中使用struct fdt_header结构体描述。struct fdt_header结构体定义在scripts\\dtc\\libfdt\\fdt.h文件中。\nstruct fdt_header { fdt32_t magic; /* magic word FDT_MAGIC */ fdt32_t totalsize; /* total size of DT block */ fdt32_t off_dt_struct; /* offset to structure */ fdt32_t off_dt_strings; /* offset to strings */ fdt32_t off_mem_rsvmap; /* offset to memory reserve map */ fdt32_t version; /* format version */ fdt32_t last_comp_version; /* last compatible version */ /* version 2 fields below */ fdt32_t boot_cpuid_phys; /* Which physical CPU id we're booting on */ /* version 3 fields below */ fdt32_t size_dt_strings; /* size of the strings block */ /* version 17 fields below */ fdt32_t size_dt_struct; /* size of the structure block */ };  fdtdump工具的输出信息即是以上结构中每一个成员的值，struct fdt_header结构体包含了Device Tree的私有信息。例如: fdt_header.magic是fdt的魔数,固定值为0xd00dfeed，fdt_header.totalsize是fdt文件的大小。使用二进制工具打开s5pv21_smc.dtb验证。s5pv21_smc.dtb二进制文件头信息如图2所示。从图2中可以得到Device Tree的文件是以大端模式储存。并且，头部信息和fdtdump的输出信息一致。\nDevice Tree中的节点信息举例如下所示。 上述.dts文件并没有什么真实的用途，但它基本表征了一个Device Tree源文件的结构。\n  1个root结点“ / ”；\n  root结点下面含一系列子结点，本例中为“node@0”和“node@1”；\n  结点“node@0”下又含有一系列子结点，本例中为“ child-node@0 ”；\n  各结点都有一系列属性：\n   这些属性可能为空，如“ an-empty-property”；     可能为字符串，如“a-string-property”；     可能为字符串序列，如“a-string-list-property”；     可能为Cells（由u32整数组成，用尖括号括起来），如“second-child-property”；     可能为字节数据，（每个byte用2个16进制数表示，用“[]”括起来）如“a-byte-data-property”。    Device Tree源文件的结构分为header、fill_area、dt_struct及dt_string四个区域。header为头信息，fill_area为填充区域，填充数字0，dt_struct存储节点数值及名称相关信息，dt_string存储属性名。例如：a-string-property就存储在dt_string区，”A string”及node1就存储在dt_struct区域。\n我们可以给一个设备节点添加lable，之后可以通过\u0026amp;lable的形式访问这个lable，这种引用是通过phandle（pointer handle）进行的。例如，图3中的node1就是一个lable，node@0的子节点child-node@0通过\u0026lt;\u0026amp;node1\u0026gt;引用node@1节点。像是这种phandle的节点，在经过DTC工具编译之后，\u0026amp;node1会变成一个特殊的整型数字n，假设n值为1，那么在node@1节点下自动生成两个属性，属性如下： linux,phandle = \u0026lt;0x00000001\u0026gt;; phandle = \u0026lt;0x00000001\u0026gt;; node@0的子节点child-node@0中的a-reference-to-something = \u0026lt;\u0026amp;node1\u0026gt;会变成a-reference-to-something = \u0026lt; 0x00000001\u0026gt;。此处0x00000001就是一个phandle得值，每一个phandle都有一个独一无二的整型值，在后续kernel中通过这个特殊的数字间接找到引用的节点。通过查看fdtdump输出信息以及dtb二进制文件信息，得到struct fdt_header和文件结构之间的关系信息如所示。\n4. DTB文件结构 通过以上分析，可以得到Device Tree文件结构如图5所示。dtb的头部首先存放的是fdt_header的结构体信息，接着是填充区域，填充大小为off_dt_struct – sizeof(struct fdt_header)，填充的值为0。接着就是struct fdt_property结构体的相关信息。最后是dt_string部分。 Device Tree源文件的结构分为header、fill_area、dt_struct及dt_string四个区域。fill_area区域填充数值0。节点（node）信息使用struct fdt_node_header结构体描述。属性信息使用struct fdt_property结构体描述。各个结构体信息如下:\nstruct fdt_node_header { fdt32_t tag; char name[0]; }; struct fdt_property { fdt32_t tag; fdt32_t len; fdt32_t nameoff; char data[0]; };  struct fdt_node_header描述节点信息，tag是标识node的起始结束等信息的标志位，name指向node名称的首地址。tag的取值如下：\n#define FDT_BEGIN_NODE 0x1 /* Start node: full name */ #define FDT_END_NODE 0x2 /* End node */ #define FDT_PROP 0x3 /* Property: name off, size, content */ #define FDT_NOP 0x4 /* nop */ #define FDT_END 0x9  FDT_BEGIN_NODE和FDT_END_NODE标识node节点的起始和结束，FDT_PROP标识node节点下面的属性起始符，FDT_END标识Device Tree的结束标识符。因此，对于每个node节点的tag标识符一般为FDT_BEGIN_NODE，对于每个node节点下面的属性的tag标识符一般是FDT_PROP。\n描述属性采用struct fdt_property描述，tag标识是属性，取值为FDT_PROP；len为属性值的长度（包括‘\\0’，单位：字节）；nameoff为属性名称存储位置相对于off_dt_strings的偏移地址。\n例如：compatible = “samsung,goni”, “samsung,s5pv210”;compatible是属性名称，”samsung,goni”, “samsung,s5pv210”是属性值。compatible属性名称字符串存放的区域是dt_string。”samsung,goni”, “samsung,s5pv210”存放的位置是fdt_property.data后面。因此fdt_property.data指向该属性值。fdt_property.tag的值为属性标识，len为属性值的长度（包括‘\\0’，单位：字节）,此处len = 29。nameoff为compatible字符串的位置相对于off_dt_strings的偏移地址，即\u0026amp;compatible = nameoff + off_dt_strings。\ndt_struct在Device Tree中的结构如图6所示。节点的嵌套也带来tag标识符的嵌套。 5. kernel解析Device Tree Device Tree文件结构描述就以上struct fdt_header、struct fdt_node_header及struct fdt_property三个结构体描述。kernel会根据Device Tree的结构解析出kernel能够使用的struct property结构体。kernel根据Device Tree中所有的属性解析出数据填充struct property结构体。struct property结构体描述如下：\nstruct property { char *name; /* property full name */ int length; /* property value length */ void *value; /* property value */ struct property *next; /* next property under the same node */ unsigned long _flags; unsigned int unique_id; struct bin_attribute attr; /* 属性文件，与sysfs文件系统挂接 */ };  总的来说，kernel根据Device Tree的文件结构信息转换成struct property结构体，并将同一个node节点下面的所有属性通过property.next指针进行链接，形成一个单链表。 kernel中究竟是如何解析Device Tree的呢？下面分析函数解析过程。函数调用过程如图7所示。kernel的C语言阶段的入口函数是init/main.c/stsrt_kernel()函数，在early_init_dt_scan_nodes()中会做以下三件事：\n  扫描/chosen或者/chose@0节点下面的bootargs属性值到boot_command_line，此外，还处理initrd相关的property，并保存在initrd_start和initrd_end这两个全局变量中；\n  扫描根节点下面，获取{size,address}-cells信息，并保存在dt_root_size_cells和dt_root_addr_cells全局变量中；\n  扫描具有device_type =“memory”属性的/memory或者/memory@0节点下面的reg属性值，并把相关信息保存在meminfo中，全局变量meminfo保存了系统内存相关的信息。\n  Device Tree中的每一个node节点经过kernel处理都会生成一个struct device_node的结构体，struct device_node最终一般会被挂接到具体的struct device结构体。struct device_node结构体描述如下：\nstruct device_node { const char *name; /* node的名称，取最后一次“/”和“@”之间子串 */ const char *type; /* device_type的属性名称，没有为\u0026lt;NULL\u0026gt; */ phandle phandle; /* phandle属性值 */ const char *full_name; /* 指向该结构体结束的位置，存放node的路径全名，例如：/chosen */ struct fwnode_handle fwnode; struct property *properties; /* 指向该节点下的第一个属性，其他属性与该属性链表相接 */ struct property *deadprops; /* removed properties */ struct device_node *parent; /* 父节点 */ struct device_node *child; /* 子节点 */ struct device_node *sibling; /* 姊妹节点，与自己同等级的node */ struct kobject kobj; /* sysfs文件系统目录体现 */ unsigned long _flags; /* 当前node状态标志位，见/include/linux/of.h line124-127 */ void *data; }; /* flag descriptions (need to be visible even when !CONFIG_OF) */ #define OF_DYNAMIC 1 /* node and properties were allocated via kmalloc */ #define OF_DETACHED 2 /* node has been detached from the device tree*/ #define OF_POPULATED 3 /* device already created for the node */ #define OF_POPULATED_BUS 4 /* of_platform_populate recursed to children of this node */  struct device_node结构体中的每个成员作用已经备注了注释信息，下面分析以上信息是如何得来的。\nDevice Tree的解析首先从unflatten_device_tree()开始，代码列出如下：\n/** * unflatten_device_tree - create tree of device_nodes from flat blob * * unflattens the device-tree passed by the firmware, creating the * tree of struct device_node. It also fills the \u0026quot;name\u0026quot; and \u0026quot;type\u0026quot; * pointers of the nodes so the normal device-tree walking functions * can be used. */ void __init unflatten_device_tree(void) { __unflatten_device_tree(initial_boot_params, NULL, \u0026amp;of_root, early_init_dt_alloc_memory_arch, false); /* Get pointer to \u0026quot;/chosen\u0026quot; and \u0026quot;/aliases\u0026quot; nodes for use everywhere */ of_alias_scan(early_init_dt_alloc_memory_arch); }  分析以上代码，在unflatten_device_tree()中，调用函数__unflatten_device_tree()，参数initial_boot_params指向Device Tree在内存中的首地址，of_root在经过该函数处理之后，会指向根节点，early_init_dt_alloc_memory_arch是一个函数指针，为struct device_node和struct property结构体分配内存的回调函数（callback）。\n在__unflatten_device_tree()函数中，两次调用unflatten_dt_node()函数，第一次是为了得到Device Tree转换成struct device_node和struct property结构体需要分配的内存大小，第二次调用才是具体填充每一个struct device_node和struct property结构体。__unflatten_device_tree()代码列出如下：\n/** * __unflatten_device_tree - create tree of device_nodes from flat blob * * unflattens a device-tree, creating the * tree of struct device_node. It also fills the \u0026quot;name\u0026quot; and \u0026quot;type\u0026quot; * pointers of the nodes so the normal device-tree walking functions * can be used. * @blob: The blob to expand * @dad: Parent device node * @mynodes: The device_node tree created by the call * @dt_alloc: An allocator that provides a virtual address to memory * for the resulting tree * * Returns NULL on failure or the memory chunk containing the unflattened * device tree on success. */ static void *__unflatten_device_tree(const void *blob, struct device_node *dad, struct device_node **mynodes, void *(*dt_alloc)(u64 size, u64 align), bool detached) { int size; void *mem; pr_debug(\u0026quot; -\u0026gt; unflatten_device_tree()\\n\u0026quot;); if (!blob) { pr_debug(\u0026quot;No device tree pointer\\n\u0026quot;); return NULL; } pr_debug(\u0026quot;Unflattening device tree:\\n\u0026quot;); pr_debug(\u0026quot;magic: %08x\\n\u0026quot;, fdt_magic(blob)); pr_debug(\u0026quot;size: %08x\\n\u0026quot;, fdt_totalsize(blob)); pr_debug(\u0026quot;version: %08x\\n\u0026quot;, fdt_version(blob)); if (fdt_check_header(blob)) { pr_err(\u0026quot;Invalid device tree blob header\\n\u0026quot;); return NULL; } /* First pass, scan for size */ size = unflatten_dt_nodes(blob, NULL, dad, NULL); if (size \u0026lt; 0) return NULL; size = ALIGN(size, 4); pr_debug(\u0026quot; size is %d, allocating...\\n\u0026quot;, size); /* Allocate memory for the expanded device tree */ mem = dt_alloc(size + 4, __alignof__(struct device_node)); if (!mem) return NULL; memset(mem, 0, size); *(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef); pr_debug(\u0026quot; unflattening %p...\\n\u0026quot;, mem); /* Second pass, do actual unflattening */ unflatten_dt_nodes(blob, mem, dad, mynodes); if (be32_to_cpup(mem + size) != 0xdeadbeef) pr_warning(\u0026quot;End of tree marker overwritten: %08x\\n\u0026quot;, be32_to_cpup(mem + size)); if (detached \u0026amp;\u0026amp; mynodes) { of_node_set_flag(*mynodes, OF_DETACHED); pr_debug(\u0026quot;unflattened tree is detached\\n\u0026quot;); } pr_debug(\u0026quot; \u0026lt;- unflatten_device_tree()\\n\u0026quot;); return mem; }  __unflatten_device_tree()代码列出如下：\n/** * unflatten_dt_nodes - Alloc and populate a device_node from the flat tree * @blob: The parent device tree blob * @mem: Memory chunk to use for allocating device nodes and properties * @dad: Parent struct device_node * @nodepp: The device_node tree created by the call * * It returns the size of unflattened device tree or error code */ static int unflatten_dt_nodes(const void *blob, void *mem, struct device_node *dad, struct device_node **nodepp) { struct device_node *root; int offset = 0, depth = 0, initial_depth = 0; #define FDT_MAX_DEPTH\t64 unsigned int fpsizes[FDT_MAX_DEPTH]; struct device_node *nps[FDT_MAX_DEPTH]; void *base = mem; bool dryrun = !base; if (nodepp) *nodepp = NULL; /* * We're unflattening device sub-tree if @dad is valid. There are * possibly multiple nodes in the first level of depth. We need * set @depth to 1 to make fdt_next_node() happy as it bails * immediately when negative @depth is found. Otherwise, the device * nodes except the first one won't be unflattened successfully. */ if (dad) depth = initial_depth = 1; root = dad; fpsizes[depth] = dad ? strlen(of_node_full_name(dad)) : 0; nps[depth] = dad; for (offset = 0; offset \u0026gt;= 0 \u0026amp;\u0026amp; depth \u0026gt;= initial_depth; offset = fdt_next_node(blob, offset, \u0026amp;depth)) { if (WARN_ON_ONCE(depth \u0026gt;= FDT_MAX_DEPTH)) continue; fpsizes[depth+1] = populate_node(blob, offset, \u0026amp;mem, nps[depth], fpsizes[depth], \u0026amp;nps[depth+1], dryrun); if (!fpsizes[depth+1]) return mem - base; if (!dryrun \u0026amp;\u0026amp; nodepp \u0026amp;\u0026amp; !*nodepp) *nodepp = nps[depth+1]; if (!dryrun \u0026amp;\u0026amp; !root) root = nps[depth+1]; } if (offset \u0026lt; 0 \u0026amp;\u0026amp; offset != -FDT_ERR_NOTFOUND) { pr_err(\u0026quot;Error %d processing FDT\\n\u0026quot;, offset); return -EINVAL; } /* * Reverse the child list. Some drivers assumes node order matches .dts * node order */ if (!dryrun) reverse_nodes(root); return mem - base; }  通过以上函数处理就得到了所有的struct device_node结构体，为每一个node都会自动添加一个名称为“name”的property，property.length的值为当前node的名称取最后一个“/”和“@”之间的子串（包括‘\\0’）。例如：/serial@e2900800，则length = 7，property.value = device_node.name = “serial”。\n6. platform_device和device_node绑定 经过以上解析，Device Tree的数据已经全部解析出具体的struct device_node和struct property结构体，下面需要和具体的device进行绑定。首先讲解platform_device和device_node的绑定过程。在arch/arm/kernel/setup.c文件中，customize_machine()函数负责填充struct platform_device结构体。函数调用过程如下图所示。\n代码分析如下：\nconst struct of_device_id of_default_bus_match_table[] = { { .compatible = \u0026quot;simple-bus\u0026quot;, }, { .compatible = \u0026quot;simple-mfd\u0026quot;, }, #ifdef CONFIG_ARM_AMBA { .compatible = \u0026quot;arm,amba-bus\u0026quot;, }, #endif /* CONFIG_ARM_AMBA */ {} /* Empty terminated list */ }; int of_platform_populate(struct device_node *root, const struct of_device_id *matches, const struct of_dev_auxdata *lookup, struct device *parent) { struct device_node *child; int rc = 0; /* 获取根节点 */ root = root ? of_node_get(root) : of_find_node_by_path(\u0026quot;/\u0026quot;); if (!root) return -EINVAL; /* 为根节点下面的每一个节点创建platform_device结构体 */ for_each_child_of_node(root, child) { rc = of_platform_bus_create(child, matches, lookup, parent, true); if (rc) { of_node_put(child); break; } } /* 更新device_node flag标志位 */ of_node_set_flag(root, OF_POPULATED_BUS); of_node_put(root); return rc; } static int of_platform_bus_create(struct device_node *bus, const struct of_device_id *matches, const struct of_dev_auxdata *lookup, struct device *parent, bool strict) { const struct of_dev_auxdata *auxdata; struct device_node *child; struct platform_device *dev; const char *bus_id = NULL; void *platform_data = NULL; int rc = 0; /* 只有包含\u0026quot;compatible\u0026quot;属性的node节点才会生成相应的platform_device结构体 */ /* Make sure it has a compatible property */ if (strict \u0026amp;\u0026amp; (!of_get_property(bus, \u0026quot;compatible\u0026quot;, NULL))) { return 0; } /* 省略部分代码 */ /* * 针对节点下面得到status = \u0026quot;ok\u0026quot; 或者status = \u0026quot;okay\u0026quot;或者不存在status属性的 * 节点分配内存并填充platform_device结构体 */ dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent); if (!dev || !of_match_node(matches, bus)) return 0; /* 递归调用节点解析函数，为子节点继续生成platform_device结构体，前提是父节点 * 的“compatible” = “simple-bus”，也就是匹配of_default_bus_match_table结构体中的数据 */ for_each_child_of_node(bus, child) { rc = of_platform_bus_create(child, matches, lookup, \u0026amp;dev-\u0026gt;dev, strict); if (rc) { of_node_put(child); break; } } of_node_set_flag(bus, OF_POPULATED_BUS); return rc; }  总的来说，当of_platform_populate()函数执行完毕:\n  kernel就为DTB中所有包含compatible属性名的第一级node创建platform_device结构体，并向平台设备总线注册设备信息。\n  如果第一级node的compatible属性值等于“simple-bus”、“simple-mfd”或者”arm,amba-bus”的话，kernel会继续为当前node的第二级包含compatible属性的node创建platform_device结构体，并注册设备。\n  Linux系统下的设备大多都是挂载在平台总线下的，因此在平台总线被注册后，会根据of_root节点的树结构，去寻找该总线的子节点，所有的子节点将被作为设备注册到该总线上。\n7. i2c_client和device_node绑定 经过customize_machine()函数的初始化，DTB已经转换成platform_device结构体，这其中就包含i2c adapter设备，不同的SoC需要通过平台设备总线的方式自己实现i2c adapter设备的驱动。例如：i2c_adapter驱动的probe函数中会调用i2c_add_numbered_adapter()注册adapter驱动，函数流执行如图9所示。 在of_i2c_register_devices()函数内部便利i2c节点下面的每一个子节点，并为子节点（status = “disable”的除外）创建i2c_client结构体，并与子节点的device_node挂接。其中i2c_client的填充是在i2c_new_device()中进行的，最后device_register()。在构建i2c_client的时候，会对node下面的compatible属性名称的厂商名字去除作为i2c_client的name。例如：compatible = “maxim,ds1338”,则i2c_client-\u0026gt;name = “ds1338”。\n8. Device_Tree与sysfs kernel启动流程为start_kernel()→rest_init()→kernel_thread():kernel_init()→do_basic_setup()→driver_init()→of_core_init()，在of_core_init()函数中在sys/firmware/devicetree/base目录下面为设备树展开成sysfs的目录和二进制属性文件，所有的node节点就是一个目录，所有的property属性就是一个二进制属性文件。\n9. 特此感谢 感谢原创作者的文章，文章图片表达清晰，代码注释详细，对我帮助很大。 ———————————————— 版权声明：本文为CSDN博主「smcdef」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/smcdef/article/details/77387975\n","date":1594893659,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1594893659,"objectID":"6700822a5e8f541b5cc4a0436a16cd29","permalink":"https://strivefar.github.io/project/post/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3-imx6ull/","publishdate":"2020-07-16T18:00:59+08:00","relpermalink":"/project/post/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3-imx6ull/","section":"project","summary":"1. Device Tree简介 2. Device Tree编译 3. Device Tree头信息 4. DTB文件结构 5. kernel解析Device Tree 6. platform_device和devi","tags":["linux","IMX6ULL"],"title":"设备树详解","type":"project"},{"authors":["youngfar"],"categories":null,"content":" 1. 前言 2. 关键词解释：  2.1. 变量的存储方式  2.1.1. 静态存储变量 2.1.2. 动态存储变量   2.2. 生存期的区别   3. static 全局变量与普通全局变量的区别 ？ 4. static局部变量和普通局部变量有什么区别 ？ 5. static函数与普通函数有什么区别？ 6. 巧用static,默认初始化为0 7. 总结：static关键字的作用 8. 参考来源：  1. 前言 Linux内核源码中使用的大量的static关键字来修饰变量和函数，有效的防止了不同文件间的相同变量或函数名引起的冲突，关于static的作用，现解释如下，如有问题，欢迎批评指正。\n2. 关键词解释： 2.1. 变量的存储方式  可分为：“静态存储”和“动态存储”两种。  2.1.1. 静态存储变量  通常是在变量定义时就分定存储单元并一直保持不变，直至整个程序结束，即在程序运行期间分配固定的存储空间。 全局变量即属于此类存储方式。  2.1.2. 动态存储变量  在程序执行过程中，使用它时才分配存储单元，使用完毕立即释放。  典型的例子是函数的形式参数，在函数定义时并不给行参分配存储单元，只是在函数被调用时，才予以分配，调用函数完毕立即释放。 如果一个函数被多次调用时，则反复地分配、释放形参变量的存储单元。\n2.2. 生存期的区别  静态存储变量是一直存在的，而动态存储变量则时而存在时而消失。通常把由于变量存储方式不同而产生的特性称为变量的生存期。  3. static 全局变量与普通全局变量的区别 ？  普通全局变量加上static修饰后就变成了static全局变量 二者都是存储在静态变量区，即以静态存储方式进行存储， 区别：全局变量加上static之后就被限制了可见范围   未加static之前，全局变量在所有的源程序都可见，只要加上extern即可使用其他文件中定义的全局变量；     加上static之后，变为了静态全局变量，静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。    4. static局部变量和普通局部变量有什么区别 ？  保持变量内容的持久，存储在静态数据区的变量会在程序编译时分配固定的存储空间，程序刚开始运行时就完成初始化，也是唯一的一次初始化。 举例如下：  #include \u0026lt;stdio.h\u0026gt; int fun(void) { /*static局部变量只被初始化一次，下一次使用时在上一次结果值的基础上进行改变*/ static int count = 10; return count--; } int count = 1; int main(void) { printf(\u0026quot;global\\t\\tlocal static\\n\u0026quot;); for(; count \u0026lt;= 10; ++count) printf(\u0026quot;%d\\t\\t%d\\n\u0026quot;, count, fun()); return 0; } 程序的运行结果是： global local static 1 10 2 9 3 8 4 7 5 6 6 5 7 4 8 3 9 2 10 1  5. static函数与普通函数有什么区别？ 这有些类似于static 全局变量与普通全局变量的区别，同样的，static函数仅对定义该函数的当前文件可见，无法像普通函数一样加上extern声明就能在其他文件中使用。\n也就是说static修饰后成为了内部函数，应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件.\n6. 巧用static,默认初始化为0 static的第三个作用是默认初始化为0。其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加\u0026rsquo;\\ 0'太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是\u0026rsquo;\\0\u0026rsquo;。不妨做个小实验验证一下。\n#include \u0026lt;stdio.h\u0026gt; int a; int main(void) { int i; static char str[10]; printf(\u0026quot;integer: %d; string: (begin)%s(end)\u0026quot;, a, str); return 0; }  运行结果如下：\ninteger: 0; string: (begin)(end)  7. 总结：static关键字的作用  1.隐藏（限制作用域） 2.保持变量内容的持久（静态局部变量） 3.默认初始化为0  8. 参考来源： 特此感谢： https://blog.csdn.net/tr_ainiyangyang/article/details/80965574 https://blog.csdn.net/qq_37858386/article/details/79064900\n","date":1594530352,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1594530352,"objectID":"0cb0c3d345cb042e2e7834ee9dcb0c1b","permalink":"https://strivefar.github.io/project/post/static%E7%9A%84%E4%BD%9C%E7%94%A8/","publishdate":"2020-07-12T13:05:52+08:00","relpermalink":"/project/post/static%E7%9A%84%E4%BD%9C%E7%94%A8/","section":"project","summary":"1. 前言 2. 关键词解释： 2.1. 变量的存储方式 2.1.1. 静态存储变量 2.1.2. 动态存储变量 2.2. 生存期的区别 3. static 全局变量与普通全局变量的区别 ？ 4. static局部变量和普通","tags":["C"],"title":"Static的作用","type":"project"},{"authors":["youngfar"],"categories":null,"content":" 1. 板子启动后查看设备树  1.1. 文件说明   2. 编译/反编译 设备树文件  2.1. 手动编译 2.2. 在内核根目录下自动编译  2.2.1. 过程解析     3. led驱动模板——设备树改造  3.1. 给开发板更换设备树文件 3.2. 内核驱动程序的改造  3.2.1. platform_device（包含来自设备树的） 如何与 platform_driver 配对:  3.2.1.1. 使用设备树信息来判断 dev 和 drv 是否配对时     3.3. 按照这种转换关系，代码改造如下 3.4. 匹配成功后，会调用chip_demo_gpio_probe 注册分配的各种资源 3.5. 注销分配的各种资源： 3.6. 然后是模块加载和卸载函数： 3.7. 进入开发板的/mnt目录下 3.8. 将leddrv.ko 和 chip_demo_gpio.ko 注册进内核 3.9. 执行一下命令来进行点灯的操作 3.10. 前后对比，观察一下转化关系   4. 参考来源 5. 程序  1. 板子启动后查看设备树 注意：开发板中仅存放dtb 二进制文件，所以想直接查看开发板中的dts文件是查看不到的，需要先通过网络文件系统将开发板中dtb 二进制文件的copy到虚拟机，在虚拟机中反编译得到dts文件\n板子启动后执行下面的命令：\nls /sys/firmware/ devicetree fdt  1.1. 文件说明 /sys/firmware/devicetree 目录下是以目录结构程现的 dtb 文件, 根结点对应 base 目录, 每一个结点对应一个目录, 每一个属性对应一个文件。\n这些属性的值如果是字符串，可以使用 cat 命令把它打印出来；对于数值可以用 hexdump 把它打印出来。\n还可以看到/sys/firmware/fdt 文件，它就是 dtb 格式的设备树文件，可以把它复制出来放到 ubuntu上，执行下面的命令反编译出来(-I dtb：输入格式是 dtb，-O dts：输出格式是 dts)：\ncd 板子所用的内核源码目录为 ./scripts/dtc/dtc -I dtb -O dts /从板子上/复制出来的/fdt -o tmp.dts  2. 编译/反编译 设备树文件 2.1. 手动编译 内核目录下 scripts/dtc/dtc 是设备树的编译工具，直接使用它的话，包含其他文件时不能使用 “#include”，而必须使用“/incldue”。\n编译、反编译的示例命令如下，“-I”指定输入格式，“-O”指定输出格式，“-o”指定输出文件：\n./scripts/dtc/dtc -I dts -O dtb -o tmp.dtb arch/arm/boot/dts/xxx.dts // 编译 dts 为 dtb ./scripts/dtc/dtc -I dtb -O dts -o tmp.dts arch/arm/boot/dts/xxx.dtb // 反编译 dtb 为 dts  2.2. 在内核根目录下自动编译 V=1 察看编译过程,不关心过程省略即可\nmake dtbs V=1 mkdir -p arch/arm/boot/dts/ ; arm-linux-gnueabihf-gcc -E -Wp,-MD,arch/arm/boot/dts/.imx6ull-14x14-ebf-mini.dtb.d.pre.tmp -nostdinc -I./arch/arm/boot/dts -I./arch/arm/boot/dts/include -I./drivers/of/testcase-data -undef -D__DTS__ -x assembler-with-cpp -o arch/arm/boot/dts/.imx6ull-14x14-ebf-mini.dtb.dts.tmp arch/arm/boot/dts/imx6ull-14x14-ebf-mini.dts ; ./scripts/dtc/dtc -O dtb -o arch/arm/boot/dts/imx6ull-14x14-ebf-mini.dtb -b 0 -i arch/arm/boot/dts/ -Wno-unit_address_vs_reg -d arch/arm/boot/dts/.imx6ull-14x14-ebf-mini.dtb.d.dtc.tmp arch/arm/boot/dts/.imx6ull-14x14-ebf-mini.dtb.dts.tmp ;  2.2.1. 过程解析 它首先用 arm-linux-gnueabihf-gcc 预处理 dts 文件，把其中的.h 头文件包含进来，把宏展开。\n然后使用 scripts/dtc/dtc 生成 dtb 文件。\n可见，dts 文件之所以支持“#include”语法，是因为 arm-linux-gnueabihf-gcc 帮忙。\n如果只用 dtc 工具，它是不支持”#include”语法的，只支持“/include”语法。\n3. led驱动模板——设备树改造 3.1. 给开发板更换设备树文件 imx6ull 单板 设备树文件是：内核源码目录中：\n/home/book/100ask_imx6ull-sdk/Linux-4.9.88  其在内核源码目录中的路径为\narch/arm/boot/dts/100ask_imx6ull-14x14.dts  要更换板子上的设备树文件，启动板子后，更换这个文件：\n/boot/100ask_imx6ull-14x14.dtb     远程登录Linux服务器后：先搜索dts文件    book@100ask:~/100ask_imx6ull-sdk/Linux-4.9.88/arch/arm/boot/dts$ find -name 100ask_imx6ull-14x14.dts ./100ask_imx6ull-14x14.dts    然后打开后添加node（子结点）： 在根结点下添加100ask_led@0和100ask_led@1这两个子结点（由于dts篇幅较长，这里仅展示一部分）    /dts-v1/; #include \u0026lt;dt-bindings/input/input.h\u0026gt; #include \u0026quot;imx6ull.dtsi\u0026quot; #define GROUP_PIN(g,p) ((g\u0026lt;\u0026lt;16) | (p)) / { model = \u0026quot;Freescale i.MX6 ULL 14x14 EVK Board\u0026quot;; compatible = \u0026quot;fsl,imx6ull-14x14-evk\u0026quot;, \u0026quot;fsl,imx6ull\u0026quot;; chosen { stdout-path = \u0026amp;uart1; }; memory { reg = \u0026lt;0x80000000 0x20000000\u0026gt;; }; reserved-memory { #address-cells = \u0026lt;1\u0026gt;; #size-cells = \u0026lt;1\u0026gt;; ranges; linux,cma { compatible = \u0026quot;shared-dma-pool\u0026quot;; reusable; size = \u0026lt;0x14000000\u0026gt;; linux,cma-default; }; }; 100ask_led@0 { compatible = \u0026quot;100as,leddrv\u0026quot;; pin = \u0026lt;GROUP_PIN(5,3)\u0026gt;; }; 100ask_led@1 { compatible = \u0026quot;100as,leddrv\u0026quot;; pin = \u0026lt;GROUP_PIN(5,8)\u0026gt;; };    在内核源码目录中执行make dtbs编译dts得到dtb文件：    book@100ask:~/100ask_imx6ull-sdk/Linux-4.9.88/arch/arm/boot/dts$ cd /home/book/100ask_imx6ull-sdk/Linux-4.9.88 book@100ask:~/100ask_imx6ull-sdk/Linux-4.9.88$ make dtbs CHK include/config/kernel.release CHK include/generated/uapi/linux/version.h CHK include/generated/utsrelease.h CHK include/generated/bounds.h CHK include/generated/timeconst.h CHK include/generated/asm-offsets.h CALL scripts/checksyscalls.sh DTC arch/arm/boot/dts/100ask_imx6ull-14x14.dtb  上述编译结果中，DTC 后面的即为编译好的设备树的二进制文件\n然后通过网络传输一下：\nbook@100ask:~/100ask_imx6ull-sdk/Linux-4.9.88$ cp arch/arm/boot/dts/100ask_imx6ull-14x14.dtb ~/nfs_rootfs/    在开发板中（串口操作） 首先进入到/boot目录中    cd /boot  然后查看一下/boot/ 的内容\n[root@imx6ull:/boot]# ls 100ask_imx6ull-14x14.dtb zImage 100ask_imx6ull-14x14_back.dtb  这里的100ask_imx6ull-14x14_back.dtb 是原来的100ask_imx6ull-14x14.dtb的备份，建议备份一下\n然后重启开发板\n[root@imx6ull:/boot]# reboot  3.2. 内核驱动程序的改造 内核处理设备树的函数调用过程，这里不去分析；我们只需要得到如下结论：\n A. platform_device 中含有 resource 数组, 它来自 device_node 的 reg, interrupts 属性; B. platform_device.dev.of_node 指向 device_node, 可以通过它获得其他属性  在/home/book/100ask_imx6ull-sdk/Linux-4.9.88/include/linux/的device.h中 定义了一个struct device 结构体\n/** * struct device - The basic device structure * @of_node:\tAssociated device tree node. */ struct device { /* ...省略部分代码 */ struct device_node\t*of_node; /* associated device tree node */ struct fwnode_handle\t*fwnode; /* firmware device node */ /* ...省略部分代码 */ };  3.2.1. platform_device（包含来自设备树的） 如何与 platform_driver 配对: 3.2.1.1. 使用设备树信息来判断 dev 和 drv 是否配对时   首先，如果 of_match_table 中含有 compatible 值，就跟 dev 的 compatile 属性比较，若一致则成功，否则返回失败；\n  其次，如果 of_match_table 中含有 type 值，就跟 dev 的 device_type 属性比较，若一致则成功，否则返回失败；\n  最后，如果 of_match_table 中含有 name 值，就跟 dev 的 name 属性比较，若一致则成功，否则返回失败。\n  而设备树中建议不再使用 devcie_type 和 name 属性，所以基本上只使用设备节点的 compatible 属性 来寻找匹配的 platform_driver。\n  对上述关系还有一个非常有趣的拟人化解释，这个解释出自这位博主的博客，链接如下： https://blog.csdn.net/zqixiao_09/article/details/50888795\n打个比方，就好比相亲，总线是红娘，设备是男方，驱动是女方：\na \u0026ndash; 红娘（总线）负责男方（设备）和女方（驱动）的撮合； b \u0026ndash; 男方（女方）找到红娘，说我来登记一下，看有没有合适的姑娘（汉子）—— 设备或驱动的注册；\nc \u0026ndash; 红娘这时候就需要看看有没有八字（二者的name 字段）匹配的姑娘（汉子）——match 函数进行匹配，看name是否相同；\nd \u0026ndash; 如果八字不合，就告诉男方（女方）没有合适的对象，先等着，别急着乱做事 —— 设备和驱动会等待，直到匹配成功；\ne \u0026ndash; 终于遇到八字匹配的了，那就结婚呗！接完婚，男方就向女方交代，我有多少存款，我的房子在哪，钱放在哪等等（ struct resource *resource），女方说好啊，于是去房子里拿钱，去给男方买菜啦，给自己买衣服、化妆品、首饰啊等等（int (*probe)(struct platform_device *) 匹配成功后驱动执行的第一个函数），当然如果男的跟小三跑了（设备卸载），女方也不会继续待下去的（ int (*remove)(struct platform_device *)）。\n3.3. 按照这种转换关系，代码改造如下 /* of_device_id */ static const struct of_device_id ask100_leds[] = { { .compatible = \u0026quot;100as,leddrv\u0026quot; }, { }, //标志结束，不可省略 }; static struct platform_driver chip_demo_gpio_driver = { .probe = chip_demo_gpio_probe, .remove = chip_demo_gpio_remove, .driver = { .name = \u0026quot;mytest_led\u0026quot;, .of_match_table = ask100_leds, //得到of_device_id }, };  3.4. 匹配成功后，会调用chip_demo_gpio_probe 注册分配的各种资源 static int chip_demo_gpio_probe(struct platform_device *pdev) { struct device_node *np; int err = 0; int led_pin; np = pdev-\u0026gt;dev.of_node; if (!np) return -1; /* 从设备树转化过来的平台设备中提取pin资源 */ err = of_property_read_u32(np, \u0026quot;pin\u0026quot;, \u0026amp;led_pin); /* 利用设备的资源依次注册设备 */ g_ledpins[g_ledcnt] = led_pin; led_class_create_device(g_ledcnt); g_ledcnt++; return 0; }  3.5. 注销分配的各种资源： static int chip_demo_gpio_remove(struct platform_device *pdev) { int i = 0; int err; struct device_node *np; int led_pin; np = pdev-\u0026gt;dev.of_node; if (!np) return -1; /* 判断一下是否为之前已解析到的pin属性 */ err = of_property_read_u32(np, \u0026quot;pin\u0026quot;, \u0026amp;led_pin); for (i = 0; i \u0026lt; g_ledcnt; i++) { /* 如果是，则销毁设备，并把存放引脚属性的数组对应元素置为-1 */ if (g_ledpins[i] == led_pin) { led_class_destroy_device(i); g_ledpins[i] = -1; break; }; } /* 遍历一遍引脚属性数组，如果均为-1，说明都已经销毁掉了 */ for (i = 0; i \u0026lt; g_ledcnt; i++) { if (g_ledpins[i] != -1) break; } /*如果均已销毁，引脚属性数组为空，则把已注册的LED灯的个数置为0，方便下次注册 */ if (i == g_ledcnt) g_ledcnt = 0; return 0; }  3.6. 然后是模块加载和卸载函数： static int __init chip_demo_gpio_drv_init(void) { int err; err = platform_driver_register(\u0026amp;chip_demo_gpio_driver); register_led_operations(\u0026amp;board_demo_led_opr); return 0; } static void __exit lchip_demo_gpio_drv_exit(void) { platform_driver_unregister(\u0026amp;chip_demo_gpio_driver); } module_init(chip_demo_gpio_drv_init); module_exit(lchip_demo_gpio_drv_exit); MODULE_LICENSE(\u0026quot;GPL\u0026quot;);  可以看到,模块加载和卸载函数仅仅通过paltform_driver_register()、paltform_driver_unregister() 函数进行 platform_driver 的注册和注销，而原先注册和注销字符设备的工作已经被移交到 platform_driver 的 probe() 和 remove() 成员函数中。\n3.7. 进入开发板的/mnt目录下 [root@imx6ull:/mnt]# ls 100ask_imx6ull-14x14.dtb leddrv.ko chip_demo_gpio.ko ledtest  3.8. 将leddrv.ko 和 chip_demo_gpio.ko 注册进内核 [root@imx6ull:/mnt]# insmod leddrv.ko [root@imx6ull:/mnt]# insmod chip_demo_gpio.ko  进入到如下目录来查看一下，匹配之后的目录结构如下： 3.9. 执行一下命令来进行点灯的操作 [root@imx6ull:/mnt]# ./ledtest /dev/mytest_led0 on [root@imx6ull:/mnt]# ./ledtest /dev/mytest_led0 off  注意：这里设备名之所以是mytest_ledx，是因为上层驱动中的device_create函数以\u0026quot;mytest_led%d\u0026quot;进行设备的创建\nvoid led_class_create_device(int minor) { device_create(led_class, NULL, MKDEV(major, minor), NULL, \u0026quot;mytest_led%d\u0026quot;, minor); /* /dev/mytest_led0,1,... */ }  文末给出了具体的chip_demo_gpio.c 和 应用层的led_test.c等代码\n3.10. 前后对比，观察一下转化关系 关于内核对设备树文件的解析，可以参考设备树详解中的内容。这里仅针对目录结构对应的转化关系来看看结果。\n  根结点下的子结点（一级结点）中的属性名，将来会成为开发板中/sys/firmware/devicetree/base目录下的文件，base则对应为根结点;   对于根结点下的二级结点，同样会以一级结点名作为目录，二级结点中的属性名将成为该目录下的文件 以reserved-memory结点为例，其包含linux,cma这一子结点：   [root@imx6ull:/sys/firmware/devicetree/base/reserved-memory]# cd linux,cma [root@imx6ull:/sys/firmware/devicetree/base/reserved-memory/linux,cma]# ls compatible name size linux,cma-default reusable   对于结点中包含的属性，按照不同类型的值转换为不同类型的文件   这些属性的值如果是字符串，可以使用 cat 命令把它打印出来；    [root@imx6ull:/sys/firmware/devicetree/base/reserved-memory]# ls #address-cells #size-cells linux,cma name ranges [root@imx6ull:/sys/firmware/devicetree/base/reserved-memory]# cat name reserved-memory     对于数值，可以用 hexdump 把它打印出来    [root@imx6ull:/sys/firmware/devicetree/base/reserved-memory/linux,cma]# ls compatible name size linux,cma-default reusable izeot@imx6ull:/sys/firmware/devicetree/base/reserved-memory/linux,cma]# hexdump s 0000000 0014 0000 0000004  4. 参考来源 本文参考了并学习了韦东山老师的视频和配套的文档，特此感谢\n5. 程序  chip_demo_gpio.c  #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/fs.h\u0026gt; #include \u0026lt;linux/errno.h\u0026gt; #include \u0026lt;linux/miscdevice.h\u0026gt; #include \u0026lt;linux/kernel.h\u0026gt; #include \u0026lt;linux/major.h\u0026gt; #include \u0026lt;linux/mutex.h\u0026gt; #include \u0026lt;linux/proc_fs.h\u0026gt; #include \u0026lt;linux/seq_file.h\u0026gt; #include \u0026lt;linux/stat.h\u0026gt; #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/device.h\u0026gt; #include \u0026lt;linux/tty.h\u0026gt; #include \u0026lt;linux/kmod.h\u0026gt; #include \u0026lt;linux/gfp.h\u0026gt; #include \u0026lt;linux/platform_device.h\u0026gt; #include \u0026lt;linux/of.h\u0026gt; #include \u0026lt;asm/io.h\u0026gt; #include \u0026quot;led_opr.h\u0026quot; #include \u0026quot;leddrv.h\u0026quot; #include \u0026quot;led_resource.h\u0026quot; static int g_ledpins[100]; static int g_ledcnt = 0; static volatile unsigned int val; static volatile unsigned int* CCM_CCGR1; static volatile unsigned int* IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3; static volatile unsigned int* GPIO5_GDIR; static volatile unsigned int* GPIO5_DR; static int board_demo_led_init(int which) /* 初始化LED, which-哪个LED */ { //printk(\u0026quot;%s %s line %d, led %d\\n\u0026quot;, __FILE__, __FUNCTION__, __LINE__, which); printk(\u0026quot;init gpio: group %d, pin %d\\n\u0026quot;, GROUP(g_ledpins[which]), PIN(g_ledpins[which])); switch (GROUP(g_ledpins[which])) { case 0: { printk(\u0026quot;init pin of group 0 ...\\n\u0026quot;); break; } case 1: { printk(\u0026quot;init pin of group 1 ...\\n\u0026quot;); break; } case 2: { printk(\u0026quot;init pin of group 2 ...\\n\u0026quot;); break; } case 3: { printk(\u0026quot;init pin of group 3 ...\\n\u0026quot;); break; } case 4: { printk(\u0026quot;init pin of group 4 ...\\n\u0026quot;); break; } case 5: { printk(\u0026quot;init pin of group 5 ...\\n\u0026quot;); if (!CCM_CCGR1) { CCM_CCGR1 = ioremap(0x20C406C, 4); IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = ioremap(0x2290014, 4); GPIO5_GDIR = ioremap(0x020AC000 + 0x4, 4); GPIO5_DR = ioremap(0x020AC000 + 0, 4); } /* GPIO5_IO03 */ /* a. 使能GPIO5 * set CCM to enable GPIO5 * CCM_CCGR1[CG15] 0x20C406C * bit[31:30] = 0b11 */ *CCM_CCGR1 |= (3 \u0026lt;\u0026lt; 30); /* b. 设置GPIO5_IO03用于GPIO * set IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 * to configure GPIO5_IO03 as GPIO * IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 0x2290014 * bit[3:0] = 0b0101 alt5 */ val = *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3; val \u0026amp;= ~(0xf); val |= (5); *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = val; /* b. 设置GPIO5_IO03作为output引脚 * set GPIO5_GDIR to configure GPIO5_IO03 as output * GPIO5_GDIR 0x020AC000 + 0x4 * bit[3] = 0b1 */ *GPIO5_GDIR |= (1 \u0026lt;\u0026lt; 3); break; } } return 0; } static int board_demo_led_ctl(int which, char status) /* 控制LED, which-哪个LED, status:1-亮,0-灭 */ { //printk(\u0026quot;%s %s line %d, led %d, %s\\n\u0026quot;, __FILE__, __FUNCTION__, __LINE__, which, status ? \u0026quot;on\u0026quot; : \u0026quot;off\u0026quot;); printk(\u0026quot;set led %s: group %d, pin %d\\n\u0026quot;, status ? \u0026quot;on\u0026quot; : \u0026quot;off\u0026quot;, GROUP(g_ledpins[which]), PIN(g_ledpins[which])); switch (GROUP(g_ledpins[which])) { case 0: { printk(\u0026quot;set pin of group 0 ...\\n\u0026quot;); break; } case 1: { printk(\u0026quot;set pin of group 1 ...\\n\u0026quot;); break; } case 2: { printk(\u0026quot;set pin of group 2 ...\\n\u0026quot;); break; } case 3: { printk(\u0026quot;set pin of group 3 ...\\n\u0026quot;); break; } case 4: { printk(\u0026quot;set pin of group 4 ...\\n\u0026quot;); break; } case 5: { switch (PIN(g_ledpins[which])) { case 0: /* code */ break; case 1: /* code */ break; case 2: /* code */ break; case 3: if (status) /* on: output 0*/ { /* d. 设置GPIO5_DR输出低电平 * set GPIO5_DR to configure GPIO5_IO03 output 0 * GPIO5_DR 0x020AC000 + 0 * bit[3] = 0b0 */ *GPIO5_DR \u0026amp;= ~(1 \u0026lt;\u0026lt; 3); } else /* off: output 1*/ { /* e. 设置GPIO5_IO3输出高电平 * set GPIO5_DR to configure GPIO5_IO03 output 1 * GPIO5_DR 0x020AC000 + 0 * bit[3] = 0b1 */ *GPIO5_DR |= (1 \u0026lt;\u0026lt; 3); } break; default: break; } printk(\u0026quot;set pin of group 5 ...\\n\u0026quot;); break; } } return 0; } static struct led_operations board_demo_led_opr = { .init = board_demo_led_init, .ctl = board_demo_led_ctl, }; struct led_operations *get_board_led_opr(void) { return \u0026amp;board_demo_led_opr; } static int chip_demo_gpio_probe(struct platform_device *pdev) { struct device_node *np; int err = 0; int led_pin; np = pdev-\u0026gt;dev.of_node; if (!np) return -1; /* 从设备树转化过来的平台设备中提取pin资源 */ err = of_property_read_u32(np, \u0026quot;pin\u0026quot;, \u0026amp;led_pin); /* 利用设备的资源依次注册设备 */ g_ledpins[g_ledcnt] = led_pin; led_class_create_device(g_ledcnt); g_ledcnt++; return 0; } static int chip_demo_gpio_remove(struct platform_device *pdev) { int i = 0; int err; struct device_node *np; int led_pin; np = pdev-\u0026gt;dev.of_node; if (!np) return -1; /* 判断一下是否为之前已解析到的pin属性 */ err = of_property_read_u32(np, \u0026quot;pin\u0026quot;, \u0026amp;led_pin); for (i = 0; i \u0026lt; g_ledcnt; i++) { /* 如果是，则销毁设备，并把存放引脚属性的数组对应元素置为-1 */ if (g_ledpins[i] == led_pin) { led_class_destroy_device(i); g_ledpins[i] = -1; break; }; } /* 遍历一遍引脚属性数组，如果均为-1，说明都已经销毁掉了 */ for (i = 0; i \u0026lt; g_ledcnt; i++) { if (g_ledpins[i] != -1) break; } /*如果均已销毁，引脚属性数组为空，则把已注册的LED灯的个数置为0，方便下次注册 */ if (i == g_ledcnt) g_ledcnt = 0; return 0; } static const struct of_device_id ask100_leds[] = { { .compatible = \u0026quot;100as,leddrv\u0026quot; }, { }, }; static struct platform_driver chip_demo_gpio_driver = { .probe = chip_demo_gpio_probe, .remove = chip_demo_gpio_remove, .driver = { .name = \u0026quot;mytest_led\u0026quot;, .of_match_table = ask100_leds, }, }; static int __init chip_demo_gpio_drv_init(void) { int err; err = platform_driver_register(\u0026amp;chip_demo_gpio_driver); register_led_operations(\u0026amp;board_demo_led_opr); return 0; } static void __exit lchip_demo_gpio_drv_exit(void) { platform_driver_unregister(\u0026amp;chip_demo_gpio_driver); } module_init(chip_demo_gpio_drv_init); module_exit(lchip_demo_gpio_drv_exit); MODULE_LICENSE(\u0026quot;GPL\u0026quot;);   上层驱动leddrv.c  #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/fs.h\u0026gt; #include \u0026lt;linux/errno.h\u0026gt; #include \u0026lt;linux/miscdevice.h\u0026gt; #include \u0026lt;linux/kernel.h\u0026gt; #include \u0026lt;linux/major.h\u0026gt; #include \u0026lt;linux/mutex.h\u0026gt; #include \u0026lt;linux/proc_fs.h\u0026gt; #include \u0026lt;linux/seq_file.h\u0026gt; #include \u0026lt;linux/stat.h\u0026gt; #include \u0026lt;linux/init.h\u0026gt; #include \u0026lt;linux/device.h\u0026gt; #include \u0026lt;linux/tty.h\u0026gt; #include \u0026lt;linux/kmod.h\u0026gt; #include \u0026lt;linux/gfp.h\u0026gt; #include \u0026quot;led_opr.h\u0026quot; /* 1. 确定主设备号 */ static int major = 0; static struct class *led_class; struct led_operations *p_led_opr; #define MIN(a, b) (a \u0026lt; b ? a : b) //void led_class_create_device(int minor) //{ //\tdevice_create(led_class, NULL, MKDEV(major, minor), NULL, \u0026quot;100ask_led%d\u0026quot;, minor); /* /dev/100ask_led0,1,... */ //} void led_class_create_device(int minor) { device_create(led_class, NULL, MKDEV(major, minor), NULL, \u0026quot;mytest_led%d\u0026quot;, minor); /* /dev/mytest_led0,1,... */ } void led_class_destroy_device(int minor) { device_destroy(led_class, MKDEV(major, minor)); } void register_led_operations(struct led_operations *opr) { p_led_opr = opr; } EXPORT_SYMBOL(led_class_create_device); EXPORT_SYMBOL(led_class_destroy_device); EXPORT_SYMBOL(register_led_operations); /* 3. 实现对应的open/read/write等函数，填入file_operations结构体 */ static ssize_t led_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset) { printk(\u0026quot;%s %s line %d\\n\u0026quot;, __FILE__, __FUNCTION__, __LINE__); return 0; } /* write(fd, \u0026amp;val, 1); */ static ssize_t led_drv_write (struct file *file, const char __user *buf, size_t size, loff_t *offset) { int err; char status; struct inode *inode = file_inode(file); int minor = iminor(inode); printk(\u0026quot;%s %s line %d\\n\u0026quot;, __FILE__, __FUNCTION__, __LINE__); err = copy_from_user(\u0026amp;status, buf, 1); /* 根据次设备号和status控制LED */ p_led_opr-\u0026gt;ctl(minor, status); return 1; } static int led_drv_open (struct inode *node, struct file *file) { int minor = iminor(node); printk(\u0026quot;%s %s line %d\\n\u0026quot;, __FILE__, __FUNCTION__, __LINE__); /* 根据次设备号初始化LED */ p_led_opr-\u0026gt;init(minor); return 0; } static int led_drv_close (struct inode *node, struct file *file) { printk(\u0026quot;%s %s line %d\\n\u0026quot;, __FILE__, __FUNCTION__, __LINE__); return 0; } /* 2. 定义自己的file_operations结构体 */ static struct file_operations led_drv = { .owner\t= THIS_MODULE, .open = led_drv_open, .read = led_drv_read, .write = led_drv_write, .release = led_drv_close, }; /* 4. 把file_operations结构体告诉内核：注册驱动程序 */ /* 5. 谁来注册驱动程序啊？得有一个入口函数：安装驱动程序时，就会去调用这个入口函数 */ static int __init led_init(void) { int err; printk(\u0026quot;%s %s line %d\\n\u0026quot;, __FILE__, __FUNCTION__, __LINE__); major = register_chrdev(0, \u0026quot;100ask_led\u0026quot;, \u0026amp;led_drv); /* /dev/led */ led_class = class_create(THIS_MODULE, \u0026quot;100ask_led_class\u0026quot;); err = PTR_ERR(led_class); if (IS_ERR(led_class)) { printk(\u0026quot;%s %s line %d\\n\u0026quot;, __FILE__, __FUNCTION__, __LINE__); unregister_chrdev(major, \u0026quot;100ask_led\u0026quot;); return -1; } return 0; } /* 6. 有入口函数就应该有出口函数：卸载驱动程序时，就会去调用这个出口函数 */ static void __exit led_exit(void) { printk(\u0026quot;%s %s line %d\\n\u0026quot;, __FILE__, __FUNCTION__, __LINE__); class_destroy(led_class); unregister_chrdev(major, \u0026quot;100ask_led\u0026quot;); } /* 7. 其他完善：提供设备信息，自动创建设备节点 */ module_init(led_init); module_exit(led_exit); MODULE_LICENSE(\u0026quot;GPL\u0026quot;);   应用程序  #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; /* * ./ledtest /dev/100ask_led0 on * ./ledtest /dev/100ask_led0 off */ int main(int argc, char **argv) { int fd; char status; /* 1. 判断参数 */ if (argc != 3) { printf(\u0026quot;Usage: %s \u0026lt;dev\u0026gt; \u0026lt;on | off\u0026gt;\\n\u0026quot;, argv[0]); return -1; } /* 2. 打开文件 */ fd = open(argv[1], O_RDWR); if (fd == -1) { printf(\u0026quot;can not open file %s\\n\u0026quot;, argv[1]); return -1; } /* 3. 写文件 */ if (0 == strcmp(argv[2], \u0026quot;on\u0026quot;)) { status = 1; write(fd, \u0026amp;status, 1); } else { status = 0; write(fd, \u0026amp;status, 1); } close(fd); return 0; }   Makefile  # 1. 使用不同的开发板内核时, 一定要修改KERN_DIR # 2. KERN_DIR中的内核要事先配置、编译, 为了能编译内核, 要先设置下列环境变量: # 2.1 ARCH, 比如: export ARCH=arm64 # 2.2 CROSS_COMPILE, 比如: export CROSS_COMPILE=aarch64-linux-gnu- # 2.3 PATH, 比如: export PATH=$PATH:/home/book/100ask_roc-rk3399-pc/ToolChain-6.3.1/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin # 注意: 不同的开发板不同的编译器上述3个环境变量不一定相同, # 请参考各开发板的高级用户使用手册 KERN_DIR = /home/book/100ask_imx6ull-sdk/Linux-4.9.88 all: make -C $(KERN_DIR) M=`pwd` modules $(CROSS_COMPILE)gcc -o ledtest ledtest.c clean: make -C $(KERN_DIR) M=`pwd` modules clean rm -rf modules.order rm -f ledtest # 参考内核源码drivers/char/ipmi/Makefile # 要想把a.c, b.c编译成ab.ko, 可以这样指定: # ab-y := a.o b.o # obj-m += ab.o obj-m += leddrv.o chip_demo_gpio.o  ","date":1594008063,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1594008063,"objectID":"db335458a84e7b8c29480e0b67d1e028","permalink":"https://strivefar.github.io/project/post/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%AD%E6%B3%95/","publishdate":"2020-07-06T12:01:03+08:00","relpermalink":"/project/post/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%AD%E6%B3%95/","section":"project","summary":"1. 板子启动后查看设备树 1.1. 文件说明 2. 编译/反编译 设备树文件 2.1. 手动编译 2.2. 在内核根目录下自动编译 2.2.1. 过程解析 3. led驱动模板——设备树改造 3.1. 给开发板","tags":["linux"],"title":"Linux 设备驱动开发————设备树应用实例（imx6ull）","type":"project"},{"authors":["youngfar"],"categories":null,"content":"绘制思维导图如下： ","date":1593878657,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1593878657,"objectID":"6e413c37a8c5286085da52312ab08d06","permalink":"https://strivefar.github.io/project/post/%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/","publishdate":"2020-07-05T00:04:17+08:00","relpermalink":"/project/post/%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/","section":"project","summary":"绘制思维导图如下：","tags":["linux"],"title":"总线设备驱动模型","type":"project"},{"authors":["youngfar"],"categories":null,"content":" 前言 参数的调用方式  11.1. 传值调用 11.2. 传址调用 11.3. 传引用调用 11.4. 示例说明   使用二级指针/一级指针创建链表时的对比  12.1. 主函数中作此调用 12.2. 使用二级指针创建链表 12.3. 使用一级指针创建链表会成功吗   销毁链表时二级指针和一级指针的对比  13.1. 使用二级指针销毁链表 13.2. 使用一级指针销毁链表会成功吗   总结 完整代码 参考来源  前言 我们在学习数据结构时，在链表初始化或者销毁链表的时候，经常使用二级指针或者一级指针的引用，这是为什么呢？同样是指向内存单元的地址，为什么就不能使用一级指针呢？使用一级指针去初始化或者是销毁链表的时候，究竟会发生什么呢？到底什么时候该用二级指针，什么时候该用一级指针？\n如果你对这些问题有疑问，可以参考本篇文章，以下是我个人对这些问题的理解，如有问题，欢迎随时联系我。\n参数的调用方式 我们通常使用的函数调用方式无非两种，一种是传值调用，一种是传址调用。 谈起指针我们可能瞬间就会把它和传址调用联系在一起，但实际上，对于指针来讲，它也存在着这两种调用方式，传值调用和传值调用。\n11.1. 传值调用 传值调用是指在调用参数时,不是对原参数进行操作,而是创建参数的拷贝并对其进行操作,这种调用有利于保护数据。\n11.2. 传址调用 传址调用的过程中把函数外部创建的变量的内存地址传递给函数参数，这种调用可以让函数和函数外边的变量建立起联系，函数内部可以直接操作函数外部；\n11.3. 传引用调用 适用于C++，不适用于C语言\n11.4. 示例说明 注意： 传递一级指针变量本身等价于在传递指针变量的值，虽然有指针参与其中，但在函数内部，也只是创建了指针的copy，无非就是把传过来的实参的值给指针的copy用一用，并没有对实参（原指针变量）进行操作\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string.h\u0026gt; using namespace std; void fun1(char* str) { str = new char[5]; strcpy (str, \u0026quot;test string\u0026quot;); } void fun2(char** str) { *str = new char[5]; strcpy (*str, \u0026quot;test string\u0026quot;); } int main() { char* s = NULL; cout \u0026lt;\u0026lt; \u0026quot;call function fun1\u0026quot; \u0026lt;\u0026lt; endl; fun1 (s); if (!s) cout \u0026lt;\u0026lt; \u0026quot;s is null!\u0026quot; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;call function fun2\u0026quot; \u0026lt;\u0026lt; endl; fun2 (\u0026amp;s); if (!s) cout \u0026lt;\u0026lt; \u0026quot;s is null!\u0026quot; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } ———————————————— 版权声明：本文为CSDN博主「踏莎行hyx」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/u012234115/article/details/39717215  输出结果： 使用二级指针/一级指针创建链表时的对比 12.1. 主函数中作此调用 int main() { LinkList L; ElemType e; Status i; int j, k; //InitList1(L); //一级指针方式创建表头，失败 InitList2(\u0026amp;L); //二级指针方式创建表头，成功 }  12.2. 使用二级指针创建链表 //初始化表头，用二级指针 Status InitList2(LinkList *L) //等价于Node **L { *L = (LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */ if (!(*L)) /* 存储分配失败 */ return ERROR; (*L)-\u0026gt;next = NULL; /* 指针域为空 */ return OK; }  用图片说明更为直观： 函数内部可以直接操作函数外部\n简明描述为： 如果没有头结点： ![在这里插入图片描述]12.3. 使用一级指针创建链表会成功吗 //初始化表头，用一级指针（此方式无效） Status InitList1(LinkList L) //等价于Node *L { L = (LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */ if (!L) /* 存储分配失败 */ return ERROR; L-\u0026gt;next = NULL; /* 指针域为空 */ return OK; }  用图片说明更为直观： ![在这里插入图片描述]很明显，把传过来的实参的值给指针的copy用一用，并没有对实参（原指针变量）进行操作，这样创建的链表是毫无意义的，main.c后面再使用L时，用的依旧是个垃圾值，是有隐患的。\n销毁链表时二级指针和一级指针的对比 main.c中：\nprintf(\u0026quot;销毁链表\\n\u0026quot;); //DestroyList1(L); //一级指针方式销毁链表，失败,且出现满屏乱码 DestroyList2(\u0026amp;L); //二级指针方式销毁链表，成功  13.1. 使用二级指针销毁链表 //销毁链表，使用二级指针 Status DestroyList2(LinkList *L) { LinkList p, q; p = (*L)-\u0026gt;next; /* p指向第一个结点 */ while (p) /* 没到表尾 */ { q = p-\u0026gt;next; free(p); p = q; } free(*L); //头结点彻底没有掉才是销毁 *L = NULL; return OK; }  用图片说明更为直观：\n![在这里插入图片描述]简单来说： 销毁链表就是让头指针为空，然后这个链表就彻底湮没在内存中了\n![在这里插入图片描述]13.2. 使用一级指针销毁链表会成功吗 //销毁链表，使用一级指针(此方式无效) Status DestroyList1(LinkList L) { LinkList p, q; p = L-\u0026gt;next; /* p指向第一个结点 */ while (p) /* 没到表尾 */ { q = p-\u0026gt;next; free(p); p = q; } free(L); L = NULL; return OK; }  用图片说明更为直观：\n![在这里插入图片描述]可见这种方式的确很危险，实际测试中也的确出现了乱码\n总结 1.初始化链表头部指针需要用二级指针或者一级指针的引用。\n2.销毁链表需要用到二级指针或者一级指针的引用。\n3.插入、删除、遍历、清空结点用一级指针即可。\n完整代码 #include \u0026quot;stdio.h\u0026quot; #include \u0026quot;stdlib.h\u0026quot; #include \u0026quot;time.h\u0026quot; #define OK 1 #define ERROR 0 #define TRUE 1 #define FALSE 0 #define MAXSIZE 20 /* 存储空间初始分配量 */ typedef int Status; /* Status是函数的类型,其值是函数结果状态代码，如OK等 */ typedef int ElemType; /* ElemType类型根据实际情况而定，这里假设为int */ Status visit(ElemType c) { printf(\u0026quot;%d \u0026quot;, c); return OK; } typedef struct Node { ElemType data; struct Node *next; } Node; typedef struct Node *LinkList; /* 定义LinkList */ //初始化表头，用一级指针（此方式无效） Status InitList1(LinkList L) //等价于Node *L { L = (LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */ if (!L) /* 存储分配失败 */ return ERROR; L-\u0026gt;next = NULL; /* 指针域为空 */ return OK; } //初始化表头，用二级指针 Status InitList2(LinkList *L) //等价于Node **L { *L = (LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */ if (!(*L)) /* 存储分配失败 */ return ERROR; (*L)-\u0026gt;next = NULL; /* 指针域为空 */ return OK; } //初始化表头，用一级指针引用 Status InitList3(LinkList \u0026amp;L) //等价于Node *\u0026amp;L { L = (LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */ if (!L) /* 存储分配失败 */ return ERROR; L-\u0026gt;next = NULL; /* 指针域为空 */ return OK; } //清空链表，使用二级指针 Status ClearList1(LinkList *L) { LinkList p, q; p = (*L)-\u0026gt;next; /* p指向第一个结点 */ while (p) /* 没到表尾 */ { q = p-\u0026gt;next; free(p); p = q; } (*L)-\u0026gt;next = NULL; /* 头结点指针域为空 */ return OK; } //清空链表，使用一级指针 Status ClearList2(LinkList L) { LinkList p, q; p = L-\u0026gt;next; /* p指向(这里的第一个结点只头结点) */ while (p) /* 没到表尾 */ { q = p-\u0026gt;next; free(p); p = q; } L-\u0026gt;next = NULL; /* 头结点指针域为空 */ return OK; } //销毁链表，使用一级指针(此方式无效) Status DestroyList1(LinkList L) { LinkList p, q; p = L-\u0026gt;next; /* p指向第一个结点 */ while (p) /* 没到表尾 */ { q = p-\u0026gt;next; free(p); p = q; } free(L); L = NULL; return OK; } //销毁链表，使用二级指针 Status DestroyList2(LinkList *L) { LinkList p, q; p = (*L)-\u0026gt;next; /* p指向头结点(第一个结点) */ while (p) /* 没到表尾 */ { q = p-\u0026gt;next; free(p); p = q; } free(*L); //头结点彻底没有掉才是销毁 *L = NULL; return OK; } //销毁链表，使用一级指针引用 Status DestroyList3(LinkList \u0026amp;L) { LinkList p, q; p = L-\u0026gt;next; /* p指向第一个结点 */ while (p) /* 没到表尾 */ { q = p-\u0026gt;next; free(p); p = q; } free(L); L = NULL; return OK; } /* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */ /* 操作结果：用e返回L中第i个数据元素的值 */ Status GetElem(LinkList L, int i, ElemType *e) { int j; LinkList p; /* 声明一结点p */ p = L-\u0026gt;next; /* 让p指向链表L的第一个结点 */ j = 1; /* j为计数器 */ while (p \u0026amp;\u0026amp; j \u0026lt; i) /* p不为空或者计数器j还没有等于i时，循环继续 */ { p = p-\u0026gt;next; /* 让p指向下一个结点 */ ++j; } if (!p || j \u0026gt; i) return ERROR; /* 第i个元素不存在 */ *e = p-\u0026gt;data; /* 取第i个元素的数据 */ return OK; } //在中间插入元素，用二级指针 Status ListInsert1(LinkList *L, int i, ElemType e) { int j; LinkList p, s; p = *L; j = 1; while (p \u0026amp;\u0026amp; j \u0026lt; i) /* 寻找第i个结点 */ { p = p-\u0026gt;next; ++j; } if (!p || j \u0026gt; i) return ERROR; /* 第i个元素不存在 */ s = (LinkList)malloc(sizeof(Node)); /* 生成新结点(C语言标准函数) */ s-\u0026gt;data = e; s-\u0026gt;next = p-\u0026gt;next; /* 将p的后继结点赋值给s的后继 */ p-\u0026gt;next = s; /* 将s赋值给p的后继 */ return OK; } //在中间插入元素，用一级指针 Status ListInsert2(LinkList L, int i, ElemType e) { int j; LinkList p, s; p = L; j = 1; while (p \u0026amp;\u0026amp; j \u0026lt; i) /* 寻找第i个结点 */ { p = p-\u0026gt;next; ++j; } if (!p || j \u0026gt; i) return ERROR; /* 第i个元素不存在 */ s = (LinkList)malloc(sizeof(Node)); /* 生成新结点(C语言标准函数) */ s-\u0026gt;data = e; s-\u0026gt;next = p-\u0026gt;next; /* 将p的后继结点赋值给s的后继 */ p-\u0026gt;next = s; /* 将s赋值给p的后继 */ return OK; } //删除一个元素，用二级指针 Status ListDelete1(LinkList *L, int i, ElemType *e) { int j; LinkList p, q; p = *L; j = 1; while (p-\u0026gt;next \u0026amp;\u0026amp; j \u0026lt; i) /* 遍历寻找第i个元素 */ { p = p-\u0026gt;next; ++j; } if (!(p-\u0026gt;next) || j \u0026gt; i) return ERROR; /* 第i个元素不存在 */ q = p-\u0026gt;next; p-\u0026gt;next = q-\u0026gt;next; /* 将q的后继赋值给p的后继 */ *e = q-\u0026gt;data; /* 将q结点中的数据给e */ free(q); /* 让系统回收此结点，释放内存 */ return OK; } //删除一个元素，用一级指针 Status ListDelete2(LinkList L, int i, ElemType *e) { int j; LinkList p, q; p = L; j = 1; while (p-\u0026gt;next \u0026amp;\u0026amp; j \u0026lt; i) /* 遍历寻找第i个元素 */ { p = p-\u0026gt;next; ++j; } if (!(p-\u0026gt;next) || j \u0026gt; i) return ERROR; /* 第i个元素不存在 */ q = p-\u0026gt;next; p-\u0026gt;next = q-\u0026gt;next; /* 将q的后继赋值给p的后继 */ *e = q-\u0026gt;data; /* 将q结点中的数据给e */ free(q); /* 让系统回收此结点，释放内存 */ return OK; } /* 初始条件：顺序线性表L已存在 */ /* 操作结果：依次对L的每个数据元素输出 */ Status ListTraverse(LinkList L) { LinkList p = L-\u0026gt;next; while (p) { visit(p-\u0026gt;data); p = p-\u0026gt;next; } printf(\u0026quot;\\n\u0026quot;); return OK; } int main() { LinkList L; ElemType e; Status i; int j, k; //InitList1(L); //一级指针方式创建表头，失败 //InitList2(\u0026amp;L); //二级指针方式创建表头，成功 InitList3(L); //一级指针引用方式创建表头，成功 for (j = 1; j \u0026lt;= 7; j++) ListInsert2(L, 1, j); printf(\u0026quot;一级指针方式在L的表头依次插入1～7后：\u0026quot;); ListTraverse(L); ListInsert1(\u0026amp;L, 3, 12); printf(\u0026quot;二级指针方式在L的中间插入12后：\u0026quot;); ListTraverse(L); ListInsert2(L, 5, 27); printf(\u0026quot;一级指针在L的中间插入27后：\u0026quot;); ListTraverse(L); GetElem(L, 5, \u0026amp;e); printf(\u0026quot;第5个元素的值为：%d\\n\u0026quot;, e); ListDelete1(\u0026amp;L, 5, \u0026amp;e); /* 删除第5个数据 */ printf(\u0026quot;二级指针方式删除第%d个的元素值为：%d\\n\u0026quot;, 5, e); printf(\u0026quot;依次输出L的元素：\u0026quot;); ListTraverse(L); ListDelete2(L, 3, \u0026amp;e); /* 删除第3个数据 */ printf(\u0026quot;一级指针方式删除第%d个的元素值为：%d\\n\u0026quot;, 3, e); printf(\u0026quot;依次输出L的元素：\u0026quot;); ListTraverse(L); printf(\u0026quot;二级指针方式清空链表\\n\u0026quot;); ClearList1(\u0026amp;L); printf(\u0026quot;依次输出L的元素：\u0026quot;); ListTraverse(L); for (j = 1; j \u0026lt;= 7; j++) ListInsert2(L, j, j); printf(\u0026quot;在L的表尾依次插入1～7后：\u0026quot;); ListTraverse(L); printf(\u0026quot;一级指针方式清空链表\\n\u0026quot;); ClearList2(L); printf(\u0026quot;依次输出L的元素：\u0026quot;); ListTraverse(L); printf(\u0026quot;销毁链表\\n\u0026quot;); //DestroyList1(L); //一级指针方式销毁链表，失败,且出现满屏乱码 DestroyList2(\u0026amp;L); //二级指针方式销毁链表，成功 DestroyList3(L); //一级指针引用方式销毁链表，成功 return 0; }  参考来源 本文参考了以下博文，结合自己的理解，总结记录了相关知识，特此感谢 https://blog.csdn.net/u012234115/article/details/39717215 https://blog.csdn.net/DX_Jone/article/details/102817995\n","date":1591352808,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1591352808,"objectID":"023659301634c78eb2c3f28ed9be9e54","permalink":"https://strivefar.github.io/project/post/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/","publishdate":"2020-06-05T18:26:48+08:00","relpermalink":"/project/post/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/","section":"project","summary":"前言 参数的调用方式 11.1. 传值调用 11.2. 传址调用 11.3. 传引用调用 11.4. 示例说明 使用二级指针/一级指针创建链表时的对比 12.1. 主函数中作此调用 12.2. 使用二级指针创建链表 12.3.","tags":["Data_Structure"],"title":"链表中为何使用二级指针或者一级指针的引用","type":"project"},{"authors":["youngfar"],"categories":null,"content":"参考链接 GCC生成动态链接库（.so文件）：-shared和-fPIC选项 GCC创建和使用静态链接库（.a文件） gcc的使用方法；动态编译和静态编译；Linux制作动态库和静态库\n命名规则 静态库命名规则如下： libxxx.o lib:前缀 .o:静态库 动态链接库（shared object file，共享对象文件）命名规则如下： libxxx.so lib:前缀 .so:动态库\n静态库参数 gcc 常用编译选项 动态库和静态库的对比 我们先来说一下静态库； Linux下的静态库是以.a结尾的二进制文件，它作为一个程序的模块，它在链接期间就被组合到了程序中，比如说我有一个主程序mian.c，那么我把它和静态库链接的时候，它就直接把这个静态库组合到了我的main.c里面生成的一个二进制文件.a。 而与静态链接库相对的是动态链接库，同样的是把主函数mian.c和动态库进行链接，与静态库不同的是,这个动态库在程序运行的阶段才会被加载进内存,参与主函数运行 下面用几张图来说明一下： 还可以加上-static选项，让链接静态库后的math.out彻底的独立起来，“完全静态”，因此，得到的二进制文件会非常大。 使用静态/动态链接库的优缺点： 静态库： 编译后的执行程序不需要外部的函数库支持，因为所有使用的函数都经被编译进去了。当然这也会成为他的缺点，因为如果静态函数库改变了，那么你的程序必须重新编译。\n静态库的代码在编译时链接到应用程序中，因此编译时库文件必须存在并且需要通过“-L”参数传递给编译器，应用程序在开始执行时，库函数代码将随程序一 起调入进程内存段直到进程结束，其执行过程不需要原静态库存在。\n动态库： 动态函数库在编译的时候并没有被编译进目标代码中，你的程序执行到相关函数时才调用该函数库里的相应函数，因此动态函数库所产生的可执行文件比较小。由于函数库没有被整合进你的程序，而是程序运行时动态的申请并调用，所以程序的运行环境中必须提供相应的库。动态函数库的改变并不影响你的程序，所以动态函数库的升级比较方便。\n不同的INIX系统链接动态库方法，实现细节不一样，编译PIC型.o中间文件的方法一般是采用C语言编译器的-KPIC或者 -fPIC选项 最主要的是GCC命令行的一个选项: -shared:该选项指定生成动态连接库(让连接器生成T类型的导出符号表，有时候也生成弱连接W类 型的导出符号) ,不用该标志外部程序无法连接。相当于一个可执行文件 -fPIC:表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的,所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。\n制作链接库的目的（商业角度）： 这就和商业项目挂钩了: 假如我们是一个项目的外包方，我们是有专利的，希望别人使用我们已经实现的功能，但又不希望别人看到我们的源代码，所以这对商业机构是非常友好的。\nMakefile中的使用实例： ","date":1589328000,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1589328000,"objectID":"1871c95961991aff494bda9a3a308f67","permalink":"https://strivefar.github.io/project/post/getting-started/","publishdate":"2020-05-13T00:00:00Z","relpermalink":"/project/post/getting-started/","section":"project","summary":"参考链接 GCC生成动态链接库（.so文件）：-shared和-fPIC选项 GCC创建和使用静态链接库（.a文件） gcc的使用方法；动态编译和","tags":["linux"],"title":"动态编译和静态编译——制作动态库和静态库","type":"project"},{"authors":["YoungFar"],"categories":null,"content":" Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature.   Supplementary notes can be added here, including code and math.\n","date":1554595200,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1554595200,"objectID":"557dc08fd4b672a0c08e0a8cf0c9ff7d","permalink":"https://strivefar.github.io/publication/preprint/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/preprint/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example preprint / working paper","type":"publication"},{"authors":[],"categories":[],"content":"Create slides in Markdown with Academic Academic | Documentation\n Features  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides   Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E   Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)   Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = ;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\n Fragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}}  Press Space to play!\nOne  Two  Three \n A fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears   Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}}  Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view    Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links    night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links   Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/img/boards.jpg\u0026quot; \u0026gt;}} {{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}} {{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}   Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; }   Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"https://strivefar.github.io/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Academic's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":["YoungFar","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.    Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature.   Supplementary notes can be added here, including code and math.\n","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1441065600,"objectID":"966884cc0d8ac9e31fab966c4534e973","permalink":"https://strivefar.github.io/publication/journal-article/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/journal-article/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example journal article","type":"publication"},{"authors":["YoungFar","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.    Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature.   Supplementary notes can be added here, including code and math.\n","date":1372636800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1372636800,"objectID":"69425fb10d4db090cfbd46854715582c","permalink":"https://strivefar.github.io/publication/conference-paper/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/conference-paper/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example conference paper","type":"publication"}]