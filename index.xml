<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>YoungFar的个人博客——Love&amp;Share</title>
    <link>https://strivefar.github.io/</link>
      <atom:link href="https://strivefar.github.io/index.xml" rel="self" type="application/rss+xml" />
    <description>YoungFar的个人博客——Love&amp;Share</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><copyright>© 2005-2020版权所有[沪ICP备01234567号](http://www.beian.miit.gov.cn)</copyright><lastBuildDate>Thu, 28 Jun 2018 00:00:00 +0100</lastBuildDate>
    <image>
      <url>https://strivefar.github.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>YoungFar的个人博客——Love&amp;Share</title>
      <link>https://strivefar.github.io/</link>
    </image>
    
    <item>
      <title>Example Page 1</title>
      <link>https://strivefar.github.io/courses/example/example1/</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0100</pubDate>
      <guid>https://strivefar.github.io/courses/example/example1/</guid>
      <description>&lt;p&gt;In this tutorial, I&amp;rsquo;ll share my top 10 tips for getting started with Academic:&lt;/p&gt;
&lt;h2 id=&#34;tip-1&#34;&gt;Tip 1&lt;/h2&gt;
&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.&lt;/p&gt;
&lt;p&gt;Nullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.&lt;/p&gt;
&lt;p&gt;Cras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.&lt;/p&gt;
&lt;p&gt;Suspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.&lt;/p&gt;
&lt;p&gt;Aliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.&lt;/p&gt;
&lt;h2 id=&#34;tip-2&#34;&gt;Tip 2&lt;/h2&gt;
&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.&lt;/p&gt;
&lt;p&gt;Nullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.&lt;/p&gt;
&lt;p&gt;Cras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.&lt;/p&gt;
&lt;p&gt;Suspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.&lt;/p&gt;
&lt;p&gt;Aliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Example Page 2</title>
      <link>https://strivefar.github.io/courses/example/example2/</link>
      <pubDate>Sun, 05 May 2019 00:00:00 +0100</pubDate>
      <guid>https://strivefar.github.io/courses/example/example2/</guid>
      <description>&lt;p&gt;Here are some more tips for getting started with Academic:&lt;/p&gt;
&lt;h2 id=&#34;tip-3&#34;&gt;Tip 3&lt;/h2&gt;
&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.&lt;/p&gt;
&lt;p&gt;Nullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.&lt;/p&gt;
&lt;p&gt;Cras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.&lt;/p&gt;
&lt;p&gt;Suspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.&lt;/p&gt;
&lt;p&gt;Aliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.&lt;/p&gt;
&lt;h2 id=&#34;tip-4&#34;&gt;Tip 4&lt;/h2&gt;
&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.&lt;/p&gt;
&lt;p&gt;Nullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.&lt;/p&gt;
&lt;p&gt;Cras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.&lt;/p&gt;
&lt;p&gt;Suspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.&lt;/p&gt;
&lt;p&gt;Aliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Example Talk</title>
      <link>https://strivefar.github.io/talk/example/</link>
      <pubDate>Sat, 01 Jun 2030 13:00:00 +0000</pubDate>
      <guid>https://strivefar.github.io/talk/example/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Click on the &lt;strong&gt;Slides&lt;/strong&gt; button above to view the built-in slides feature.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Slides can be added in a few ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Create&lt;/strong&gt; slides using Academic&amp;rsquo;s &lt;a href=&#34;https://sourcethemes.com/academic/docs/managing-content/#create-slides&#34;&gt;&lt;em&gt;Slides&lt;/em&gt;&lt;/a&gt; feature and link using &lt;code&gt;slides&lt;/code&gt; parameter in the front matter of the talk file&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Upload&lt;/strong&gt; an existing slide deck to &lt;code&gt;static/&lt;/code&gt; and link using &lt;code&gt;url_slides&lt;/code&gt; parameter in the front matter of the talk file&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Embed&lt;/strong&gt; your slides (e.g. Google Slides) or presentation video on this page using &lt;a href=&#34;https://sourcethemes.com/academic/docs/writing-markdown-latex/&#34;&gt;shortcodes&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Further talk details can easily be added to this page using &lt;em&gt;Markdown&lt;/em&gt; and $\rm \LaTeX$ math code.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43;_Primer_Plus_chapter2</title>
      <link>https://strivefar.github.io/project/post/c&#43;&#43;_primer_plus_chapter2/</link>
      <pubDate>Tue, 11 Aug 2020 09:36:53 +0800</pubDate>
      <guid>https://strivefar.github.io/project/post/c&#43;&#43;_primer_plus_chapter2/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E7%A8%8B%E5%BA%8F%E6%B8%85%E5%8D%9526&#34;&gt;1. 程序清单2.6&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-26%E8%AF%B4%E6%98%8E&#34;&gt;1.1. 2.6说明：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;1-程序清单26&#34;&gt;1. 程序清单2.6&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// convert.cpp -- converts stone to pounds
#include &amp;lt;iostream&amp;gt;
int stonetolb(int);     // function prototype
int main()
{
    using namespace std;
    int stone;
    cout &amp;lt;&amp;lt; &amp;quot;Enter the weight in stone: &amp;quot;;
    cin &amp;gt;&amp;gt; stone;
    int pounds = stonetolb(stone);
    cout &amp;lt;&amp;lt; stone &amp;lt;&amp;lt; &amp;quot; stone = &amp;quot;;
    cout &amp;lt;&amp;lt; pounds &amp;lt;&amp;lt; &amp;quot; pounds.&amp;quot; &amp;lt;&amp;lt; endl;
    return 0;
}

int stonetolb(int sts)
{
    return 14 * sts;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;11-26说明&#34;&gt;1.1. 2.6说明：&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;  cout &amp;lt;&amp;lt; stone &amp;lt;&amp;lt; &amp;quot; stone = &amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;输出到屏幕上的只能是字符串形式，所以在打印之前，cout必须将整数形式的数字转换为字符串形式。&lt;/li&gt;
&lt;li&gt;cout 相比 printf 更“聪明”,知道stone是一个需要转换的整数，而printf则需要使用特殊代码进行指定要打印的是字符串还是整数&lt;/li&gt;
&lt;li&gt;cout 的智能行为源自C++的面向对象的特性&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;printf(&amp;quot;Printing a string : %s\n&amp;quot;,&amp;quot;25&amp;quot;);
printf(&amp;quot;Printing an integer: %d\n&amp;quot;, 25);
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define  min(x,y)  ({                   \
	 typeof(x)  __min1 = (x);        \
     typeof(y) __min2 = (y);             \
     (void)  (&amp;amp; __min1 == &amp;amp; __min2);     \
    __min1 &amp;lt; __min2  ? __min1 :__min2})
    
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>设备树详解</title>
      <link>https://strivefar.github.io/project/post/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3-imx6ull/</link>
      <pubDate>Thu, 16 Jul 2020 18:00:59 +0800</pubDate>
      <guid>https://strivefar.github.io/project/post/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3-imx6ull/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-device-tree%E7%AE%80%E4%BB%8B&#34;&gt;1. Device Tree简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-device-tree%E7%BC%96%E8%AF%91&#34;&gt;2. Device Tree编译&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-device-tree%E5%A4%B4%E4%BF%A1%E6%81%AF&#34;&gt;3. Device Tree头信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-dtb%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84&#34;&gt;4. DTB文件结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-kernel%E8%A7%A3%E6%9E%90device-tree&#34;&gt;5. kernel解析Device Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-platform_device%E5%92%8Cdevice_node%E7%BB%91%E5%AE%9A&#34;&gt;6. platform_device和device_node绑定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-i2c_client%E5%92%8Cdevice_node%E7%BB%91%E5%AE%9A&#34;&gt;7. i2c_client和device_node绑定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8-device_tree%E4%B8%8Esysfs&#34;&gt;8. Device_Tree与sysfs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9-%E7%89%B9%E6%AD%A4%E6%84%9F%E8%B0%A2&#34;&gt;9. 特此感谢&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#内核对设备树的处理
dts在PC 上被编译为.dtb文件；
uboot把dtb文件传给内核；
内核解析dtb 文件，把每一个节点都转换为 device_node 结构体；
对于某些device_node结构体，会被转换为platform_device结构体。&lt;/p&gt;
&lt;h1 id=&#34;1-device-tree简介&#34;&gt;1. Device Tree简介&lt;/h1&gt;
&lt;p&gt;Linus Torvalds在2011年3月17日的ARM Linux邮件列表宣称“this whole ARM thing is a fucking pain in the ass”，引发ARM Linux社区的地震，随后ARM社区进行了一系列的重大修正。在过去的ARM Linux中，arch/arm/plat-xxx和arch/arm/mach-xxx中充斥着大量的垃圾代码，相当多数的代码只是在描述板级细节，而这些板级细节对于内核来讲，不过是垃圾，如板上的platform设备、resource、i2c_board_info、spi_board_info以及各种硬件的platform_data。 社区必须改变这种局面，于是PowerPC等其他体系架构下已经使用的Flattened Device Tree（FDT）进入ARM社区的视野。Device Tree是一种描述硬件的数据结构，它起源于OpenFirmware(OF)。在Linux2.6中，ARM架构的板极硬件细节过多地被硬编码在arch/arm/plat-xxx和arch/arm/mach-xxx，采用Device Tree后，许多硬件的细节可以直接透过它传递给Linux，而不再需要在kernel中进行大量的冗余编码。&lt;/p&gt;
&lt;p&gt;Device Tree由一系列被命名的结点（node）和属性（property）组成，而结点本身可包含子结点。所谓属性，其实就是成对出现的name和value。在Device Tree中，可描述的信息包括（原先这些信息大多被hard code到kernel中）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU的数量和类别&lt;/li&gt;
&lt;li&gt;内存基地址和大小&lt;/li&gt;
&lt;li&gt;总线和桥&lt;/li&gt;
&lt;li&gt;外设连接&lt;/li&gt;
&lt;li&gt;中断控制器和中断使用情况&lt;/li&gt;
&lt;li&gt;GPIO控制器和GPIO使用情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它基本上就是画一棵电路板上CPU、总线、设备组成的树，Bootloader会将这棵树传递给内核，然后内核可以识别这棵树，并根据它展开出Linux内核中的platform_device、i2c_client、spi_device等设备。这些设备用到的内存、IRQ等资源，也被传递给了kernel，kernel会将这些资源绑定给展开的相应的设备。&lt;/p&gt;
&lt;h1 id=&#34;2-device-tree编译&#34;&gt;2. Device Tree编译&lt;/h1&gt;
&lt;p&gt;Device Tree文件的格式为dts，包含的头文件格式为dtsi，dts文件是一种人可以看懂的编码格式。但是uboot和linux不能直接识别，他们只能识别二进制文件，所以需要把dts文件编译成dtb文件。dtb文件是一种可以被kernel和uboot识别的二进制文件。把dts编译成dtb文件的工具是dtc。Linux源码目录下scripts/dtc目录包含dtc工具的源码。在Linux的scripts/dtc目录下除了提供dtc工具外，也可以自己安装dtc工具，linux下执行：sudo apt-get install device-tree-compiler安装dtc工具。其中还提供了一个fdtdump的工具，可以反编译dtb文件。dts和dtb文件的转换如图1所示。&lt;/p&gt;
&lt;p&gt;dtc工具的使用方法是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dtc –I dts –O dtb –o xxx.dtb xxx.dts
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即可生成dts文件对应的dtb文件了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/%E7%BC%96%E8%AF%91.jpg&#34; alt=&#34;编译&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-device-tree头信息&#34;&gt;3. Device Tree头信息&lt;/h1&gt;
&lt;p&gt;fdtdump工具使用，Linux终端执行ftddump –h，输出以下信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;fdtdump -h
Usage: fdtdump [options]
Options: -[dshV]
-d, –debug Dump debug information while decoding the file
-s, –scan Scan for an embedded fdt in file
-h, –help Print this help and exit
-V, –version Print version and exit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本文采用s5pv21_smc.dtb文件为例说明fdtdump工具的使用。Linux终端执行fdtdump –sd s5pv21_smc.dtb &amp;gt; s5pv21_smc.txt，打开s5pv21_smc.txt文件，部分输出信息如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;// magic: 0xd00dfeed
// totalsize: 0xce4 (3300)
// off_dt_struct: 0x38
// off_dt_strings: 0xc34
// off_mem_rsvmap: 0x28
// version: 17
// last_comp_version: 16
// boot_cpuid_phys: 0x0
// size_dt_strings: 0xb0
// size_dt_struct: 0xbfc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上信息便是Device Tree文件头信息，存储在dtb文件的开头部分。&lt;/p&gt;
&lt;p&gt;在Linux内核中使用struct fdt_header结构体描述。struct fdt_header结构体定义在scripts\dtc\libfdt\fdt.h文件中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct fdt_header {
    fdt32_t magic;               /* magic word FDT_MAGIC */
    fdt32_t totalsize;           /* total size of DT block */
    fdt32_t off_dt_struct;       /* offset to structure */
    fdt32_t off_dt_strings;      /* offset to strings */
    fdt32_t off_mem_rsvmap;      /* offset to memory reserve map */
    fdt32_t version;                 /* format version */
    fdt32_t last_comp_version;   /* last compatible version */

    /* version 2 fields below */
    fdt32_t boot_cpuid_phys;     /* Which physical CPU id we&#39;re booting on */
    /* version 3 fields below */
    fdt32_t size_dt_strings;     /* size of the strings block */

    /* version 17 fields below */
    fdt32_t size_dt_struct;      /* size of the structure block */
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;fdtdump工具的输出信息即是以上结构中每一个成员的值，struct fdt_header结构体包含了Device Tree的私有信息。例如: fdt_header.magic是fdt的魔数,固定值为0xd00dfeed，fdt_header.totalsize是fdt文件的大小。使用二进制工具打开s5pv21_smc.dtb验证。s5pv21_smc.dtb二进制文件头信息如图2所示。从图2中可以得到Device Tree的文件是以大端模式储存。并且，头部信息和fdtdump的输出信息一致。&lt;/p&gt;
&lt;p&gt;Device Tree中的节点信息举例如下所示。
&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/node.png&#34; alt=&#34;编译&#34;&gt;&lt;/p&gt;
&lt;p&gt;上述.dts文件并没有什么真实的用途，但它基本表征了一个Device Tree源文件的结构。1个root结点”/”；root结点下面含一系列子结点，本例中为”node@0”和”node@1”；结点”node@0”下又含有一系列子结点，本例中为”child-node@0”；各结点都有一系列属性。这些属性可能为空，如” an-empty-property”；可能为字符串，如”a-string-property”；可能为字符串数组，如”a-string-list-property”；可能为Cells（由u32整数组成），如”second-child-property”，可能为二进制数，如”a-byte-data-property”。Device Tree源文件的结构分为header、fill_area、dt_struct及dt_string四个区域。header为头信息，fill_area为填充区域，填充数字0，dt_struct存储节点数值及名称相关信息，dt_string存储属性名。例如：a-string-property就存储在dt_string区，”A string”及node1就存储在dt_struct区域。
我们可以给一个设备节点添加lable，之后可以通过&amp;amp;lable的形式访问这个lable，这种引用是通过phandle（pointer handle）进行的。例如，图3中的node1就是一个lable，node@0的子节点child-node@0通过&amp;amp;node1引用node@1节点。像是这种phandle的节点，在经过DTC工具编译之后，&amp;amp;node1会变成一个特殊的整型数字n，假设n值为1，那么在node@1节点下自动生成两个属性，属性如下：
linux,phandle = &amp;lt;0x00000001&amp;gt;;
phandle = &amp;lt;0x00000001&amp;gt;;
node@0的子节点child-node@0中的a-reference-to-something = &amp;lt;&amp;amp;node1&amp;gt;会变成a-reference-to-something = &amp;lt; 0x00000001&amp;gt;。此处0x00000001就是一个phandle得值，每一个phandle都有一个独一无二的整型值，在后续kernel中通过这个特殊的数字间接找到引用的节点。通过查看fdtdump输出信息以及dtb二进制文件信息，得到struct fdt_header和文件结构之间的关系信息如所示。&lt;/p&gt;
&lt;h1 id=&#34;4-dtb文件结构&#34;&gt;4. DTB文件结构&lt;/h1&gt;
&lt;p&gt;通过以上分析，可以得到Device Tree文件结构如图5所示。dtb的头部首先存放的是fdt_header的结构体信息，接着是填充区域，填充大小为off_dt_struct – sizeof(struct fdt_header)，填充的值为0。接着就是struct fdt_property结构体的相关信息。最后是dt_string部分。
&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/DTB.png&#34; alt=&#34;编译&#34;&gt;&lt;/p&gt;
&lt;p&gt;Device Tree源文件的结构分为header、fill_area、dt_struct及dt_string四个区域。fill_area区域填充数值0。节点（node）信息使用struct fdt_node_header结构体描述。属性信息使用struct fdt_property结构体描述。各个结构体信息如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct fdt_node_header {
    fdt32_t tag;
    char name[0];
};

struct fdt_property {
    fdt32_t tag;
    fdt32_t len;
    fdt32_t nameoff;
    char data[0];
};

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;struct fdt_node_header描述节点信息，tag是标识node的起始结束等信息的标志位，name指向node名称的首地址。tag的取值如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define FDT_BEGIN_NODE  0x1     /* Start node: full name */
#define FDT_END_NODE    0x2     /* End node */
#define FDT_PROP        0x3     /* Property: name off, size, content */
#define FDT_NOP         0x4     /* nop */
#define FDT_END         0x9

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;FDT_BEGIN_NODE和FDT_END_NODE标识node节点的起始和结束，FDT_PROP标识node节点下面的属性起始符，FDT_END标识Device Tree的结束标识符。因此，对于每个node节点的tag标识符一般为FDT_BEGIN_NODE，对于每个node节点下面的属性的tag标识符一般是FDT_PROP。&lt;/p&gt;
&lt;p&gt;描述属性采用struct fdt_property描述，tag标识是属性，取值为FDT_PROP；len为属性值的长度（包括‘\0’，单位：字节）；nameoff为属性名称存储位置相对于off_dt_strings的偏移地址。&lt;/p&gt;
&lt;p&gt;例如：compatible = “samsung,goni”, “samsung,s5pv210”;compatible是属性名称，”samsung,goni”, “samsung,s5pv210”是属性值。compatible属性名称字符串存放的区域是dt_string。”samsung,goni”, “samsung,s5pv210”存放的位置是fdt_property.data后面。因此fdt_property.data指向该属性值。fdt_property.tag的值为属性标识，len为属性值的长度（包括‘\0’，单位：字节）,此处len = 29。nameoff为compatible字符串的位置相对于off_dt_strings的偏移地址，即&amp;amp;compatible = nameoff + off_dt_strings。&lt;/p&gt;
&lt;p&gt;dt_struct在Device Tree中的结构如图6所示。节点的嵌套也带来tag标识符的嵌套。
&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/dt_struct.png&#34; alt=&#34;编译&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;5-kernel解析device-tree&#34;&gt;5. kernel解析Device Tree&lt;/h1&gt;
&lt;p&gt;Device Tree文件结构描述就以上struct fdt_header、struct fdt_node_header及struct fdt_property三个结构体描述。kernel会根据Device Tree的结构解析出kernel能够使用的struct property结构体。kernel根据Device Tree中所有的属性解析出数据填充struct property结构体。struct property结构体描述如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct property {
    char *name;                          /* property full name */
    int length;                          /* property value length */
    void *value;                         /* property value */
    struct property *next;             /* next property under the same node */
    unsigned long _flags;
    unsigned int unique_id;
    struct bin_attribute attr;        /* 属性文件，与sysfs文件系统挂接 */
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总的来说，kernel根据Device Tree的文件结构信息转换成struct property结构体，并将同一个node节点下面的所有属性通过property.next指针进行链接，形成一个单链表。
kernel中究竟是如何解析Device Tree的呢？下面分析函数解析过程。函数调用过程如图7所示。kernel的C语言阶段的入口函数是init/main.c/stsrt_kernel()函数，在early_init_dt_scan_nodes()中会做以下三件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;扫描/chosen或者/chose@0节点下面的bootargs属性值到boot_command_line，此外，还处理initrd相关的property，并保存在initrd_start和initrd_end这两个全局变量中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;扫描根节点下面，获取{size,address}-cells信息，并保存在dt_root_size_cells和dt_root_addr_cells全局变量中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;扫描具有device_type =“memory”属性的/memory或者/memory@0节点下面的reg属性值，并把相关信息保存在meminfo中，全局变量meminfo保存了系统内存相关的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB1.png&#34; alt=&#34;编译&#34;&gt;&lt;/p&gt;
&lt;p&gt;Device Tree中的每一个node节点经过kernel处理都会生成一个struct device_node的结构体，struct device_node最终一般会被挂接到具体的struct device结构体。struct device_node结构体描述如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct device_node {
    const char *name;              /* node的名称，取最后一次“/”和“@”之间子串 */
    const char *type;              /* device_type的属性名称，没有为&amp;lt;NULL&amp;gt; */
    phandle phandle;               /* phandle属性值 */
    const char *full_name;         /* 指向该结构体结束的位置，存放node的路径全名，例如：/chosen */
    struct fwnode_handle fwnode;

    struct  property *properties;  /* 指向该节点下的第一个属性，其他属性与该属性链表相接 */
    struct  property *deadprops;   /* removed properties */
    struct  device_node *parent;   /* 父节点 */
    struct  device_node *child;    /* 子节点 */
    struct  device_node *sibling;  /* 姊妹节点，与自己同等级的node */
    struct  kobject kobj;          /* sysfs文件系统目录体现 */
    unsigned long _flags;          /* 当前node状态标志位，见/include/linux/of.h line124-127 */
    void    *data;
};

/* flag descriptions (need to be visible even when !CONFIG_OF) */
#define OF_DYNAMIC        1 /* node and properties were allocated via kmalloc */
#define OF_DETACHED       2 /* node has been detached from the device tree*/
#define OF_POPULATED      3 /* device already created for the node */
#define OF_POPULATED_BUS  4 /* of_platform_populate recursed to children of this node */

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;struct device_node结构体中的每个成员作用已经备注了注释信息，下面分析以上信息是如何得来的。&lt;/p&gt;
&lt;p&gt;Device Tree的解析首先从unflatten_device_tree()开始，代码列出如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/**
 * unflatten_device_tree - create tree of device_nodes from flat blob
 *
 * unflattens the device-tree passed by the firmware, creating the
 * tree of struct device_node. It also fills the &amp;quot;name&amp;quot; and &amp;quot;type&amp;quot;
 * pointers of the nodes so the normal device-tree walking functions
 * can be used.
 */
void __init unflatten_device_tree(void)
{
	__unflatten_device_tree(initial_boot_params, NULL, &amp;amp;of_root,
				early_init_dt_alloc_memory_arch, false);

	/* Get pointer to &amp;quot;/chosen&amp;quot; and &amp;quot;/aliases&amp;quot; nodes for use everywhere */
	of_alias_scan(early_init_dt_alloc_memory_arch);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析以上代码，在unflatten_device_tree()中，调用函数__unflatten_device_tree()，参数initial_boot_params指向Device Tree在内存中的首地址，of_root在经过该函数处理之后，会指向根节点，early_init_dt_alloc_memory_arch是一个函数指针，为struct device_node和struct property结构体分配内存的回调函数（callback）。&lt;/p&gt;
&lt;p&gt;在__unflatten_device_tree()函数中，两次调用unflatten_dt_node()函数，第一次是为了得到Device Tree转换成struct device_node和struct property结构体需要分配的内存大小，第二次调用才是具体填充每一个struct device_node和struct property结构体。__unflatten_device_tree()代码列出如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
/**
 * __unflatten_device_tree - create tree of device_nodes from flat blob
 *
 * unflattens a device-tree, creating the
 * tree of struct device_node. It also fills the &amp;quot;name&amp;quot; and &amp;quot;type&amp;quot;
 * pointers of the nodes so the normal device-tree walking functions
 * can be used.
 * @blob: The blob to expand
 * @dad: Parent device node
 * @mynodes: The device_node tree created by the call
 * @dt_alloc: An allocator that provides a virtual address to memory
 * for the resulting tree
 *
 * Returns NULL on failure or the memory chunk containing the unflattened
 * device tree on success.
 */
static void *__unflatten_device_tree(const void *blob,
				     struct device_node *dad,
				     struct device_node **mynodes,
				     void *(*dt_alloc)(u64 size, u64 align),
				     bool detached)
{
	int size;
	void *mem;

	pr_debug(&amp;quot; -&amp;gt; unflatten_device_tree()\n&amp;quot;);

	if (!blob) {
		pr_debug(&amp;quot;No device tree pointer\n&amp;quot;);
		return NULL;
	}

	pr_debug(&amp;quot;Unflattening device tree:\n&amp;quot;);
	pr_debug(&amp;quot;magic: %08x\n&amp;quot;, fdt_magic(blob));
	pr_debug(&amp;quot;size: %08x\n&amp;quot;, fdt_totalsize(blob));
	pr_debug(&amp;quot;version: %08x\n&amp;quot;, fdt_version(blob));

	if (fdt_check_header(blob)) {
		pr_err(&amp;quot;Invalid device tree blob header\n&amp;quot;);
		return NULL;
	}

	/* First pass, scan for size */
	size = unflatten_dt_nodes(blob, NULL, dad, NULL);
	if (size &amp;lt; 0)
		return NULL;

	size = ALIGN(size, 4);
	pr_debug(&amp;quot;  size is %d, allocating...\n&amp;quot;, size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	if (!mem)
		return NULL;

	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);

	pr_debug(&amp;quot;  unflattening %p...\n&amp;quot;, mem);

	/* Second pass, do actual unflattening */
	unflatten_dt_nodes(blob, mem, dad, mynodes);
	if (be32_to_cpup(mem + size) != 0xdeadbeef)
		pr_warning(&amp;quot;End of tree marker overwritten: %08x\n&amp;quot;,
			   be32_to_cpup(mem + size));

	if (detached &amp;amp;&amp;amp; mynodes) {
		of_node_set_flag(*mynodes, OF_DETACHED);
		pr_debug(&amp;quot;unflattened tree is detached\n&amp;quot;);
	}

	pr_debug(&amp;quot; &amp;lt;- unflatten_device_tree()\n&amp;quot;);
	return mem;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;__unflatten_device_tree()代码列出如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
/**
 * unflatten_dt_nodes - Alloc and populate a device_node from the flat tree
 * @blob: The parent device tree blob
 * @mem: Memory chunk to use for allocating device nodes and properties
 * @dad: Parent struct device_node
 * @nodepp: The device_node tree created by the call
 *
 * It returns the size of unflattened device tree or error code
 */
static int unflatten_dt_nodes(const void *blob,
			      void *mem,
			      struct device_node *dad,
			      struct device_node **nodepp)
{
	struct device_node *root;
	int offset = 0, depth = 0, initial_depth = 0;
#define FDT_MAX_DEPTH	64
	unsigned int fpsizes[FDT_MAX_DEPTH];
	struct device_node *nps[FDT_MAX_DEPTH];
	void *base = mem;
	bool dryrun = !base;

	if (nodepp)
		*nodepp = NULL;

	/*
	 * We&#39;re unflattening device sub-tree if @dad is valid. There are
	 * possibly multiple nodes in the first level of depth. We need
	 * set @depth to 1 to make fdt_next_node() happy as it bails
	 * immediately when negative @depth is found. Otherwise, the device
	 * nodes except the first one won&#39;t be unflattened successfully.
	 */
	if (dad)
		depth = initial_depth = 1;

	root = dad;
	fpsizes[depth] = dad ? strlen(of_node_full_name(dad)) : 0;
	nps[depth] = dad;

	for (offset = 0;
	     offset &amp;gt;= 0 &amp;amp;&amp;amp; depth &amp;gt;= initial_depth;
	     offset = fdt_next_node(blob, offset, &amp;amp;depth)) {
		if (WARN_ON_ONCE(depth &amp;gt;= FDT_MAX_DEPTH))
			continue;

		fpsizes[depth+1] = populate_node(blob, offset, &amp;amp;mem,
						 nps[depth],
						 fpsizes[depth],
						 &amp;amp;nps[depth+1], dryrun);
		if (!fpsizes[depth+1])
			return mem - base;

		if (!dryrun &amp;amp;&amp;amp; nodepp &amp;amp;&amp;amp; !*nodepp)
			*nodepp = nps[depth+1];
		if (!dryrun &amp;amp;&amp;amp; !root)
			root = nps[depth+1];
	}

	if (offset &amp;lt; 0 &amp;amp;&amp;amp; offset != -FDT_ERR_NOTFOUND) {
		pr_err(&amp;quot;Error %d processing FDT\n&amp;quot;, offset);
		return -EINVAL;
	}

	/*
	 * Reverse the child list. Some drivers assumes node order matches .dts
	 * node order
	 */
	if (!dryrun)
		reverse_nodes(root);

	return mem - base;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过以上函数处理就得到了所有的struct device_node结构体，为每一个node都会自动添加一个名称为“name”的property，property.length的值为当前node的名称取最后一个“/”和“@”之间的子串（包括‘\0’）。例如：/serial@e2900800，则length = 7，property.value = device_node.name = “serial”。&lt;/p&gt;
&lt;h1 id=&#34;6-platform_device和device_node绑定&#34;&gt;6. platform_device和device_node绑定&lt;/h1&gt;
&lt;p&gt;经过以上解析，Device Tree的数据已经全部解析出具体的struct device_node和struct property结构体，下面需要和具体的device进行绑定。首先讲解platform_device和device_node的绑定过程。在arch/arm/kernel/setup.c文件中，customize_machine()函数负责填充struct platform_device结构体。函数调用过程如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/%E7%BB%91%E5%AE%9A.png&#34; alt=&#34;编译&#34;&gt;&lt;/p&gt;
&lt;p&gt;代码分析如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
const struct of_device_id of_default_bus_match_table[] = {
    { .compatible = &amp;quot;simple-bus&amp;quot;, },
    { .compatible = &amp;quot;simple-mfd&amp;quot;, },
#ifdef CONFIG_ARM_AMBA
    { .compatible = &amp;quot;arm,amba-bus&amp;quot;, },
#endif /* CONFIG_ARM_AMBA */
    {} /* Empty terminated list */
};

int of_platform_populate(struct device_node *root,
            const struct of_device_id *matches,
            const struct of_dev_auxdata *lookup,
            struct device *parent)
{
    struct device_node *child;
    int rc = 0;

    /* 获取根节点 */
    root = root ? of_node_get(root) : of_find_node_by_path(&amp;quot;/&amp;quot;);
    if (!root)
        return -EINVAL;

    /* 为根节点下面的每一个节点创建platform_device结构体 */
    for_each_child_of_node(root, child) {
        rc = of_platform_bus_create(child, matches, lookup, parent, true);
        if (rc) {
            of_node_put(child);
            break;
        }
    }
    /* 更新device_node flag标志位 */
    of_node_set_flag(root, OF_POPULATED_BUS);

    of_node_put(root);
    return rc;
}

static int of_platform_bus_create(struct device_node *bus,
                  const struct of_device_id *matches,
                  const struct of_dev_auxdata *lookup,
                  struct device *parent, bool strict)
{
    const struct of_dev_auxdata *auxdata;
    struct device_node *child;
    struct platform_device *dev;
    const char *bus_id = NULL;
    void *platform_data = NULL;
    int rc = 0;

    /* 只有包含&amp;quot;compatible&amp;quot;属性的node节点才会生成相应的platform_device结构体 */
    /* Make sure it has a compatible property */
    if (strict &amp;amp;&amp;amp; (!of_get_property(bus, &amp;quot;compatible&amp;quot;, NULL))) {
        return 0;
    }
    /* 省略部分代码 */
    /* 
     * 针对节点下面得到status = &amp;quot;ok&amp;quot; 或者status = &amp;quot;okay&amp;quot;或者不存在status属性的
     * 节点分配内存并填充platform_device结构体
     */
    dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent);
    if (!dev || !of_match_node(matches, bus))
        return 0;

    /* 递归调用节点解析函数，为子节点继续生成platform_device结构体，前提是父节点
     * 的“compatible” = “simple-bus”，也就是匹配of_default_bus_match_table结构体中的数据
     */
    for_each_child_of_node(bus, child) {
        rc = of_platform_bus_create(child, matches, lookup, &amp;amp;dev-&amp;gt;dev, strict);
        if (rc) {
            of_node_put(child);
            break;
        }
    }
    of_node_set_flag(bus, OF_POPULATED_BUS);
    return rc;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总的来说，当of_platform_populate()函数执行完毕:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;kernel就为DTB中所有包含compatible属性名的第一级node创建platform_device结构体，并向平台设备总线注册设备信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果第一级node的compatible属性值等于“simple-bus”、“simple-mfd”或者”arm,amba-bus”的话，kernel会继续为当前node的第二级包含compatible属性的node创建platform_device结构体，并注册设备。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linux系统下的设备大多都是挂载在平台总线下的，因此在平台总线被注册后，会根据of_root节点的树结构，去寻找该总线的子节点，所有的子节点将被作为设备注册到该总线上。&lt;/p&gt;
&lt;h1 id=&#34;7-i2c_client和device_node绑定&#34;&gt;7. i2c_client和device_node绑定&lt;/h1&gt;
&lt;p&gt;经过customize_machine()函数的初始化，DTB已经转换成platform_device结构体，这其中就包含i2c adapter设备，不同的SoC需要通过平台设备总线的方式自己实现i2c adapter设备的驱动。例如：i2c_adapter驱动的probe函数中会调用i2c_add_numbered_adapter()注册adapter驱动，函数流执行如图9所示。
&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/i2c.png&#34; alt=&#34;编译&#34;&gt;
在of_i2c_register_devices()函数内部便利i2c节点下面的每一个子节点，并为子节点（status = “disable”的除外）创建i2c_client结构体，并与子节点的device_node挂接。其中i2c_client的填充是在i2c_new_device()中进行的，最后device_register()。在构建i2c_client的时候，会对node下面的compatible属性名称的厂商名字去除作为i2c_client的name。例如：compatible = “maxim,ds1338”,则i2c_client-&amp;gt;name = “ds1338”。&lt;/p&gt;
&lt;h1 id=&#34;8-device_tree与sysfs&#34;&gt;8. Device_Tree与sysfs&lt;/h1&gt;
&lt;p&gt;kernel启动流程为start_kernel()→rest_init()→kernel_thread():kernel_init()→do_basic_setup()→driver_init()→of_core_init()，在of_core_init()函数中在sys/firmware/devicetree/base目录下面为设备树展开成sysfs的目录和二进制属性文件，所有的node节点就是一个目录，所有的property属性就是一个二进制属性文件。&lt;/p&gt;
&lt;h1 id=&#34;9-特此感谢&#34;&gt;9. 特此感谢&lt;/h1&gt;
&lt;p&gt;感谢原创作者的文章，文章图片表达清晰，代码注释详细，对我帮助很大。
————————————————
版权声明：本文为CSDN博主「smcdef」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/smcdef/article/details/77387975&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Static的作用</title>
      <link>https://strivefar.github.io/project/post/static%E7%9A%84%E4%BD%9C%E7%94%A8/</link>
      <pubDate>Sun, 12 Jul 2020 13:05:52 +0800</pubDate>
      <guid>https://strivefar.github.io/project/post/static%E7%9A%84%E4%BD%9C%E7%94%A8/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E5%89%8D%E8%A8%80&#34;&gt;1. 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E5%85%B3%E9%94%AE%E8%AF%8D%E8%A7%A3%E9%87%8A&#34;&gt;2. 关键词解释：&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-%E5%8F%98%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F&#34;&gt;2.1. 变量的存储方式&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#211-%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%8F%98%E9%87%8F&#34;&gt;2.1.1. 静态存储变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#212-%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8%E5%8F%98%E9%87%8F&#34;&gt;2.1.2. 动态存储变量&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-%E7%94%9F%E5%AD%98%E6%9C%9F%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;2.2. 生存期的区别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-static-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E6%99%AE%E9%80%9A%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB-&#34;&gt;3. static 全局变量与普通全局变量的区别 ？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-static%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E6%99%AE%E9%80%9A%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-&#34;&gt;4. static局部变量和普通局部变量有什么区别 ？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-static%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB&#34;&gt;5. static函数与普通函数有什么区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-%E5%B7%A7%E7%94%A8static%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%BA0&#34;&gt;6. 巧用static,默认初始化为0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-%E6%80%BB%E7%BB%93static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8&#34;&gt;7. 总结：static关键字的作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8-%E5%8F%82%E8%80%83%E6%9D%A5%E6%BA%90&#34;&gt;8. 参考来源：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;1-前言&#34;&gt;1. 前言&lt;/h1&gt;
&lt;p&gt;Linux内核源码中使用的大量的static关键字来修饰变量和函数，有效的防止了不同文件间的相同变量或函数名引起的冲突，关于static的作用，现解释如下，如有问题，欢迎批评指正。&lt;/p&gt;
&lt;h1 id=&#34;2-关键词解释&#34;&gt;2. 关键词解释：&lt;/h1&gt;
&lt;h2 id=&#34;21-变量的存储方式&#34;&gt;2.1. 变量的存储方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可分为：“静态存储”和“动态存储”两种。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;211-静态存储变量&#34;&gt;2.1.1. 静态存储变量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;通常是在变量定义时就分定存储单元并一直保持不变，直至整个程序结束，即在程序运行期间分配固定的存储空间。
全局变量即属于此类存储方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;212-动态存储变量&#34;&gt;2.1.2. 动态存储变量&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在程序执行过程中，使用它时才分配存储单元，使用完毕立即释放。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;典型的例子是函数的形式参数，在函数定义时并不给行参分配存储单元，只是在函数被调用时，才予以分配，调用函数完毕立即释放。
如果一个函数被多次调用时，则反复地分配、释放形参变量的存储单元。&lt;/p&gt;
&lt;h2 id=&#34;22-生存期的区别&#34;&gt;2.2. 生存期的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;静态存储变量是&lt;strong&gt;一直存在&lt;/strong&gt;的，而动态存储变量则&lt;strong&gt;时而存在时而消失&lt;/strong&gt;。通常把由于变量存储方式不同而产生的特性称为变量的&lt;strong&gt;生存期&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;3-static-全局变量与普通全局变量的区别-&#34;&gt;3. static 全局变量与普通全局变量的区别 ？&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;普通全局变量加上static修饰后就变成了static全局变量&lt;/li&gt;
&lt;li&gt;二者都是存储在静态变量区，即以静态存储方式进行存储，&lt;/li&gt;
&lt;li&gt;区别：全局变量加上static之后就被限制了可见范围&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;未加static之前，全局变量在所有的源程序都可见，只要加上extern即可使用其他文件中定义的全局变量；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;加上static之后，变为了静态全局变量，静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，&lt;strong&gt;因此可以避免在其它源文件中引起错误&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;4-static局部变量和普通局部变量有什么区别-&#34;&gt;4. static局部变量和普通局部变量有什么区别 ？&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;保持变量内容的持久，存储在静态数据区的变量会在程序编译时分配固定的存储空间，程序刚开始运行时就完成初始化，也是唯一的一次初始化。
举例如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int fun(void)
{
  /*static局部变量只被初始化一次，下一次使用时在上一次结果值的基础上进行改变*/
    static int count = 10;    
    return count--;
}

int count = 1;

int main(void)
{    
    printf(&amp;quot;global\t\tlocal static\n&amp;quot;);
    for(; count &amp;lt;= 10; ++count)
        printf(&amp;quot;%d\t\t%d\n&amp;quot;, count, fun());    
    
    return 0;
}


程序的运行结果是：

global          local static

1               10

2               9

3               8

4               7

5               6

6               5

7               4

8               3

9               2

10              1
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5-static函数与普通函数有什么区别&#34;&gt;5. static函数与普通函数有什么区别？&lt;/h1&gt;
&lt;p&gt;这有些类似于static 全局变量与普通全局变量的区别，同样的，static函数仅对定义该函数的当前文件可见，无法像普通函数一样加上extern声明就能在其他文件中使用。&lt;/p&gt;
&lt;p&gt;也就是说static修饰后成为了内部函数，应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件.&lt;/p&gt;
&lt;h1 id=&#34;6-巧用static默认初始化为0&#34;&gt;6. 巧用static,默认初始化为0&lt;/h1&gt;
&lt;p&gt;static的第三个作用是默认初始化为0。其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加&amp;rsquo;\ 0&#39;太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是&amp;rsquo;\0&amp;rsquo;。不妨做个小实验验证一下。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
int a;

int main(void)
{
    int i;
    static char str[10];

    printf(&amp;quot;integer: %d;  string: (begin)%s(end)&amp;quot;, a, str);

    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;integer: 0; string: (begin)(end)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;7-总结static关键字的作用&#34;&gt;7. 总结：static关键字的作用&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1.隐藏（限制作用域）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2.保持变量内容的持久&lt;/strong&gt;（静态局部变量）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3.默认初始化为0&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;8-参考来源&#34;&gt;8. 参考来源：&lt;/h1&gt;
&lt;p&gt;特此感谢：
&lt;a href=&#34;https://blog.csdn.net/tr_ainiyangyang/article/details/80965574&#34;&gt;https://blog.csdn.net/tr_ainiyangyang/article/details/80965574&lt;/a&gt;
&lt;a href=&#34;https://blog.csdn.net/qq_37858386/article/details/79064900&#34;&gt;https://blog.csdn.net/qq_37858386/article/details/79064900&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux 设备驱动开发————设备树应用实例（imx6ull）</title>
      <link>https://strivefar.github.io/project/post/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Mon, 06 Jul 2020 12:01:03 +0800</pubDate>
      <guid>https://strivefar.github.io/project/post/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%AD%E6%B3%95/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E6%9D%BF%E5%AD%90%E5%90%AF%E5%8A%A8%E5%90%8E%E6%9F%A5%E7%9C%8B%E8%AE%BE%E5%A4%87%E6%A0%91&#34;&gt;1. 板子启动后查看设备树&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E&#34;&gt;1.1. 文件说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E7%BC%96%E8%AF%91%E5%8F%8D%E7%BC%96%E8%AF%91-%E8%AE%BE%E5%A4%87%E6%A0%91%E6%96%87%E4%BB%B6&#34;&gt;2. 编译/反编译 设备树文件&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91&#34;&gt;2.1. 手动编译&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-%E5%9C%A8%E5%86%85%E6%A0%B8%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8B%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91&#34;&gt;2.2. 在内核根目录下自动编译&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#221-%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90&#34;&gt;2.2.1. 过程解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-led%E9%A9%B1%E5%8A%A8%E6%A8%A1%E6%9D%BF%E8%AE%BE%E5%A4%87%E6%A0%91%E6%94%B9%E9%80%A0&#34;&gt;3. led驱动模板——设备树改造&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#31-%E7%BB%99%E5%BC%80%E5%8F%91%E6%9D%BF%E6%9B%B4%E6%8D%A2%E8%AE%BE%E5%A4%87%E6%A0%91%E6%96%87%E4%BB%B6&#34;&gt;3.1. 给开发板更换设备树文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32-%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%94%B9%E9%80%A0&#34;&gt;3.2. 内核驱动程序的改造&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#321-platform_device%E5%8C%85%E5%90%AB%E6%9D%A5%E8%87%AA%E8%AE%BE%E5%A4%87%E6%A0%91%E7%9A%84-%E5%A6%82%E4%BD%95%E4%B8%8E-platform_driver-%E9%85%8D%E5%AF%B9&#34;&gt;3.2.1. platform_device（包含来自设备树的） 如何与 platform_driver 配对:&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#3211-%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E4%BF%A1%E6%81%AF%E6%9D%A5%E5%88%A4%E6%96%AD-dev-%E5%92%8C-drv-%E6%98%AF%E5%90%A6%E9%85%8D%E5%AF%B9%E6%97%B6&#34;&gt;3.2.1.1. 使用设备树信息来判断 dev 和 drv 是否配对时&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#33-%E6%8C%89%E7%85%A7%E8%BF%99%E7%A7%8D%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB%E4%BB%A3%E7%A0%81%E6%94%B9%E9%80%A0%E5%A6%82%E4%B8%8B&#34;&gt;3.3. 按照这种转换关系，代码改造如下&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#34-%E5%8C%B9%E9%85%8D%E6%88%90%E5%8A%9F%E5%90%8E%E4%BC%9A%E8%B0%83%E7%94%A8chip_demo_gpio_probe-%E6%B3%A8%E5%86%8C%E5%88%86%E9%85%8D%E7%9A%84%E5%90%84%E7%A7%8D%E8%B5%84%E6%BA%90&#34;&gt;3.4. 匹配成功后，会调用chip_demo_gpio_probe 注册分配的各种资源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#35-%E6%B3%A8%E9%94%80%E5%88%86%E9%85%8D%E7%9A%84%E5%90%84%E7%A7%8D%E8%B5%84%E6%BA%90&#34;&gt;3.5. 注销分配的各种资源：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#36-%E7%84%B6%E5%90%8E%E6%98%AF%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%8D%B8%E8%BD%BD%E5%87%BD%E6%95%B0&#34;&gt;3.6. 然后是模块加载和卸载函数：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#37-%E8%BF%9B%E5%85%A5%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84mnt%E7%9B%AE%E5%BD%95%E4%B8%8B&#34;&gt;3.7. 进入开发板的/mnt目录下&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#38-%E5%B0%86leddrvko-%E5%92%8C-chip_demo_gpioko-%E6%B3%A8%E5%86%8C%E8%BF%9B%E5%86%85%E6%A0%B8&#34;&gt;3.8. 将leddrv.ko 和 chip_demo_gpio.ko 注册进内核&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#39-%E6%89%A7%E8%A1%8C%E4%B8%80%E4%B8%8B%E5%91%BD%E4%BB%A4%E6%9D%A5%E8%BF%9B%E8%A1%8C%E7%82%B9%E7%81%AF%E7%9A%84%E6%93%8D%E4%BD%9C&#34;&gt;3.9. 执行一下命令来进行点灯的操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#310-%E5%89%8D%E5%90%8E%E5%AF%B9%E6%AF%94%E8%A7%82%E5%AF%9F%E4%B8%80%E4%B8%8B%E8%BD%AC%E5%8C%96%E5%85%B3%E7%B3%BB&#34;&gt;3.10. 前后对比，观察一下转化关系&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E5%8F%82%E8%80%83%E6%9D%A5%E6%BA%90&#34;&gt;4. 参考来源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-%E7%A8%8B%E5%BA%8F&#34;&gt;5. 程序&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;1-板子启动后查看设备树&#34;&gt;1. 板子启动后查看设备树&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;注意：开发板中仅存放dtb 二进制文件，所以想直接查看开发板中的dts文件是查看不到的，需要先通过网络文件系统将开发板中dtb 二进制文件的copy到虚拟机，在虚拟机中反编译得到dts文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;板子启动后执行下面的命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ls /sys/firmware/
devicetree fdt
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;11-文件说明&#34;&gt;1.1. 文件说明&lt;/h2&gt;
&lt;p&gt;/sys/firmware/devicetree 目录下是以目录结构程现的 dtb 文件, 根结点对应 base 目录, 每一个结点对应一个目录, 每一个属性对应一个文件。&lt;/p&gt;
&lt;p&gt;这些属性的值如果是字符串，可以使用 cat 命令把它打印出来；对于数值可以用 hexdump 把它打印出来。&lt;/p&gt;
&lt;p&gt;还可以看到/sys/firmware/fdt 文件，它就是 dtb 格式的设备树文件，可以把它复制出来放到 ubuntu上，执行下面的命令反编译出来(-I dtb：输入格式是 dtb，-O dts：输出格式是 dts)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd 板子所用的内核源码目录

./scripts/dtc/dtc -I dtb -O dts /从板子上/复制出来的/fdt -o tmp.dts
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2-编译反编译-设备树文件&#34;&gt;2. 编译/反编译 设备树文件&lt;/h1&gt;
&lt;h2 id=&#34;21-手动编译&#34;&gt;2.1. 手动编译&lt;/h2&gt;
&lt;p&gt;内核目录下 scripts/dtc/dtc 是设备树的编译工具，直接使用它的话，包含其他文件时不能使用
“#include”，而必须使用“/incldue”。&lt;/p&gt;
&lt;p&gt;编译、反编译的示例命令如下，“-I”指定输入格式，“-O”指定输出格式，“-o”指定输出文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./scripts/dtc/dtc -I dts -O dtb -o tmp.dtb arch/arm/boot/dts/xxx.dts // 编译 dts 为 dtb
./scripts/dtc/dtc -I dtb -O dts -o tmp.dts arch/arm/boot/dts/xxx.dtb // 反编译 dtb 为 dts
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;22-在内核根目录下自动编译&#34;&gt;2.2. 在内核根目录下自动编译&lt;/h2&gt;
&lt;p&gt;V=1 察看编译过程,不关心过程省略即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make dtbs V=1

mkdir -p arch/arm/boot/dts/ ; 
arm-linux-gnueabihf-gcc -E 
 -Wp,-MD,arch/arm/boot/dts/.imx6ull-14x14-ebf-mini.dtb.d.pre.tmp 
 -nostdinc 
 -I./arch/arm/boot/dts 
 -I./arch/arm/boot/dts/include 
 -I./drivers/of/testcase-data 
 -undef -D__DTS__ -x assembler-with-cpp 
 -o arch/arm/boot/dts/.imx6ull-14x14-ebf-mini.dtb.dts.tmp 
 arch/arm/boot/dts/imx6ull-14x14-ebf-mini.dts ; 
 
./scripts/dtc/dtc -O dtb 
 -o arch/arm/boot/dts/imx6ull-14x14-ebf-mini.dtb
 -b 0 -i arch/arm/boot/dts/ -Wno-unit_address_vs_reg 
 -d arch/arm/boot/dts/.imx6ull-14x14-ebf-mini.dtb.d.dtc.tmp 
 arch/arm/boot/dts/.imx6ull-14x14-ebf-mini.dtb.dts.tmp ;

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;221-过程解析&#34;&gt;2.2.1. 过程解析&lt;/h3&gt;
&lt;p&gt;它首先用 arm-linux-gnueabihf-gcc 预处理 dts 文件，把其中的.h 头文件包含进来，把宏展开。&lt;/p&gt;
&lt;p&gt;然后使用 scripts/dtc/dtc 生成 dtb 文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;可见，dts 文件之所以支持“#include”语法，是因为 arm-linux-gnueabihf-gcc 帮忙。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果只用 dtc 工具，它是不支持”#include”语法的，只支持“/include”语法。&lt;/p&gt;
&lt;h1 id=&#34;3-led驱动模板设备树改造&#34;&gt;3. led驱动模板——设备树改造&lt;/h1&gt;
&lt;h2 id=&#34;31-给开发板更换设备树文件&#34;&gt;3.1. 给开发板更换设备树文件&lt;/h2&gt;
&lt;p&gt;imx6ull 单板
设备树文件是：内核源码目录中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/home/book/100ask_imx6ull-sdk/Linux-4.9.88
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其在内核源码目录中的路径为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arch/arm/boot/dts/100ask_imx6ull-14x14.dts
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要更换板子上的设备树文件，启动板子后，更换这个文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/boot/100ask_imx6ull-14x14.dtb
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;远程登录Linux服务器后：先搜索dts文件&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;book@100ask:~/100ask_imx6ull-sdk/Linux-4.9.88/arch/arm/boot/dts$ find -name 100ask_imx6ull-14x14.dts
./100ask_imx6ull-14x14.dts
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;然后打开后添加node（子结点）：
在根结点下添加100ask_led@0和100ask_led@1这两个子结点（由于dts篇幅较长，这里仅展示一部分）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;/dts-v1/;

#include &amp;lt;dt-bindings/input/input.h&amp;gt;
#include &amp;quot;imx6ull.dtsi&amp;quot;
#define GROUP_PIN(g,p) ((g&amp;lt;&amp;lt;16) | (p))

/ {
    model = &amp;quot;Freescale i.MX6 ULL 14x14 EVK Board&amp;quot;;
    compatible = &amp;quot;fsl,imx6ull-14x14-evk&amp;quot;, &amp;quot;fsl,imx6ull&amp;quot;;

    chosen {
        stdout-path = &amp;amp;uart1;
    };

    memory {
        reg = &amp;lt;0x80000000 0x20000000&amp;gt;;
    };

    reserved-memory {
        #address-cells = &amp;lt;1&amp;gt;;
        #size-cells = &amp;lt;1&amp;gt;;
        ranges;

        linux,cma {
            compatible = &amp;quot;shared-dma-pool&amp;quot;;
            reusable;
            size = &amp;lt;0x14000000&amp;gt;;
            linux,cma-default;
        };
    };

    100ask_led@0 {
        compatible = &amp;quot;100as,leddrv&amp;quot;;
        pin = &amp;lt;GROUP_PIN(5,3)&amp;gt;;
    };

    100ask_led@1 {
        compatible = &amp;quot;100as,leddrv&amp;quot;;
        pin = &amp;lt;GROUP_PIN(5,8)&amp;gt;;
    };
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;在内核源码目录中执行&lt;strong&gt;make dtbs&lt;/strong&gt;编译dts得到dtb文件：&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;book@100ask:~/100ask_imx6ull-sdk/Linux-4.9.88/arch/arm/boot/dts$ cd /home/book/100ask_imx6ull-sdk/Linux-4.9.88
book@100ask:~/100ask_imx6ull-sdk/Linux-4.9.88$ make dtbs
  CHK     include/config/kernel.release
  CHK     include/generated/uapi/linux/version.h
  CHK     include/generated/utsrelease.h
  CHK     include/generated/bounds.h
  CHK     include/generated/timeconst.h
  CHK     include/generated/asm-offsets.h
  CALL    scripts/checksyscalls.sh
  DTC     arch/arm/boot/dts/100ask_imx6ull-14x14.dtb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述编译结果中，&lt;strong&gt;DTC 后面的即为编译好的设备树的二进制文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后通过网络传输一下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;book@100ask:~/100ask_imx6ull-sdk/Linux-4.9.88$ cp arch/arm/boot/dts/100ask_imx6ull-14x14.dtb ~/nfs_rootfs/
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;在开发板中（串口操作）
首先进入到/boot目录中&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd /boot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后查看一下/boot/ 的内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@imx6ull:/boot]# ls
100ask_imx6ull-14x14.dtb       zImage
100ask_imx6ull-14x14_back.dtb

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的100ask_imx6ull-14x14_back.dtb 是原来的100ask_imx6ull-14x14.dtb的备份，建议备份一下&lt;/p&gt;
&lt;p&gt;然后重启开发板&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@imx6ull:/boot]# reboot
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;32-内核驱动程序的改造&#34;&gt;3.2. 内核驱动程序的改造&lt;/h2&gt;
&lt;p&gt;内核处理设备树的函数调用过程，这里不去分析；我们只需要得到如下结论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A. &lt;strong&gt;&lt;code&gt;platform_device&lt;/code&gt;&lt;/strong&gt; 中含有 &lt;strong&gt;&lt;code&gt;resource&lt;/code&gt;&lt;/strong&gt; 数组, 它来自 device_node 的 reg, interrupts 属性;&lt;/li&gt;
&lt;li&gt;B. &lt;strong&gt;&lt;code&gt;platform_device.dev.of_node&lt;/code&gt;&lt;/strong&gt; 指向 &lt;strong&gt;&lt;code&gt;device_node&lt;/code&gt;&lt;/strong&gt;, 可以通过它获得其他属性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在/home/book/100ask_imx6ull-sdk/Linux-4.9.88/include/linux/的device.h中
定义了一个struct device 结构体&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/**
 * struct device - The basic device structure
 * @of_node:	Associated device tree node.
 */
struct device {
  /* ...省略部分代码 */
	struct device_node	*of_node; /* associated device tree node */

	struct fwnode_handle	*fwnode; /* firmware device node */

  /* ...省略部分代码 */
};


&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;321-platform_device包含来自设备树的-如何与-platform_driver-配对&#34;&gt;3.2.1. platform_device（包含来自设备树的） 如何与 platform_driver 配对:&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/%E5%8C%B9%E9%85%8D1.png&#34; alt=&#34;匹配&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;3211-使用设备树信息来判断-dev-和-drv-是否配对时&#34;&gt;3.2.1.1. 使用设备树信息来判断 dev 和 drv 是否配对时&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先，如果 of_match_table 中含有 compatible 值，就跟 dev 的 compatile 属性比较，若一致则成功，否则返回失败；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其次，如果 of_match_table 中含有 type 值，就跟 dev 的 device_type 属性比较，若一致则成功，否则返回失败；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后，如果 of_match_table 中含有 name 值，就跟 dev 的 name 属性比较，若一致则成功，否则返回失败。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;而设备树中建议不再使用 devcie_type 和 name 属性，所以基本上只使用设备节点的 compatible 属性 来寻找匹配的 platform_driver。&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对上述关系还有一个非常有趣的拟人化解释，这个解释出自这位博主的博客，链接如下：
&lt;a href=&#34;https://blog.csdn.net/zqixiao_09/article/details/50888795&#34;&gt;https://blog.csdn.net/zqixiao_09/article/details/50888795&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;打个比方，就好比相亲，总线是红娘，设备是男方，驱动是女方：&lt;/p&gt;
&lt;p&gt;a &amp;ndash; 红娘（总线）负责男方（设备）和女方（驱动）的撮合；     &lt;/p&gt;
&lt;p&gt;b &amp;ndash; 男方（女方）找到红娘，说我来登记一下，看有没有合适的姑娘（汉子）—— 设备或驱动的注册；&lt;/p&gt;
&lt;p&gt;c &amp;ndash; 红娘这时候就需要看看有没有八字（二者的name 字段）匹配的姑娘（汉子）——match 函数进行匹配，看name是否相同；&lt;/p&gt;
&lt;p&gt;d &amp;ndash; 如果八字不合，就告诉男方（女方）没有合适的对象，先等着，别急着乱做事 —— 设备和驱动会等待，直到匹配成功；&lt;/p&gt;
&lt;p&gt;e &amp;ndash; 终于遇到八字匹配的了，那就结婚呗！接完婚，男方就向女方交代，我有多少存款，我的房子在哪，钱放在哪等等（ struct resource    *resource），女方说好啊，于是去房子里拿钱，去给男方买菜啦，给自己买衣服、化妆品、首饰啊等等（int (*probe)(struct platform_device *) 匹配成功后驱动执行的第一个函数），当然如果男的跟小三跑了（设备卸载），女方也不会继续待下去的（  int (*remove)(struct platform_device *)）。&lt;/p&gt;
&lt;h2 id=&#34;33-按照这种转换关系代码改造如下&#34;&gt;3.3. 按照这种转换关系，代码改造如下&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* of_device_id */
static const struct of_device_id ask100_leds[] = {
    { .compatible = &amp;quot;100as,leddrv&amp;quot; },
    { }, //标志结束，不可省略
};

static struct platform_driver chip_demo_gpio_driver = {
    .probe      = chip_demo_gpio_probe,
    .remove     = chip_demo_gpio_remove,
    .driver     = {
        .name   = &amp;quot;mytest_led&amp;quot;,
        .of_match_table = ask100_leds,  //得到of_device_id
    },
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;34-匹配成功后会调用chip_demo_gpio_probe-注册分配的各种资源&#34;&gt;3.4. 匹配成功后，会调用chip_demo_gpio_probe 注册分配的各种资源&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
static int chip_demo_gpio_probe(struct platform_device *pdev)
{
    struct device_node *np;
    int err = 0;
    int led_pin;

    np = pdev-&amp;gt;dev.of_node;
    if (!np)
        return -1;
    
    /* 从设备树转化过来的平台设备中提取pin资源 */
    err = of_property_read_u32(np, &amp;quot;pin&amp;quot;, &amp;amp;led_pin);
    
    /* 利用设备的资源依次注册设备 */
    g_ledpins[g_ledcnt] = led_pin;
    led_class_create_device(g_ledcnt);
    g_ledcnt++;
        
    return 0;
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;35-注销分配的各种资源&#34;&gt;3.5. 注销分配的各种资源：&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
static int chip_demo_gpio_remove(struct platform_device *pdev)
{
    int i = 0;
    int err;
    struct device_node *np;
    int led_pin;

    np = pdev-&amp;gt;dev.of_node;
    if (!np)
        return -1;
    
    /* 判断一下是否为之前已解析到的pin属性 */
    err = of_property_read_u32(np, &amp;quot;pin&amp;quot;, &amp;amp;led_pin);

    for (i = 0; i &amp;lt; g_ledcnt; i++)
    {
        /* 如果是，则销毁设备，并把存放引脚属性的数组对应元素置为-1 */
        if (g_ledpins[i] == led_pin)
        {
            led_class_destroy_device(i);
            g_ledpins[i] = -1;
            break;
        };
    }
    
    /* 遍历一遍引脚属性数组，如果均为-1，说明都已经销毁掉了 */
    for (i = 0; i &amp;lt; g_ledcnt; i++)
    {
        if (g_ledpins[i] != -1)
            break;
    }

    /*如果均已销毁，引脚属性数组为空，则把已注册的LED灯的个数置为0，方便下次注册 */
    if (i == g_ledcnt)
        g_ledcnt = 0;
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;36-然后是模块加载和卸载函数&#34;&gt;3.6. 然后是模块加载和卸载函数：&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static int __init chip_demo_gpio_drv_init(void)
{
    int err;
    
    err = platform_driver_register(&amp;amp;chip_demo_gpio_driver); 
    register_led_operations(&amp;amp;board_demo_led_opr);
    
    return 0;
}

static void __exit lchip_demo_gpio_drv_exit(void)
{
    platform_driver_unregister(&amp;amp;chip_demo_gpio_driver);
}

module_init(chip_demo_gpio_drv_init);
module_exit(lchip_demo_gpio_drv_exit);

MODULE_LICENSE(&amp;quot;GPL&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到,模块加载和卸载函数仅仅通过paltform_driver_register()、paltform_driver_unregister() 函数进行 platform_driver 的注册和注销，而原先注册和注销字符设备的工作已经被移交到 platform_driver 的 probe() 和 remove() 成员函数中。&lt;/p&gt;
&lt;h2 id=&#34;37-进入开发板的mnt目录下&#34;&gt;3.7. 进入开发板的/mnt目录下&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@imx6ull:/mnt]# ls
100ask_imx6ull-14x14.dtb  leddrv.ko
chip_demo_gpio.ko         ledtest
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;38-将leddrvko-和-chip_demo_gpioko-注册进内核&#34;&gt;3.8. 将leddrv.ko 和 chip_demo_gpio.ko 注册进内核&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@imx6ull:/mnt]# insmod leddrv.ko
[root@imx6ull:/mnt]# insmod chip_demo_gpio.ko
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;进入到如下目录来查看一下，匹配之后的目录结构如下：
&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/%E7%9B%AE%E5%BD%95.png&#34; alt=&#34;转换关系新&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;39-执行一下命令来进行点灯的操作&#34;&gt;3.9. 执行一下命令来进行点灯的操作&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@imx6ull:/mnt]# ./ledtest /dev/mytest_led0 on
[root@imx6ull:/mnt]# ./ledtest /dev/mytest_led0 off
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：这里设备名之所以是mytest_ledx，是因为上层驱动中的device_create函数以&amp;quot;mytest_led%d&amp;quot;进行设备的创建&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void led_class_create_device(int minor)
{
	device_create(led_class, NULL, MKDEV(major, minor), NULL, &amp;quot;mytest_led%d&amp;quot;, minor); /* /dev/mytest_led0,1,... */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文末给出了具体的chip_demo_gpio.c 和 应用层的led_test.c等代码&lt;/p&gt;
&lt;h2 id=&#34;310-前后对比观察一下转化关系&#34;&gt;3.10. 前后对比，观察一下转化关系&lt;/h2&gt;
&lt;p&gt;关于内核对设备树文件的解析，可以参考设备树详解中的内容。这里仅针对目录结构对应的转化关系来看看结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;根结点下的子结点（一级结点）中的属性名，将来会成为开发板中/sys/firmware/devicetree/base目录下的文件，base则对应为根结点;
&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB%E6%96%B0.png&#34; alt=&#34;转换关系新&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于根结点下的二级结点，同样会以一级结点名作为目录，二级结点中的属性名将成为该目录下的文件
以reserved-memory结点为例，其包含linux,cma这一子结点：
&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/%E4%BA%8C%E7%BA%A7%E7%BB%93%E7%82%B9.png&#34; alt=&#34;二级结点&#34;&gt;
&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/%E4%BA%8C%E7%BA%A7%E7%BB%93%E7%82%B92.png&#34; alt=&#34;二级结点&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@imx6ull:/sys/firmware/devicetree/base/reserved-memory]# cd linux,cma
[root@imx6ull:/sys/firmware/devicetree/base/reserved-memory/linux,cma]# ls
compatible         name               size
linux,cma-default  reusable
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;对于结点中包含的属性，按照不同类型的值转换为不同类型的文件&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;这些属性的值如果是字符串，可以使用 cat 命令把它打印出来；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@imx6ull:/sys/firmware/devicetree/base/reserved-memory]# ls
#address-cells  #size-cells     linux,cma       name            ranges
[root@imx6ull:/sys/firmware/devicetree/base/reserved-memory]# cat name
reserved-memory
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;对于数值，可以用 hexdump 把它打印出来&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;[root@imx6ull:/sys/firmware/devicetree/base/reserved-memory/linux,cma]# ls
compatible         name               size
linux,cma-default  reusable
izeot@imx6ull:/sys/firmware/devicetree/base/reserved-memory/linux,cma]# hexdump s
0000000 0014 0000
0000004
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;4-参考来源&#34;&gt;4. 参考来源&lt;/h1&gt;
&lt;p&gt;本文参考了并学习了韦东山老师的视频和配套的文档，特此感谢&lt;/p&gt;
&lt;h1 id=&#34;5-程序&#34;&gt;5. 程序&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;chip_demo_gpio.c&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;linux/module.h&amp;gt;

#include &amp;lt;linux/fs.h&amp;gt;
#include &amp;lt;linux/errno.h&amp;gt;
#include &amp;lt;linux/miscdevice.h&amp;gt;
#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/major.h&amp;gt;
#include &amp;lt;linux/mutex.h&amp;gt;
#include &amp;lt;linux/proc_fs.h&amp;gt;
#include &amp;lt;linux/seq_file.h&amp;gt;
#include &amp;lt;linux/stat.h&amp;gt;
#include &amp;lt;linux/init.h&amp;gt;
#include &amp;lt;linux/device.h&amp;gt;
#include &amp;lt;linux/tty.h&amp;gt;
#include &amp;lt;linux/kmod.h&amp;gt;
#include &amp;lt;linux/gfp.h&amp;gt;
#include &amp;lt;linux/platform_device.h&amp;gt;
#include &amp;lt;linux/of.h&amp;gt;
#include &amp;lt;asm/io.h&amp;gt;

#include &amp;quot;led_opr.h&amp;quot;
#include &amp;quot;leddrv.h&amp;quot;
#include &amp;quot;led_resource.h&amp;quot;

static int g_ledpins[100];
static int g_ledcnt = 0;

static volatile unsigned int val;
static volatile unsigned int* CCM_CCGR1;
static volatile unsigned int* IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3;
static volatile unsigned int* GPIO5_GDIR;
static volatile unsigned int* GPIO5_DR;


static int board_demo_led_init(int which) /* 初始化LED, which-哪个LED */
{
	//printk(&amp;quot;%s %s line %d, led %d\n&amp;quot;, __FILE__, __FUNCTION__, __LINE__, which);

	printk(&amp;quot;init gpio: group %d, pin %d\n&amp;quot;, GROUP(g_ledpins[which]), PIN(g_ledpins[which]));
	switch (GROUP(g_ledpins[which]))
	{
	case 0:
	{
		printk(&amp;quot;init pin of group 0 ...\n&amp;quot;);
		break;
	}
	case 1:
	{
		printk(&amp;quot;init pin of group 1 ...\n&amp;quot;);
		break;
	}
	case 2:
	{
		printk(&amp;quot;init pin of group 2 ...\n&amp;quot;);
		break;
	}
	case 3:
	{
		printk(&amp;quot;init pin of group 3 ...\n&amp;quot;);
		break;
	}
	case 4:
	{
		printk(&amp;quot;init pin of group 4 ...\n&amp;quot;);
		break;
	}
	case 5:
	{

		printk(&amp;quot;init pin of group 5 ...\n&amp;quot;);
		if (!CCM_CCGR1)
		{
			CCM_CCGR1 = ioremap(0x20C406C, 4);
			IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = ioremap(0x2290014, 4);
			GPIO5_GDIR = ioremap(0x020AC000 + 0x4, 4);
			GPIO5_DR = ioremap(0x020AC000 + 0, 4);
		}

		/* GPIO5_IO03 */
		/* a. 使能GPIO5
			* set CCM to enable GPIO5
			* CCM_CCGR1[CG15] 0x20C406C
			* bit[31:30] = 0b11
			*/
		*CCM_CCGR1 |= (3 &amp;lt;&amp;lt; 30);

		/* b. 设置GPIO5_IO03用于GPIO
			* set IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3
			*      to configure GPIO5_IO03 as GPIO
			* IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3  0x2290014
			* bit[3:0] = 0b0101 alt5
			*/
		val = *IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3;
		val &amp;amp;= ~(0xf);
		val |= (5);
		*IOMUXC_SNVS_SW_MUX_CTL_PAD_SNVS_TAMPER3 = val;

		/* b. 设置GPIO5_IO03作为output引脚
			* set GPIO5_GDIR to configure GPIO5_IO03 as output
			* GPIO5_GDIR  0x020AC000 + 0x4
			* bit[3] = 0b1
			*/
		*GPIO5_GDIR |= (1 &amp;lt;&amp;lt; 3);
		break;
	}
	}

	return 0;
}


static int board_demo_led_ctl(int which, char status) /* 控制LED, which-哪个LED, status:1-亮,0-灭 */
{
	//printk(&amp;quot;%s %s line %d, led %d, %s\n&amp;quot;, __FILE__, __FUNCTION__, __LINE__, which, status ? &amp;quot;on&amp;quot; : &amp;quot;off&amp;quot;);
	printk(&amp;quot;set led %s: group %d, pin %d\n&amp;quot;, status ? &amp;quot;on&amp;quot; : &amp;quot;off&amp;quot;, GROUP(g_ledpins[which]), PIN(g_ledpins[which]));

	switch (GROUP(g_ledpins[which]))
	{
	case 0:
	{
		printk(&amp;quot;set pin of group 0 ...\n&amp;quot;);
		break;
	}
	case 1:
	{
		printk(&amp;quot;set pin of group 1 ...\n&amp;quot;);
		break;
	}
	case 2:
	{
		printk(&amp;quot;set pin of group 2 ...\n&amp;quot;);
		break;
	}
	case 3:
	{
		printk(&amp;quot;set pin of group 3 ...\n&amp;quot;);
		break;
	}
	case 4:
	{
		printk(&amp;quot;set pin of group 4 ...\n&amp;quot;);
		break;
	}
	case 5:
	{

		switch (PIN(g_ledpins[which]))
		{
		case 0:
			/* code */
			break;
		case 1:
			/* code */
			break;
		case 2:
			/* code */
			break;
		case 3:
			if (status) /* on: output 0*/
			{
				/* d. 设置GPIO5_DR输出低电平
			 * set GPIO5_DR to configure GPIO5_IO03 output 0
			 * GPIO5_DR 0x020AC000 + 0
			 * bit[3] = 0b0
			 */
				*GPIO5_DR &amp;amp;= ~(1 &amp;lt;&amp;lt; 3);
			}
			else /* off: output 1*/
			{
				/* e. 设置GPIO5_IO3输出高电平
			 * set GPIO5_DR to configure GPIO5_IO03 output 1
			 * GPIO5_DR 0x020AC000 + 0
			 * bit[3] = 0b1
			 */
				*GPIO5_DR |= (1 &amp;lt;&amp;lt; 3);
			}
			break;

		default:
			break;
		}
		printk(&amp;quot;set pin of group 5 ...\n&amp;quot;);
		break;
	}
	}
	return 0;
}



static struct led_operations board_demo_led_opr = {
    .init = board_demo_led_init,
    .ctl  = board_demo_led_ctl,
};

struct led_operations *get_board_led_opr(void)
{
    return &amp;amp;board_demo_led_opr;
}

static int chip_demo_gpio_probe(struct platform_device *pdev)
{
    struct device_node *np;
    int err = 0;
    int led_pin;

    np = pdev-&amp;gt;dev.of_node;
    if (!np)
        return -1;
    
    /* 从设备树转化过来的平台设备中提取pin资源 */
    err = of_property_read_u32(np, &amp;quot;pin&amp;quot;, &amp;amp;led_pin);
    
    /* 利用设备的资源依次注册设备 */
    g_ledpins[g_ledcnt] = led_pin;
    led_class_create_device(g_ledcnt);
    g_ledcnt++;
        
    return 0;
    
}

static int chip_demo_gpio_remove(struct platform_device *pdev)
{
    int i = 0;
    int err;
    struct device_node *np;
    int led_pin;

    np = pdev-&amp;gt;dev.of_node;
    if (!np)
        return -1;
    
    /* 判断一下是否为之前已解析到的pin属性 */
    err = of_property_read_u32(np, &amp;quot;pin&amp;quot;, &amp;amp;led_pin);

    for (i = 0; i &amp;lt; g_ledcnt; i++)
    {
        /* 如果是，则销毁设备，并把存放引脚属性的数组对应元素置为-1 */
        if (g_ledpins[i] == led_pin)
        {
            led_class_destroy_device(i);
            g_ledpins[i] = -1;
            break;
        };
    }
    
    /* 遍历一遍引脚属性数组，如果均为-1，说明都已经销毁掉了 */
    for (i = 0; i &amp;lt; g_ledcnt; i++)
    {
        if (g_ledpins[i] != -1)
            break;
    }

    /*如果均已销毁，引脚属性数组为空，则把已注册的LED灯的个数置为0，方便下次注册 */
    if (i == g_ledcnt)
        g_ledcnt = 0;
    
    return 0;
}

static const struct of_device_id ask100_leds[] = {
    { .compatible = &amp;quot;100as,leddrv&amp;quot; },
    { },
};

static struct platform_driver chip_demo_gpio_driver = {
    .probe      = chip_demo_gpio_probe,
    .remove     = chip_demo_gpio_remove,
    .driver     = {
        .name   = &amp;quot;mytest_led&amp;quot;,
        .of_match_table = ask100_leds,
    },
};

static int __init chip_demo_gpio_drv_init(void)
{
    int err;
    
    err = platform_driver_register(&amp;amp;chip_demo_gpio_driver); 
    register_led_operations(&amp;amp;board_demo_led_opr);
    
    return 0;
}

static void __exit lchip_demo_gpio_drv_exit(void)
{
    platform_driver_unregister(&amp;amp;chip_demo_gpio_driver);
}

module_init(chip_demo_gpio_drv_init);
module_exit(lchip_demo_gpio_drv_exit);

MODULE_LICENSE(&amp;quot;GPL&amp;quot;);

&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;上层驱动leddrv.c&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;linux/module.h&amp;gt;

#include &amp;lt;linux/fs.h&amp;gt;
#include &amp;lt;linux/errno.h&amp;gt;
#include &amp;lt;linux/miscdevice.h&amp;gt;
#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/major.h&amp;gt;
#include &amp;lt;linux/mutex.h&amp;gt;
#include &amp;lt;linux/proc_fs.h&amp;gt;
#include &amp;lt;linux/seq_file.h&amp;gt;
#include &amp;lt;linux/stat.h&amp;gt;
#include &amp;lt;linux/init.h&amp;gt;
#include &amp;lt;linux/device.h&amp;gt;
#include &amp;lt;linux/tty.h&amp;gt;
#include &amp;lt;linux/kmod.h&amp;gt;
#include &amp;lt;linux/gfp.h&amp;gt;

#include &amp;quot;led_opr.h&amp;quot;


/* 1. 确定主设备号                                                                 */
static int major = 0;
static struct class *led_class;
struct led_operations *p_led_opr;


#define MIN(a, b) (a &amp;lt; b ? a : b)


    //void led_class_create_device(int minor)
    //{
    //	device_create(led_class, NULL, MKDEV(major, minor), NULL, &amp;quot;100ask_led%d&amp;quot;, minor); /* /dev/100ask_led0,1,... */
    //}

void led_class_create_device(int minor)
{
	device_create(led_class, NULL, MKDEV(major, minor), NULL, &amp;quot;mytest_led%d&amp;quot;, minor); /* /dev/mytest_led0,1,... */
}

void led_class_destroy_device(int minor)
{
	device_destroy(led_class, MKDEV(major, minor));
}
void register_led_operations(struct led_operations *opr)
{
	p_led_opr = opr;
}

EXPORT_SYMBOL(led_class_create_device);
EXPORT_SYMBOL(led_class_destroy_device);
EXPORT_SYMBOL(register_led_operations);



/* 3. 实现对应的open/read/write等函数，填入file_operations结构体                   */
static ssize_t led_drv_read (struct file *file, char __user *buf, size_t size, loff_t *offset)
{
	printk(&amp;quot;%s %s line %d\n&amp;quot;, __FILE__, __FUNCTION__, __LINE__);
	return 0;
}

/* write(fd, &amp;amp;val, 1); */
static ssize_t led_drv_write (struct file *file, const char __user *buf, size_t size, loff_t *offset)
{
	int err;
	char status;
	struct inode *inode = file_inode(file);
	int minor = iminor(inode);
	
	printk(&amp;quot;%s %s line %d\n&amp;quot;, __FILE__, __FUNCTION__, __LINE__);
	err = copy_from_user(&amp;amp;status, buf, 1);

	/* 根据次设备号和status控制LED */
	p_led_opr-&amp;gt;ctl(minor, status);
	
	return 1;
}

static int led_drv_open (struct inode *node, struct file *file)
{
	int minor = iminor(node);
	
	printk(&amp;quot;%s %s line %d\n&amp;quot;, __FILE__, __FUNCTION__, __LINE__);
	/* 根据次设备号初始化LED */
	p_led_opr-&amp;gt;init(minor);
	
	return 0;
}

static int led_drv_close (struct inode *node, struct file *file)
{
	printk(&amp;quot;%s %s line %d\n&amp;quot;, __FILE__, __FUNCTION__, __LINE__);
	return 0;
}

/* 2. 定义自己的file_operations结构体                                              */
static struct file_operations led_drv = {
	.owner	 = THIS_MODULE,
	.open    = led_drv_open,
	.read    = led_drv_read,
	.write   = led_drv_write,
	.release = led_drv_close,
};

/* 4. 把file_operations结构体告诉内核：注册驱动程序                                */
/* 5. 谁来注册驱动程序啊？得有一个入口函数：安装驱动程序时，就会去调用这个入口函数 */
static int __init led_init(void)
{
	int err;
	
	printk(&amp;quot;%s %s line %d\n&amp;quot;, __FILE__, __FUNCTION__, __LINE__);
	major = register_chrdev(0, &amp;quot;100ask_led&amp;quot;, &amp;amp;led_drv);  /* /dev/led */


	led_class = class_create(THIS_MODULE, &amp;quot;100ask_led_class&amp;quot;);
	err = PTR_ERR(led_class);
	if (IS_ERR(led_class)) {
		printk(&amp;quot;%s %s line %d\n&amp;quot;, __FILE__, __FUNCTION__, __LINE__);
		unregister_chrdev(major, &amp;quot;100ask_led&amp;quot;);
		return -1;
	}
	
	return 0;
}

/* 6. 有入口函数就应该有出口函数：卸载驱动程序时，就会去调用这个出口函数           */
static void __exit led_exit(void)
{
	printk(&amp;quot;%s %s line %d\n&amp;quot;, __FILE__, __FUNCTION__, __LINE__);

	class_destroy(led_class);
	unregister_chrdev(major, &amp;quot;100ask_led&amp;quot;);
}


/* 7. 其他完善：提供设备信息，自动创建设备节点                                     */

module_init(led_init);
module_exit(led_exit);

MODULE_LICENSE(&amp;quot;GPL&amp;quot;);


&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;应用程序&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

/*
 * ./ledtest /dev/100ask_led0 on
 * ./ledtest /dev/100ask_led0 off
 */
int main(int argc, char **argv)
{
	int fd;
	char status;
	
	/* 1. 判断参数 */
	if (argc != 3) 
	{
		printf(&amp;quot;Usage: %s &amp;lt;dev&amp;gt; &amp;lt;on | off&amp;gt;\n&amp;quot;, argv[0]);
		return -1;
	}

	/* 2. 打开文件 */
	fd = open(argv[1], O_RDWR);
	if (fd == -1)
	{
		printf(&amp;quot;can not open file %s\n&amp;quot;, argv[1]);
		return -1;
	}

	/* 3. 写文件 */
	if (0 == strcmp(argv[2], &amp;quot;on&amp;quot;))
	{
		status = 1;
		write(fd, &amp;amp;status, 1);
	}
	else
	{
		status = 0;
		write(fd, &amp;amp;status, 1);
	}
	
	close(fd);
	
	return 0;
}


&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Makefile&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;
# 1. 使用不同的开发板内核时, 一定要修改KERN_DIR
# 2. KERN_DIR中的内核要事先配置、编译, 为了能编译内核, 要先设置下列环境变量:
# 2.1 ARCH,          比如: export ARCH=arm64
# 2.2 CROSS_COMPILE, 比如: export CROSS_COMPILE=aarch64-linux-gnu-
# 2.3 PATH,          比如: export PATH=$PATH:/home/book/100ask_roc-rk3399-pc/ToolChain-6.3.1/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin 
# 注意: 不同的开发板不同的编译器上述3个环境变量不一定相同,
#       请参考各开发板的高级用户使用手册

KERN_DIR = /home/book/100ask_imx6ull-sdk/Linux-4.9.88

all:
	make -C $(KERN_DIR) M=`pwd` modules 
	$(CROSS_COMPILE)gcc -o ledtest ledtest.c 

clean:
	make -C $(KERN_DIR) M=`pwd` modules clean
	rm -rf modules.order
	rm -f ledtest

# 参考内核源码drivers/char/ipmi/Makefile
# 要想把a.c, b.c编译成ab.ko, 可以这样指定:
# ab-y := a.o b.o
# obj-m += ab.o



obj-m += leddrv.o chip_demo_gpio.o

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>总线设备驱动模型</title>
      <link>https://strivefar.github.io/project/post/%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sun, 05 Jul 2020 00:04:17 +0800</pubDate>
      <guid>https://strivefar.github.io/project/post/%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;p&gt;绘制思维导图如下：
&lt;img src=&#34;https://strivefar.github.io/img/%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/LED%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E9%80%9A%E7%94%A8%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6300%25.png&#34; alt=&#34;xmind&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>链表中为何使用二级指针或者一级指针的引用</title>
      <link>https://strivefar.github.io/project/post/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/</link>
      <pubDate>Fri, 05 Jun 2020 18:26:48 +0800</pubDate>
      <guid>https://strivefar.github.io/project/post/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%8D%E8%A8%80&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%82%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F&#34;&gt;参数的调用方式&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#111-%E4%BC%A0%E5%80%BC%E8%B0%83%E7%94%A8&#34;&gt;11.1. 传值调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#112-%E4%BC%A0%E5%9D%80%E8%B0%83%E7%94%A8&#34;&gt;11.2. 传址调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#113-%E4%BC%A0%E5%BC%95%E7%94%A8%E8%B0%83%E7%94%A8&#34;&gt;11.3. 传引用调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#114-%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E&#34;&gt;11.4. 示例说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E5%88%9B%E5%BB%BA%E9%93%BE%E8%A1%A8%E6%97%B6%E7%9A%84%E5%AF%B9%E6%AF%94&#34;&gt;使用二级指针/一级指针创建链表时的对比&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#121-%E4%B8%BB%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BD%9C%E6%AD%A4%E8%B0%83%E7%94%A8&#34;&gt;12.1. 主函数中作此调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#122-%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E5%88%9B%E5%BB%BA%E9%93%BE%E8%A1%A8&#34;&gt;12.2. 使用二级指针创建链表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#123-%E4%BD%BF%E7%94%A8%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E5%88%9B%E5%BB%BA%E9%93%BE%E8%A1%A8%E4%BC%9A%E6%88%90%E5%8A%9F%E5%90%97&#34;&gt;12.3. 使用一级指针创建链表会成功吗&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8%E6%97%B6%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E5%92%8C%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%AF%B9%E6%AF%94&#34;&gt;销毁链表时二级指针和一级指针的对比&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#131-%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8&#34;&gt;13.1. 使用二级指针销毁链表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#132-%E4%BD%BF%E7%94%A8%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8%E4%BC%9A%E6%88%90%E5%8A%9F%E5%90%97&#34;&gt;13.2. 使用一级指针销毁链表会成功吗&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%80%BB%E7%BB%93&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81&#34;&gt;完整代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%82%E8%80%83%E6%9D%A5%E6%BA%90&#34;&gt;参考来源&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;我们在学习数据结构时，在链表初始化或者销毁链表的时候，经常使用二级指针或者一级指针的引用，这是为什么呢？同样是指向内存单元的地址，为什么就不能使用一级指针呢？使用一级指针去初始化或者是销毁链表的时候，究竟会发生什么呢？到底什么时候该用二级指针，什么时候该用一级指针？&lt;/p&gt;
&lt;p&gt;如果你对这些问题有疑问，可以参考本篇文章，以下是我个人对这些问题的理解，如有问题，欢迎随时联系我。&lt;/p&gt;
&lt;h1 id=&#34;参数的调用方式&#34;&gt;参数的调用方式&lt;/h1&gt;
&lt;p&gt;我们通常使用的函数调用方式无非两种，一种是&lt;strong&gt;传值调用&lt;/strong&gt;，一种是&lt;strong&gt;传址调用&lt;/strong&gt;。
谈起&lt;strong&gt;指针&lt;/strong&gt;我们可能瞬间就会把它和传址调用联系在一起，但实际上，&lt;strong&gt;对于指针来讲，它也存在着这两种调用方式，传值调用和传值调用&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;111-传值调用&#34;&gt;11.1. 传值调用&lt;/h2&gt;
&lt;p&gt;传值调用是指在调用参数时,不是对原参数进行操作,而是创建参数的拷贝并对其进行操作,这种调用有利于保护数据。&lt;/p&gt;
&lt;h2 id=&#34;112-传址调用&#34;&gt;11.2. 传址调用&lt;/h2&gt;
&lt;p&gt;传址调用的过程中把函数外部创建的变量的内存地址传递给函数参数，这种调用可以让函数和函数外边的变量建立起联系，函数内部可以直接操作函数外部；&lt;/p&gt;
&lt;h2 id=&#34;113-传引用调用&#34;&gt;11.3. 传引用调用&lt;/h2&gt;
&lt;p&gt;适用于C++，不适用于C语言&lt;/p&gt;
&lt;h2 id=&#34;114-示例说明&#34;&gt;11.4. 示例说明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;
传递一级指针变量本身等价于在传递指针变量的值，虽然有指针参与其中，但在函数内部，也只是创建了指针的copy，无非就是把传过来的实参的值给指针的copy用一用，并没有对实参（原指针变量）进行操作&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;    
#include &amp;lt;string.h&amp;gt;    
using namespace std;    
    
void fun1(char* str)    
{    
    str = new char[5];    
    strcpy (str, &amp;quot;test string&amp;quot;);    
}    
    
void fun2(char** str)    
{    
    *str = new char[5];    
    strcpy (*str, &amp;quot;test string&amp;quot;);    
}    
    
int main()    
{    
    char* s = NULL;        
    cout &amp;lt;&amp;lt; &amp;quot;call function fun1&amp;quot; &amp;lt;&amp;lt; endl;    
    fun1 (s);    
    if (!s)    
        cout &amp;lt;&amp;lt; &amp;quot;s is null!&amp;quot; &amp;lt;&amp;lt; endl;    
    else    
        cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;    
    
    cout &amp;lt;&amp;lt; &amp;quot;call function fun2&amp;quot; &amp;lt;&amp;lt; endl;    
    fun2 (&amp;amp;s);    
    if (!s)    
        cout &amp;lt;&amp;lt; &amp;quot;s is null!&amp;quot; &amp;lt;&amp;lt; endl;    
    else    
        cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;    
    return 0;    
}    
————————————————
版权声明：本文为CSDN博主「踏莎行hyx」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/u012234115/article/details/39717215
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果：
&lt;img src=&#34;https://strivefar.github.io/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png&#34; alt=&#34;wechat&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;使用二级指针一级指针创建链表时的对比&#34;&gt;使用二级指针/一级指针创建链表时的对比&lt;/h1&gt;
&lt;h2 id=&#34;121-主函数中作此调用&#34;&gt;12.1. 主函数中作此调用&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main()
{
    LinkList L;
    ElemType e;
    Status i;
    int j, k;
    //InitList1(L);   //一级指针方式创建表头，失败
    InitList2(&amp;amp;L);  //二级指针方式创建表头，成功
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;122-使用二级指针创建链表&#34;&gt;12.2. 使用二级指针创建链表&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//初始化表头，用二级指针
Status InitList2(LinkList *L) //等价于Node **L
{
    *L = (LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */
    if (!(*L))                           /* 存储分配失败 */
        return ERROR;
    (*L)-&amp;gt;next = NULL; /* 指针域为空 */

    return OK;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用图片说明更为直观：
&lt;strong&gt;函数内部可以直接操作函数外部&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://strivefar.github.io/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E5%88%9D%E5%A7%8B%E5%8C%96.png&#34; alt=&#34;wechat&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简明描述为：&lt;/strong&gt;
&lt;img src=&#34;https://strivefar.github.io/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E5%88%9B%E5%BB%BA%E9%93%BE%E8%A1%A8%E6%9C%89%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E6%A1%86%E5%9B%BE.png&#34; alt=&#34;wechat&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果没有头结点：&lt;/strong&gt;
![在这里插入图片描述]&lt;img src=&#34;https://strivefar.github.io/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E5%88%9B%E5%BB%BA%E9%93%BE%E8%A1%A8%E6%A1%86%E5%9B%BE.png&#34; alt=&#34;wechat&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;123-使用一级指针创建链表会成功吗&#34;&gt;12.3. 使用一级指针创建链表会成功吗&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//初始化表头，用一级指针（此方式无效）
Status InitList1(LinkList L) //等价于Node *L
{
    L = (LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */
    if (!L)                             /* 存储分配失败 */
        return ERROR;
    L-&amp;gt;next = NULL; /* 指针域为空 */

    return OK;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用图片说明更为直观：
![在这里插入图片描述]&lt;img src=&#34;https://strivefar.github.io/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E5%88%9D%E5%A7%8B%E5%8C%96.png&#34; alt=&#34;wechat&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;很明显，把传过来的实参的值给指针的copy用一用，并没有对实参（原指针变量）进行操作&lt;/strong&gt;，这样创建的链表是毫无意义的，main.c后面再使用L时，用的依旧是个垃圾值，是有隐患的。&lt;/p&gt;
&lt;h1 id=&#34;销毁链表时二级指针和一级指针的对比&#34;&gt;销毁链表时二级指针和一级指针的对比&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;main.c中&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;printf(&amp;quot;销毁链表\n&amp;quot;);
//DestroyList1(L);   //一级指针方式销毁链表，失败,且出现满屏乱码
DestroyList2(&amp;amp;L);  //二级指针方式销毁链表，成功
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;131-使用二级指针销毁链表&#34;&gt;13.1. 使用二级指针销毁链表&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//销毁链表，使用二级指针
Status DestroyList2(LinkList *L)
{
    LinkList p, q;
    p = (*L)-&amp;gt;next; /*  p指向第一个结点 */
    while (p)       /*  没到表尾 */
    {
        q = p-&amp;gt;next;
        free(p);
        p = q;
    }
    free(*L); //头结点彻底没有掉才是销毁
    *L = NULL;
    return OK;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用图片说明更为直观：&lt;/p&gt;
&lt;p&gt;![在这里插入图片描述]&lt;img src=&#34;https://strivefar.github.io/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8.png&#34; alt=&#34;wechat&#34;&gt;&lt;/p&gt;
&lt;p&gt;简单来说：
&lt;strong&gt;销毁链表就是让头指针为空，然后这个链表就彻底湮没在内存中了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;![在这里插入图片描述]&lt;img src=&#34;https://strivefar.github.io/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E9%94%80%E6%AF%81%E5%A4%B4%E7%BB%93%E7%82%B9%E6%A1%86%E5%9B%BE.png&#34; alt=&#34;wechat&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;132-使用一级指针销毁链表会成功吗&#34;&gt;13.2. 使用一级指针销毁链表会成功吗&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//销毁链表，使用一级指针(此方式无效)
Status DestroyList1(LinkList L)
{
    LinkList p, q;
    p = L-&amp;gt;next; /*  p指向第一个结点 */
    while (p)    /*  没到表尾 */
    {
        q = p-&amp;gt;next;
        free(p);
        p = q;
    }
    free(L);
    L = NULL;
    return OK;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用图片说明更为直观：&lt;/p&gt;
&lt;p&gt;![在这里插入图片描述]&lt;img src=&#34;https://strivefar.github.io/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/%E4%BD%BF%E7%94%A8%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8.png&#34; alt=&#34;wechat&#34;&gt;
可见这种方式的确很危险，实际测试中也的确出现了乱码&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;1.初始化链表头部指针需要用二级指针或者一级指针的引用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.销毁链表需要用到二级指针或者一级指针的引用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.插入、删除、遍历、清空结点用一级指针即可。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;完整代码&#34;&gt;完整代码&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;stdio.h&amp;quot;
#include &amp;quot;stdlib.h&amp;quot;
#include &amp;quot;time.h&amp;quot;
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 20    /* 存储空间初始分配量 */
typedef int Status;   /* Status是函数的类型,其值是函数结果状态代码，如OK等 */
typedef int ElemType; /* ElemType类型根据实际情况而定，这里假设为int */
Status visit(ElemType c)
{
    printf(&amp;quot;%d &amp;quot;, c);
    return OK;
}
typedef struct Node
{
    ElemType data;
    struct Node *next;
} Node;
typedef struct Node *LinkList; /* 定义LinkList */

//初始化表头，用一级指针（此方式无效）
Status InitList1(LinkList L) //等价于Node *L
{
    L = (LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */
    if (!L)                             /* 存储分配失败 */
        return ERROR;
    L-&amp;gt;next = NULL; /* 指针域为空 */

    return OK;
}

//初始化表头，用二级指针
Status InitList2(LinkList *L) //等价于Node **L
{
    *L = (LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */
    if (!(*L))                           /* 存储分配失败 */
        return ERROR;
    (*L)-&amp;gt;next = NULL; /* 指针域为空 */

    return OK;
}

//初始化表头，用一级指针引用
Status InitList3(LinkList &amp;amp;L) //等价于Node *&amp;amp;L
{
    L = (LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */
    if (!L)                             /* 存储分配失败 */
        return ERROR;
    L-&amp;gt;next = NULL; /* 指针域为空 */

    return OK;
}

//清空链表，使用二级指针
Status ClearList1(LinkList *L)
{
    LinkList p, q;
    p = (*L)-&amp;gt;next; /*  p指向第一个结点 */
    while (p)       /*  没到表尾 */
    {
        q = p-&amp;gt;next;
        free(p);
        p = q;
    }
    (*L)-&amp;gt;next = NULL; /* 头结点指针域为空 */
    return OK;
}

//清空链表，使用一级指针
Status ClearList2(LinkList L)
{
    LinkList p, q;
    p = L-&amp;gt;next; /*  p指向(这里的第一个结点只头结点) */
    while (p)    /*  没到表尾 */
    {
        q = p-&amp;gt;next;
        free(p);
        p = q;
    }
    L-&amp;gt;next = NULL; /* 头结点指针域为空 */
    return OK;
}

//销毁链表，使用一级指针(此方式无效)
Status DestroyList1(LinkList L)
{
    LinkList p, q;
    p = L-&amp;gt;next; /*  p指向第一个结点 */
    while (p)    /*  没到表尾 */
    {
        q = p-&amp;gt;next;
        free(p);
        p = q;
    }
    free(L);
    L = NULL;
    return OK;
}

//销毁链表，使用二级指针
Status DestroyList2(LinkList *L)
{
    LinkList p, q;
    p = (*L)-&amp;gt;next; /* p指向头结点(第一个结点) */
    while (p)       /*  没到表尾 */
    {
        q = p-&amp;gt;next;
        free(p);
        p = q;
    }
    free(*L); //头结点彻底没有掉才是销毁
    *L = NULL;
    return OK;
}

//销毁链表，使用一级指针引用
Status DestroyList3(LinkList &amp;amp;L)
{
    LinkList p, q;
    p = L-&amp;gt;next; /*  p指向第一个结点 */
    while (p)    /*  没到表尾 */
    {
        q = p-&amp;gt;next;
        free(p);
        p = q;
    }
    free(L);
    L = NULL;
    return OK;
}
/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
/* 操作结果：用e返回L中第i个数据元素的值 */
Status GetElem(LinkList L, int i, ElemType *e)
{
    int j;
    LinkList p;        /* 声明一结点p */
    p = L-&amp;gt;next;       /* 让p指向链表L的第一个结点 */
    j = 1;             /*  j为计数器 */
    while (p &amp;amp;&amp;amp; j &amp;lt; i) /* p不为空或者计数器j还没有等于i时，循环继续 */
    {
        p = p-&amp;gt;next; /* 让p指向下一个结点 */
        ++j;
    }
    if (!p || j &amp;gt; i)
        return ERROR; /*  第i个元素不存在 */
    *e = p-&amp;gt;data;     /*  取第i个元素的数据 */
    return OK;
}

//在中间插入元素，用二级指针
Status ListInsert1(LinkList *L, int i, ElemType e)
{
    int j;
    LinkList p, s;
    p = *L;
    j = 1;
    while (p &amp;amp;&amp;amp; j &amp;lt; i) /* 寻找第i个结点 */
    {
        p = p-&amp;gt;next;
        ++j;
    }
    if (!p || j &amp;gt; i)
        return ERROR;                   /* 第i个元素不存在 */
    s = (LinkList)malloc(sizeof(Node)); /*  生成新结点(C语言标准函数) */
    s-&amp;gt;data = e;
    s-&amp;gt;next = p-&amp;gt;next; /* 将p的后继结点赋值给s的后继  */
    p-&amp;gt;next = s;       /* 将s赋值给p的后继 */
    return OK;
}
//在中间插入元素，用一级指针
Status ListInsert2(LinkList L, int i, ElemType e)
{
    int j;
    LinkList p, s;
    p = L;
    j = 1;
    while (p &amp;amp;&amp;amp; j &amp;lt; i) /* 寻找第i个结点 */
    {
        p = p-&amp;gt;next;
        ++j;
    }
    if (!p || j &amp;gt; i)
        return ERROR;                   /* 第i个元素不存在 */
    s = (LinkList)malloc(sizeof(Node)); /*  生成新结点(C语言标准函数) */
    s-&amp;gt;data = e;
    s-&amp;gt;next = p-&amp;gt;next; /* 将p的后继结点赋值给s的后继  */
    p-&amp;gt;next = s;       /* 将s赋值给p的后继 */
    return OK;
}
//删除一个元素，用二级指针
Status ListDelete1(LinkList *L, int i, ElemType *e)
{
    int j;
    LinkList p, q;
    p = *L;
    j = 1;
    while (p-&amp;gt;next &amp;amp;&amp;amp; j &amp;lt; i) /* 遍历寻找第i个元素 */
    {
        p = p-&amp;gt;next;
        ++j;
    }
    if (!(p-&amp;gt;next) || j &amp;gt; i)
        return ERROR; /* 第i个元素不存在 */
    q = p-&amp;gt;next;
    p-&amp;gt;next = q-&amp;gt;next; /* 将q的后继赋值给p的后继 */
    *e = q-&amp;gt;data;      /* 将q结点中的数据给e */
    free(q);           /* 让系统回收此结点，释放内存 */
    return OK;
}
//删除一个元素，用一级指针
Status ListDelete2(LinkList L, int i, ElemType *e)
{
    int j;
    LinkList p, q;
    p = L;
    j = 1;
    while (p-&amp;gt;next &amp;amp;&amp;amp; j &amp;lt; i) /* 遍历寻找第i个元素 */
    {
        p = p-&amp;gt;next;
        ++j;
    }
    if (!(p-&amp;gt;next) || j &amp;gt; i)
        return ERROR; /* 第i个元素不存在 */
    q = p-&amp;gt;next;
    p-&amp;gt;next = q-&amp;gt;next; /* 将q的后继赋值给p的后继 */
    *e = q-&amp;gt;data;      /* 将q结点中的数据给e */
    free(q);           /* 让系统回收此结点，释放内存 */
    return OK;
}
/* 初始条件：顺序线性表L已存在 */
/* 操作结果：依次对L的每个数据元素输出 */
Status ListTraverse(LinkList L)
{
    LinkList p = L-&amp;gt;next;
    while (p)
    {
        visit(p-&amp;gt;data);
        p = p-&amp;gt;next;
    }
    printf(&amp;quot;\n&amp;quot;);
    return OK;
}
int main()
{
    LinkList L;
    ElemType e;
    Status i;
    int j, k;
    //InitList1(L);   //一级指针方式创建表头，失败
    //InitList2(&amp;amp;L);  //二级指针方式创建表头，成功
    InitList3(L); //一级指针引用方式创建表头，成功
    for (j = 1; j &amp;lt;= 7; j++)
        ListInsert2(L, 1, j);
    printf(&amp;quot;一级指针方式在L的表头依次插入1～7后：&amp;quot;);
    ListTraverse(L);

    ListInsert1(&amp;amp;L, 3, 12);
    printf(&amp;quot;二级指针方式在L的中间插入12后：&amp;quot;);
    ListTraverse(L);

    ListInsert2(L, 5, 27);
    printf(&amp;quot;一级指针在L的中间插入27后：&amp;quot;);
    ListTraverse(L);

    GetElem(L, 5, &amp;amp;e);
    printf(&amp;quot;第5个元素的值为：%d\n&amp;quot;, e);

    ListDelete1(&amp;amp;L, 5, &amp;amp;e); /* 删除第5个数据 */
    printf(&amp;quot;二级指针方式删除第%d个的元素值为：%d\n&amp;quot;, 5, e);
    printf(&amp;quot;依次输出L的元素：&amp;quot;);
    ListTraverse(L);

    ListDelete2(L, 3, &amp;amp;e); /* 删除第3个数据 */
    printf(&amp;quot;一级指针方式删除第%d个的元素值为：%d\n&amp;quot;, 3, e);
    printf(&amp;quot;依次输出L的元素：&amp;quot;);
    ListTraverse(L);

    printf(&amp;quot;二级指针方式清空链表\n&amp;quot;);
    ClearList1(&amp;amp;L);
    printf(&amp;quot;依次输出L的元素：&amp;quot;);
    ListTraverse(L);

    for (j = 1; j &amp;lt;= 7; j++)
        ListInsert2(L, j, j);
    printf(&amp;quot;在L的表尾依次插入1～7后：&amp;quot;);
    ListTraverse(L);

    printf(&amp;quot;一级指针方式清空链表\n&amp;quot;);
    ClearList2(L);
    printf(&amp;quot;依次输出L的元素：&amp;quot;);
    ListTraverse(L);

    printf(&amp;quot;销毁链表\n&amp;quot;);
    //DestroyList1(L);   //一级指针方式销毁链表，失败,且出现满屏乱码
    DestroyList2(&amp;amp;L); //二级指针方式销毁链表，成功
    DestroyList3(L);  //一级指针引用方式销毁链表，成功

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;参考来源&#34;&gt;参考来源&lt;/h1&gt;
&lt;p&gt;本文参考了以下博文，结合自己的理解，总结记录了相关知识，特此感谢
&lt;a href=&#34;https://blog.csdn.net/u012234115/article/details/39717215&#34;&gt;https://blog.csdn.net/u012234115/article/details/39717215&lt;/a&gt;
&lt;a href=&#34;https://blog.csdn.net/DX_Jone/article/details/102817995&#34;&gt;https://blog.csdn.net/DX_Jone/article/details/102817995&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>动态编译和静态编译——制作动态库和静态库</title>
      <link>https://strivefar.github.io/project/post/getting-started/</link>
      <pubDate>Wed, 13 May 2020 00:00:00 +0000</pubDate>
      <guid>https://strivefar.github.io/project/post/getting-started/</guid>
      <description>&lt;h1 id=&#34;参考链接&#34;&gt;参考链接&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;http://c.biancheng.net/view/2385.html&#34;&gt;GCC生成动态链接库（.so文件）：-shared和-fPIC选项&lt;/a&gt;
&lt;a href=&#34;http://c.biancheng.net/view/7168.html&#34;&gt;GCC创建和使用静态链接库（.a文件）&lt;/a&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1ZT4y137Ba?from=search&amp;amp;seid=5456022104877118795&#34;&gt;gcc的使用方法；动态编译和静态编译；Linux制作动态库和静态库&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;命名规则&#34;&gt;命名规则&lt;/h1&gt;
&lt;p&gt;静态库命名规则如下：
&lt;strong&gt;libxxx.o&lt;/strong&gt;
&lt;strong&gt;lib&lt;/strong&gt;:前缀
&lt;strong&gt;.o&lt;/strong&gt;:静态库
动态链接库（shared object file，共享对象文件）命名规则如下：
&lt;strong&gt;libxxx.so&lt;/strong&gt;
&lt;strong&gt;lib&lt;/strong&gt;:前缀
&lt;strong&gt;.so&lt;/strong&gt;:动态库&lt;/p&gt;
&lt;h1 id=&#34;静态库参数&#34;&gt;静态库参数&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503195703920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;gcc-常用编译选项&#34;&gt;gcc 常用编译选项&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503200518148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;动态库和静态库的对比&#34;&gt;动态库和静态库的对比&lt;/h1&gt;
&lt;p&gt;我们先来说一下静态库；
Linux下的静态库是以.a结尾的二进制文件，它作为一个程序的模块，它在链接期间就被组合到了程序中，比如说我有一个主程序mian.c，那么我把它和静态库链接的时候，它就直接把这个静态库组合到了我的main.c里面生成的一个二进制文件.a。
而与静态链接库相对的是动态链接库，同样的是把主函数mian.c和动态库进行链接，与静态库不同的是,这个动态库在程序运行的阶段才会被加载进内存,参与主函数运行
下面用几张图来说明一下：
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503132421885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503195153959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;tr&gt;&lt;td bgcolor=orange&gt;还可以加上-static选项，让链接静态库后的math.out彻底的独立起来，“完全静态”&lt;/td&gt;&lt;/tr&gt;，因此，得到的二进制文件会非常大。
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503133250379.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503133154266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503132624143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;使用静态动态链接库的优缺点&#34;&gt;使用静态/动态链接库的优缺点：&lt;/h1&gt;
&lt;h3 id=&#34;静态库&#34;&gt;静态库：&lt;/h3&gt;
&lt;p&gt;编译后的执行程序不需要外部的函数库支持，&lt;strong&gt;因为所有使用的函数都经被编译进去了&lt;/strong&gt;。当然这也会成为他的缺点，因为如果&lt;strong&gt;静态函数库改变&lt;/strong&gt;了，那么你的程序必须&lt;strong&gt;重新编译&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;静态库的代码在编译时链接到应用程序中，因此&lt;strong&gt;编译时库文件必须存在并且需要通过“-L”参数传递给编译器&lt;/strong&gt;，应用程序在开始执行时，库函数代码将随程序一 起调入进程内存段直到进程结束，其执行过程不需要原静态库存在。&lt;/p&gt;
&lt;h3 id=&#34;动态库&#34;&gt;动态库：&lt;/h3&gt;
&lt;p&gt;动态函数库在编译的时候&lt;strong&gt;并没有&lt;/strong&gt;被编译进目标代码中，你的程序&lt;strong&gt;执行到相关函数时才调用该函数库里的相应函数&lt;/strong&gt;，因此动态函数库所产生的可执行文件比较&lt;strong&gt;小&lt;/strong&gt;。由于函数库没有被整合进你的程序，而是程序运行时动态的申请并调用，所以程序的&lt;strong&gt;运行环境中必须提供相应的库&lt;/strong&gt;。动态函数库的改变并不影响你的程序，所以动态函数库的&lt;strong&gt;升级比较方便&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不同的INIX系统链接动态库方法，实现细节不一样，编译PIC型.o中间文件的方法一般是采用C语言编译器的-KPIC或者 -fPIC选项
&lt;strong&gt;最主要的是GCC命令行的一个选项:&lt;/strong&gt;
&lt;strong&gt;-shared&lt;/strong&gt;:该选项指定&lt;strong&gt;生成动态连接库&lt;/strong&gt;(让连接器生成T类型的导出符号表，有时候也生成弱连接W类
型的导出符号) ,不用该标志外部程序无法连接。相当于一个可执行文件
&lt;strong&gt;-fPIC&lt;/strong&gt;:表示编译为&lt;strong&gt;位置独立&lt;/strong&gt;的代码，不用此选项的话编译后的代码是位置相关的,所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。&lt;/p&gt;
&lt;h1 id=&#34;制作链接库的目的商业角度&#34;&gt;制作链接库的目的（商业角度）：&lt;/h1&gt;
&lt;p&gt;这就和&lt;strong&gt;商业&lt;/strong&gt;项目挂钩了:
假如我们是一个项目的外包方，我们是有专利的，&lt;strong&gt;希望别人使用我们已经实现的功能，但又不希望别人看到我们的源代码&lt;/strong&gt;，所以这对商业机构是非常友好的。&lt;/p&gt;
&lt;h1 id=&#34;makefile中的使用实例&#34;&gt;Makefile中的使用实例：&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503143928633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503144212953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An example preprint / working paper</title>
      <link>https://strivefar.github.io/publication/preprint/</link>
      <pubDate>Sun, 07 Apr 2019 00:00:00 +0000</pubDate>
      <guid>https://strivefar.github.io/publication/preprint/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Click the &lt;em&gt;Slides&lt;/em&gt; button above to demo Academic&amp;rsquo;s Markdown slides feature.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Supplementary notes can be added here, including &lt;a href=&#34;https://sourcethemes.com/academic/docs/writing-markdown-latex/&#34;&gt;code and math&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Slides</title>
      <link>https://strivefar.github.io/slides/example/</link>
      <pubDate>Tue, 05 Feb 2019 00:00:00 +0000</pubDate>
      <guid>https://strivefar.github.io/slides/example/</guid>
      <description>&lt;h1 id=&#34;create-slides-in-markdown-with-academic&#34;&gt;Create slides in Markdown with Academic&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://sourcethemes.com/academic/&#34;&gt;Academic&lt;/a&gt; | &lt;a href=&#34;https://sourcethemes.com/academic/docs/managing-content/#create-slides&#34;&gt;Documentation&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;features&#34;&gt;Features&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Efficiently write slides in Markdown&lt;/li&gt;
&lt;li&gt;3-in-1: Create, Present, and Publish your slides&lt;/li&gt;
&lt;li&gt;Supports speaker notes&lt;/li&gt;
&lt;li&gt;Mobile friendly slides&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;controls&#34;&gt;Controls&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Next: &lt;code&gt;Right Arrow&lt;/code&gt; or &lt;code&gt;Space&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Previous: &lt;code&gt;Left Arrow&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Start: &lt;code&gt;Home&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Finish: &lt;code&gt;End&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Overview: &lt;code&gt;Esc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Speaker notes: &lt;code&gt;S&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Fullscreen: &lt;code&gt;F&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Zoom: &lt;code&gt;Alt + Click&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hakimel/reveal.js#pdf-export&#34;&gt;PDF Export&lt;/a&gt;: &lt;code&gt;E&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;code-highlighting&#34;&gt;Code Highlighting&lt;/h2&gt;
&lt;p&gt;Inline code: &lt;code&gt;variable&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Code block:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;porridge = &amp;quot;blueberry&amp;quot;
if porridge == &amp;quot;blueberry&amp;quot;:
    print(&amp;quot;Eating...&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;math&#34;&gt;Math&lt;/h2&gt;
&lt;p&gt;In-line math: $x + y = z$&lt;/p&gt;
&lt;p&gt;Block math:&lt;/p&gt;
&lt;p&gt;$$
f\left( x \right) = ;\frac{{2\left( {x + 4} \right)\left( {x - 4} \right)}}{{\left( {x + 4} \right)\left( {x + 1} \right)}}
$$&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;fragments&#34;&gt;Fragments&lt;/h2&gt;
&lt;p&gt;Make content appear incrementally&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{{% fragment %}} One {{% /fragment %}}
{{% fragment %}} **Two** {{% /fragment %}}
{{% fragment %}} Three {{% /fragment %}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Press &lt;code&gt;Space&lt;/code&gt; to play!&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;fragment &#34; &gt;
One
&lt;/span&gt;
&lt;span class=&#34;fragment &#34; &gt;
&lt;strong&gt;Two&lt;/strong&gt;
&lt;/span&gt;
&lt;span class=&#34;fragment &#34; &gt;
Three
&lt;/span&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;A fragment can accept two optional parameters:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;class&lt;/code&gt;: use a custom style (requires definition in custom CSS)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;weight&lt;/code&gt;: sets the order in which a fragment appears&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;speaker-notes&#34;&gt;Speaker Notes&lt;/h2&gt;
&lt;p&gt;Add speaker notes to your presentation&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;{{% speaker_note %}}
- Only the speaker can read these notes
- Press `S` key to view
{{% /speaker_note %}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Press the &lt;code&gt;S&lt;/code&gt; key to view the speaker notes!&lt;/p&gt;
&lt;aside class=&#34;notes&#34;&gt;
  &lt;ul&gt;
&lt;li&gt;Only the speaker can read these notes&lt;/li&gt;
&lt;li&gt;Press &lt;code&gt;S&lt;/code&gt; key to view&lt;/li&gt;
&lt;/ul&gt;

&lt;/aside&gt;
&lt;hr&gt;
&lt;h2 id=&#34;themes&#34;&gt;Themes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;black: Black background, white text, blue links (default)&lt;/li&gt;
&lt;li&gt;white: White background, black text, blue links&lt;/li&gt;
&lt;li&gt;league: Gray background, white text, blue links&lt;/li&gt;
&lt;li&gt;beige: Beige background, dark text, brown links&lt;/li&gt;
&lt;li&gt;sky: Blue background, thin dark text, blue links&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;night: Black background, thick white text, orange links&lt;/li&gt;
&lt;li&gt;serif: Cappuccino background, gray text, brown links&lt;/li&gt;
&lt;li&gt;simple: White background, black text, blue links&lt;/li&gt;
&lt;li&gt;solarized: Cream-colored background, dark green text, blue links&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;

&lt;section data-noprocess data-shortcode-slide
  
      
      data-background-image=&#34;/img/boards.jpg&#34;
  &gt;

&lt;h2 id=&#34;custom-slide&#34;&gt;Custom Slide&lt;/h2&gt;
&lt;p&gt;Customize the slide style and background&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;{{&amp;lt; slide background-image=&amp;quot;/img/boards.jpg&amp;quot; &amp;gt;}}
{{&amp;lt; slide background-color=&amp;quot;#0000FF&amp;quot; &amp;gt;}}
{{&amp;lt; slide class=&amp;quot;my-style&amp;quot; &amp;gt;}}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;custom-css-example&#34;&gt;Custom CSS Example&lt;/h2&gt;
&lt;p&gt;Let&amp;rsquo;s make headers navy colored.&lt;/p&gt;
&lt;p&gt;Create &lt;code&gt;assets/css/reveal_custom.css&lt;/code&gt; with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.reveal section h1,
.reveal section h2,
.reveal section h3 {
  color: navy;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;questions&#34;&gt;Questions?&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://spectrum.chat/academic&#34;&gt;Ask&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://sourcethemes.com/academic/docs/managing-content/#create-slides&#34;&gt;Documentation&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Privacy Policy</title>
      <link>https://strivefar.github.io/privacy/</link>
      <pubDate>Thu, 28 Jun 2018 00:00:00 +0100</pubDate>
      <guid>https://strivefar.github.io/privacy/</guid>
      <description>&lt;p&gt;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Terms</title>
      <link>https://strivefar.github.io/terms/</link>
      <pubDate>Thu, 28 Jun 2018 00:00:00 +0100</pubDate>
      <guid>https://strivefar.github.io/terms/</guid>
      <description>&lt;p&gt;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An example journal article</title>
      <link>https://strivefar.github.io/publication/journal-article/</link>
      <pubDate>Tue, 01 Sep 2015 00:00:00 +0000</pubDate>
      <guid>https://strivefar.github.io/publication/journal-article/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Click the &lt;em&gt;Cite&lt;/em&gt; button above to demo the feature to enable visitors to import publication metadata into their reference management software.
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Click the &lt;em&gt;Slides&lt;/em&gt; button above to demo Academic&amp;rsquo;s Markdown slides feature.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Supplementary notes can be added here, including &lt;a href=&#34;https://sourcethemes.com/academic/docs/writing-markdown-latex/&#34;&gt;code and math&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An example conference paper</title>
      <link>https://strivefar.github.io/publication/conference-paper/</link>
      <pubDate>Mon, 01 Jul 2013 00:00:00 +0000</pubDate>
      <guid>https://strivefar.github.io/publication/conference-paper/</guid>
      <description>&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Click the &lt;em&gt;Cite&lt;/em&gt; button above to demo the feature to enable visitors to import publication metadata into their reference management software.
  &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Click the &lt;em&gt;Slides&lt;/em&gt; button above to demo Academic&amp;rsquo;s Markdown slides feature.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Supplementary notes can be added here, including &lt;a href=&#34;https://sourcethemes.com/academic/docs/writing-markdown-latex/&#34;&gt;code and math&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
