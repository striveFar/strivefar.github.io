<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>linux | YoungFar的个人博客——Love&amp;Share</title>
    <link>https://strivefar.github.io/tags/linux/</link>
      <atom:link href="https://strivefar.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    <description>linux</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><copyright>© 2005-2020版权所有[沪ICP备01234567号](http://www.beian.miit.gov.cn)</copyright><lastBuildDate>Mon, 06 Jul 2020 12:01:03 +0800</lastBuildDate>
    <image>
      <url>https://strivefar.github.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>linux</title>
      <link>https://strivefar.github.io/tags/linux/</link>
    </image>
    
    <item>
      <title>设备树语法</title>
      <link>https://strivefar.github.io/project/post/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Mon, 06 Jul 2020 12:01:03 +0800</pubDate>
      <guid>https://strivefar.github.io/project/post/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%AD%E6%B3%95/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E6%9D%BF%E5%AD%90%E5%90%AF%E5%8A%A8%E5%90%8E%E6%9F%A5%E7%9C%8B%E8%AE%BE%E5%A4%87%E6%A0%91&#34;&gt;1. 板子启动后查看设备树&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E&#34;&gt;1.1. 文件说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E7%BC%96%E8%AF%91%E5%8F%8D%E7%BC%96%E8%AF%91-%E8%AE%BE%E5%A4%87%E6%A0%91%E6%96%87%E4%BB%B6&#34;&gt;2. 编译/反编译 设备树文件&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-%E6%89%8B%E5%8A%A8%E7%BC%96%E8%AF%91&#34;&gt;2.1. 手动编译&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-%E5%9C%A8%E5%86%85%E6%A0%B8%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8B%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91&#34;&gt;2.2. 在内核根目录下自动编译&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#221-%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90&#34;&gt;2.2.1. 过程解析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E7%BB%99%E5%BC%80%E5%8F%91%E6%9D%BF%E6%9B%B4%E6%8D%A2%E8%AE%BE%E5%A4%87%E6%A0%91%E6%96%87%E4%BB%B6&#34;&gt;3. 给开发板更换设备树文件&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#31-%E6%9B%B4%E6%8D%A2%E6%96%B9%E6%B3%95&#34;&gt;3.1. 更换方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32-%E5%89%8D%E5%90%8E%E5%AF%B9%E6%AF%94&#34;&gt;3.2. 前后对比&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E5%8F%82%E8%80%83%E6%9D%A5%E6%BA%90&#34;&gt;4. 参考来源&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;1-板子启动后查看设备树&#34;&gt;1. 板子启动后查看设备树&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;注意：开发板中仅存放dtb 二进制文件，所以想直接查看开发板中的dts文件是查看不到的，需要先通过网络文件系统将开发板中dtb 二进制文件的copy到虚拟机，在虚拟机中反编译得到dts文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;板子启动后执行下面的命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ls /sys/firmware/
devicetree fdt
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;11-文件说明&#34;&gt;1.1. 文件说明&lt;/h2&gt;
&lt;p&gt;/sys/firmware/devicetree 目录下是以目录结构程现的 dtb 文件, 根节点对应 base 目录, 每一个节点对应一个目录, 每一个属性对应一个文件。&lt;/p&gt;
&lt;p&gt;这些属性的值如果是字符串，可以使用 cat 命令把它打印出来；对于数值可以用 hexdump 把它打印出来。&lt;/p&gt;
&lt;p&gt;还可以看到/sys/firmware/fdt 文件，它就是 dtb 格式的设备树文件，可以把它复制出来放到 ubuntu上，执行下面的命令反编译出来(-I dtb：输入格式是 dtb，-O dts：输出格式是 dts)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd 板子所用的内核源码目录

./scripts/dtc/dtc -I dtb -O dts /从板子上/复制出来的/fdt -o tmp.dts
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2-编译反编译-设备树文件&#34;&gt;2. 编译/反编译 设备树文件&lt;/h1&gt;
&lt;h2 id=&#34;21-手动编译&#34;&gt;2.1. 手动编译&lt;/h2&gt;
&lt;p&gt;内核目录下 scripts/dtc/dtc 是设备树的编译工具，直接使用它的话，包含其他文件时不能使用
“#include”，而必须使用“/incldue”。&lt;/p&gt;
&lt;p&gt;编译、反编译的示例命令如下，“-I”指定输入格式，“-O”指定输出格式，“-o”指定输出文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;./scripts/dtc/dtc -I dts -O dtb -o tmp.dtb arch/arm/boot/dts/xxx.dts // 编译 dts 为 dtb
./scripts/dtc/dtc -I dtb -O dts -o tmp.dts arch/arm/boot/dts/xxx.dtb // 反编译 dtb 为 dts
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;22-在内核根目录下自动编译&#34;&gt;2.2. 在内核根目录下自动编译&lt;/h2&gt;
&lt;p&gt;V=1 察看编译过程,不关心过程省略即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;make dtbs V=1

mkdir -p arch/arm/boot/dts/ ; 
arm-linux-gnueabihf-gcc -E 
 -Wp,-MD,arch/arm/boot/dts/.imx6ull-14x14-ebf-mini.dtb.d.pre.tmp 
 -nostdinc 
 -I./arch/arm/boot/dts 
 -I./arch/arm/boot/dts/include 
 -I./drivers/of/testcase-data 
 -undef -D__DTS__ -x assembler-with-cpp 
 -o arch/arm/boot/dts/.imx6ull-14x14-ebf-mini.dtb.dts.tmp 
 arch/arm/boot/dts/imx6ull-14x14-ebf-mini.dts ; 
 
./scripts/dtc/dtc -O dtb 
 -o arch/arm/boot/dts/imx6ull-14x14-ebf-mini.dtb
 -b 0 -i arch/arm/boot/dts/ -Wno-unit_address_vs_reg 
 -d arch/arm/boot/dts/.imx6ull-14x14-ebf-mini.dtb.d.dtc.tmp 
 arch/arm/boot/dts/.imx6ull-14x14-ebf-mini.dtb.dts.tmp ;

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;221-过程解析&#34;&gt;2.2.1. 过程解析&lt;/h3&gt;
&lt;p&gt;它首先用 arm-linux-gnueabihf-gcc 预处理 dts 文件，把其中的.h 头文件包含进来，把宏展开。&lt;/p&gt;
&lt;p&gt;然后使用 scripts/dtc/dtc 生成 dtb 文件。&lt;/p&gt;
&lt;p&gt;可见，dts 文件之所以支持“#include”语法，是因为 arm-linux-gnueabihf-gcc 帮忙。&lt;/p&gt;
&lt;p&gt;如果只用 dtc 工具，它是不支持”#include”语法的，只支持“/include”语法。&lt;/p&gt;
&lt;h1 id=&#34;3-给开发板更换设备树文件&#34;&gt;3. 给开发板更换设备树文件&lt;/h1&gt;
&lt;h2 id=&#34;31-更换方法&#34;&gt;3.1. 更换方法&lt;/h2&gt;
&lt;p&gt;对于 100ask-am335x 单板
设备树文件是：内核源码目录中 arch/arm/boot/dts/100ask-am335x.dtb
要更换板子上的设备树文件，启动板子后，更换这个文件：/boot/mx6ull-14x14-ebf.dtb&lt;/p&gt;
&lt;p&gt;对于 firefly-rk3288
设备树文件是：内核源码目录中 arch/arm/boot/dts/rk3288-firefly.dtb
对于这款板子，本教程中我们使用 SD 卡上的系统。
要更换板上的设备树文件，你可以使用 SD 卡启动开发板后，更换这个文件：/boot/rk3288-firefly.dtb&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在虚拟机中：先搜索dts文件
&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/%E6%90%9C%E7%B4%A2%E5%AD%90%E7%9B%AE%E5%BD%95.png&#34; alt=&#34;搜索子目录&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后更改：
&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB1.png&#34; alt=&#34;转换关系1&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在内核源码目录中编译dts得到dtb文件，然后通过网络传输一下：
&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/%E6%9B%B4%E6%96%B0%E8%AE%BE%E5%A4%87%E6%A0%911.png&#34; alt=&#34;更新设备树1&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在开发板中（串口操作）
&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/%E6%9B%B4%E6%96%B0%E8%AE%BE%E5%A4%87%E6%A0%91.png&#34; alt=&#34;更新设备树&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;32-前后对比&#34;&gt;3.2. 前后对比&lt;/h2&gt;
&lt;p&gt;我们来看一下，内核是如何解析设备树文件的（有待补充）
&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB1.png&#34; alt=&#34;转换关系1&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB2.png&#34; alt=&#34;转换关系2&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;4-参考来源&#34;&gt;4. 参考来源&lt;/h1&gt;
&lt;p&gt;本文参考了并学习了韦东山老师的视频和配套的文档，特此感谢&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>总线设备驱动模型</title>
      <link>https://strivefar.github.io/project/post/%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sun, 05 Jul 2020 00:04:17 +0800</pubDate>
      <guid>https://strivefar.github.io/project/post/%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;p&gt;绘制思维导图如下：
&lt;img src=&#34;https://strivefar.github.io/img/%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/LED%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E9%80%9A%E7%94%A8%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6300%25.png&#34; alt=&#34;xmind&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>动态编译和静态编译——制作动态库和静态库</title>
      <link>https://strivefar.github.io/project/post/getting-started/</link>
      <pubDate>Wed, 13 May 2020 00:00:00 +0000</pubDate>
      <guid>https://strivefar.github.io/project/post/getting-started/</guid>
      <description>&lt;h1 id=&#34;参考链接&#34;&gt;参考链接&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;http://c.biancheng.net/view/2385.html&#34;&gt;GCC生成动态链接库（.so文件）：-shared和-fPIC选项&lt;/a&gt;
&lt;a href=&#34;http://c.biancheng.net/view/7168.html&#34;&gt;GCC创建和使用静态链接库（.a文件）&lt;/a&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1ZT4y137Ba?from=search&amp;amp;seid=5456022104877118795&#34;&gt;gcc的使用方法；动态编译和静态编译；Linux制作动态库和静态库&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;命名规则&#34;&gt;命名规则&lt;/h1&gt;
&lt;p&gt;静态库命名规则如下：
&lt;strong&gt;libxxx.o&lt;/strong&gt;
&lt;strong&gt;lib&lt;/strong&gt;:前缀
&lt;strong&gt;.o&lt;/strong&gt;:静态库
动态链接库（shared object file，共享对象文件）命名规则如下：
&lt;strong&gt;libxxx.so&lt;/strong&gt;
&lt;strong&gt;lib&lt;/strong&gt;:前缀
&lt;strong&gt;.so&lt;/strong&gt;:动态库&lt;/p&gt;
&lt;h1 id=&#34;静态库参数&#34;&gt;静态库参数&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503195703920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;gcc-常用编译选项&#34;&gt;gcc 常用编译选项&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503200518148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;动态库和静态库的对比&#34;&gt;动态库和静态库的对比&lt;/h1&gt;
&lt;p&gt;我们先来说一下静态库；
Linux下的静态库是以.a结尾的二进制文件，它作为一个程序的模块，它在链接期间就被组合到了程序中，比如说我有一个主程序mian.c，那么我把它和静态库链接的时候，它就直接把这个静态库组合到了我的main.c里面生成的一个二进制文件.a。
而与静态链接库相对的是动态链接库，同样的是把主函数mian.c和动态库进行链接，与静态库不同的是,这个动态库在程序运行的阶段才会被加载进内存,参与主函数运行
下面用几张图来说明一下：
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503132421885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503195153959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;tr&gt;&lt;td bgcolor=orange&gt;还可以加上-static选项，让链接静态库后的math.out彻底的独立起来，“完全静态”&lt;/td&gt;&lt;/tr&gt;，因此，得到的二进制文件会非常大。
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503133250379.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503133154266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503132624143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;使用静态动态链接库的优缺点&#34;&gt;使用静态/动态链接库的优缺点：&lt;/h1&gt;
&lt;h3 id=&#34;静态库&#34;&gt;静态库：&lt;/h3&gt;
&lt;p&gt;编译后的执行程序不需要外部的函数库支持，&lt;strong&gt;因为所有使用的函数都经被编译进去了&lt;/strong&gt;。当然这也会成为他的缺点，因为如果&lt;strong&gt;静态函数库改变&lt;/strong&gt;了，那么你的程序必须&lt;strong&gt;重新编译&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;静态库的代码在编译时链接到应用程序中，因此&lt;strong&gt;编译时库文件必须存在并且需要通过“-L”参数传递给编译器&lt;/strong&gt;，应用程序在开始执行时，库函数代码将随程序一 起调入进程内存段直到进程结束，其执行过程不需要原静态库存在。&lt;/p&gt;
&lt;h3 id=&#34;动态库&#34;&gt;动态库：&lt;/h3&gt;
&lt;p&gt;动态函数库在编译的时候&lt;strong&gt;并没有&lt;/strong&gt;被编译进目标代码中，你的程序&lt;strong&gt;执行到相关函数时才调用该函数库里的相应函数&lt;/strong&gt;，因此动态函数库所产生的可执行文件比较&lt;strong&gt;小&lt;/strong&gt;。由于函数库没有被整合进你的程序，而是程序运行时动态的申请并调用，所以程序的&lt;strong&gt;运行环境中必须提供相应的库&lt;/strong&gt;。动态函数库的改变并不影响你的程序，所以动态函数库的&lt;strong&gt;升级比较方便&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不同的INIX系统链接动态库方法，实现细节不一样，编译PIC型.o中间文件的方法一般是采用C语言编译器的-KPIC或者 -fPIC选项
&lt;strong&gt;最主要的是GCC命令行的一个选项:&lt;/strong&gt;
&lt;strong&gt;-shared&lt;/strong&gt;:该选项指定&lt;strong&gt;生成动态连接库&lt;/strong&gt;(让连接器生成T类型的导出符号表，有时候也生成弱连接W类
型的导出符号) ,不用该标志外部程序无法连接。相当于一个可执行文件
&lt;strong&gt;-fPIC&lt;/strong&gt;:表示编译为&lt;strong&gt;位置独立&lt;/strong&gt;的代码，不用此选项的话编译后的代码是位置相关的,所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。&lt;/p&gt;
&lt;h1 id=&#34;制作链接库的目的商业角度&#34;&gt;制作链接库的目的（商业角度）：&lt;/h1&gt;
&lt;p&gt;这就和&lt;strong&gt;商业&lt;/strong&gt;项目挂钩了:
假如我们是一个项目的外包方，我们是有专利的，&lt;strong&gt;希望别人使用我们已经实现的功能，但又不希望别人看到我们的源代码&lt;/strong&gt;，所以这对商业机构是非常友好的。&lt;/p&gt;
&lt;h1 id=&#34;makefile中的使用实例&#34;&gt;Makefile中的使用实例：&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503143928633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503144212953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
