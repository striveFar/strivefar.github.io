<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>IMX6ULL | YoungFar的个人博客——Love&amp;Share</title>
    <link>https://strivefar.github.io/tags/imx6ull/</link>
      <atom:link href="https://strivefar.github.io/tags/imx6ull/index.xml" rel="self" type="application/rss+xml" />
    <description>IMX6ULL</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><lastBuildDate>Fri, 01 Jan 2021 20:32:13 +0800</lastBuildDate>
    <image>
      <url>https://strivefar.github.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>IMX6ULL</title>
      <link>https://strivefar.github.io/tags/imx6ull/</link>
    </image>
    
    <item>
      <title>Framebuffer中英文混合输出</title>
      <link>https://strivefar.github.io/project/post/framebuffer%E4%B8%AD%E8%8B%B1%E6%96%87%E6%B7%B7%E5%90%88%E8%BE%93%E5%87%BA/</link>
      <pubDate>Fri, 01 Jan 2021 20:32:13 +0800</pubDate>
      <guid>https://strivefar.github.io/project/post/framebuffer%E4%B8%AD%E8%8B%B1%E6%96%87%E6%B7%B7%E5%90%88%E8%BE%93%E5%87%BA/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-lcd%E8%8B%B1%E6%96%87%E8%BE%93%E5%87%BA&#34;&gt;1. LCD英文输出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-lcd-%E4%B8%AD%E6%96%87%E8%BE%93%E5%87%BA&#34;&gt;2. LCD 中文输出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-lcd%E4%B8%AD%E8%8B%B1%E6%96%87%E6%B7%B7%E5%90%88%E8%BE%93%E5%87%BAansi%E7%BC%96%E7%A0%81ascii%E7%A0%81&#34;&gt;3. LCD中英文混合输出（ANSI编码+ASCII码)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E8%B0%83%E7%94%A8&#34;&gt;4. 调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%E4%B8%8E%E7%BC%96%E8%AF%91%E6%A0%BC%E5%BC%8F&#34;&gt;5. 编译程序——编码格式与编译格式&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#51-%E6%8C%87%E5%AE%9A%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F&#34;&gt;5.1. 指定编码格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#52-%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4&#34;&gt;5.2. 编译命令：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#53-makefile%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9&#34;&gt;5.3. Makefile中指定编译选项&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-%E6%98%BE%E7%A4%BA%E6%95%88%E6%9E%9C&#34;&gt;6. 显示效果&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-%E6%9C%AC%E8%8A%82%E5%85%A8%E9%83%A8%E4%BB%A3%E7%A0%81gitee%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80&#34;&gt;7. 本节全部代码gitee仓库地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5&#34;&gt;8. 参考链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;1-lcd英文输出&#34;&gt;1. LCD英文输出&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/**********************************************************************
 * 函数名称： lcd_put_ascii
 * 功能描述： 在LCD指定位置上显示一个8*16的字符
 * 输入参数： x坐标，y坐标，c:ascii码, disp_color字符颜色， bak_grd_color背景颜色
 * 输出参数： 无
 * 返 回 值： 无
 * 修改日期        版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2020/05/12	     V1.0	  zh(angenao)	      创建
 ***********************************************************************/ 
    void lcd_put_ascii(int x, int y, char c, unsigned int disp_color, unsigned int bak_grd_color)
    {
        unsigned int i, j;
    
        const unsigned char *dots = &amp;amp;fontdata_8x16[c*16];
    
        unsigned char data, bit;
        for(j = y; j &amp;lt; y+16; j++ )
        {
            data = *dots++;
            bit = 7;
            
            for(i = x; i &amp;lt; x+8; i++)
            {
                /* 根据点阵的某位决定是否描颜色 */
                if(data &amp;amp; (1 &amp;lt;&amp;lt; bit) &amp;amp;&amp;amp; (j &amp;lt; var.yres)) 
                    lcd_put_pixel(i, j, disp_color);/* 字符颜色 */
                
                else if ((j &amp;lt; var.yres))
                    lcd_put_pixel(i, j, bak_grd_color);/* 背景色 */
                bit--;
            }
        }
        
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2-lcd-中文输出&#34;&gt;2. LCD 中文输出&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/**********************************************************************
 * 函数名称： lcd_put_chinese
 * 功能描述： 在LCD指定位置上显示一个16*16的汉字
 * 输入参数： x坐标，y坐标，str中文字符串，disp_color字符颜色， bak_grd_color背景颜色
 * 输出参数： 无
 * 返 回 值： 无
 * 修改日期        版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2020/05/12	     V1.0	  zh(angenao)	      创建
 ***********************************************************************/ 
void lcd_put_chinese(int x, int y, unsigned char *str, unsigned int disp_color, unsigned int bak_grd_color)
{
	unsigned int area  = str[0] - 0xA1;
	unsigned int where = str[1] - 0xA1;
	unsigned char *dots = hzkmem + (area * 94 + where)*32;
	unsigned char byte;

	int i, j, b;
	for (i = 0; i &amp;lt; 16; i++)
		for (j = 0; j &amp;lt; 2; j++)
		{
			byte = dots[i*2 + j];
			for (b = 7; b &amp;gt;=0; b--)
                /* 对x做限制 */
			{
				if (byte &amp;amp; (1&amp;lt;&amp;lt;b) &amp;amp;&amp;amp; (y+i) &amp;lt; var.yres)
				{
					/* show */
					lcd_put_pixel(x+j*8+7-b, y+i, disp_color); /* 字符颜色 */
				}
				else if (((y+i) &amp;lt; var.yres))
				{
					/* hide */
					lcd_put_pixel(x+j*8+7-b, y+i, bak_grd_color); /* 背景色 */
				}	
			}
		}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3-lcd中英文混合输出ansi编码ascii码&#34;&gt;3. LCD中英文混合输出（ANSI编码+ASCII码)&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
/**********************************************************************
 * 函数名称： lcd_put_mix_str
 * 功能描述： 在LCD指定位置输出混合的中英文字符，比如“中国china”，支持自动换行,优化了边框显示，使所有字符显示完整。
 * 输入参数： x坐标，y坐标，str中英文混合字符串，disp_color字符颜色， bak_grd_color背景颜色
 * 输出参数： 无
 * 返 回 值： 无
 * 修改日期        版本号     修改人	      修改内容
 * -----------------------------------------------
 * 2021/01/01	     V1.0	  youngfar	      创建
 ***********************************************************************/
void lcd_put_mix_str(int x, int y, unsigned char *str, unsigned int disp_color, unsigned int bak_grd_color)

{
    unsigned char *p = str;
    unsigned int pixel = 0, j = 0, i = 0;
    unsigned char *tmp = (unsigned char *)malloc(sizeof(unsigned char) * ANSI + 1);
    memset(tmp, &#39;\0&#39;, sizeof(unsigned char) * ANSI + 1);

    /* j &amp;lt;= (var.yres - 16)：对边框显示做处理,字符是8X16或16X16的像素面积，当(i,j)落在距离屏幕底部的像素距离&amp;lt;16时，字符会显示不全，即便显示全也会访问越界出现段错误，此时停止显示 */
    for (i = (x + pixel) % var.xres, j = y + 16 * ((x + pixel) / var.xres); *p != &#39;\0&#39; &amp;amp;&amp;amp; j &amp;lt;= (var.yres - 16); i = (x + pixel) % var.xres, j = y + 16 * ((x + pixel) / var.xres))
    {

        if (!((*p) &amp;gt;&amp;gt; 7) &amp;amp; 1)
        {

            /* 调试时用，显示打印在屏幕上的字符 */
            //printf(&amp;quot;%c&amp;quot;, *p);

            /* 对边框做处理,ASCII字符是8X16的像素面积，当(i,j)落在距离屏幕右下角8X16的像素面积内时，字符会显示不全，即便显示全也会访问越界出现段错误，此时停止显示 */
            if (i &amp;lt;= var.xres - BORDER_WIDTH_ASCII)
                lcd_put_ascii(i, j, *p++, disp_color, bak_grd_color); /*在屏幕中间显示8*16的字母A*/
            pixel += 8;
        }
        else
        {
            memcpy(tmp, p, sizeof(unsigned char) * ANSI);
            p = p + ANSI;

            /* 对边框做处理,中文字符是16X16的像素面积，当(i,j)落在距离屏幕右下角16X16的像素面积内时，字符会显示不全，即便显示全也会访问越界出现段错误，此时停止显示 */
            if (i &amp;lt;= var.xres - BORDER_WIDTH_ANSI)
                lcd_put_chinese(i, j, tmp, disp_color, bak_grd_color);
            pixel += 16;

            /* 调试时用，显示打印在屏幕上的字符 */
            //printf(&amp;quot;chinese code: %02x %02x\n&amp;quot;, tmp[0], tmp[1]);
        }
    }
    free(tmp);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;4-调用&#34;&gt;4. 调用&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main(int argc, char **argv)
{

    unsigned char str[] =&amp;quot;对边框做处理,ASCII字符是8X16的像素面积，当(i,j)落在距离屏幕右下角8X16的像素面积内时，字符会显示不全，即便显示全也会访问越界,出现段错误，此时停止显示&amp;quot;;
	fd_fb = open(&amp;quot;/dev/fb0&amp;quot;, O_RDWR);
	if (fd_fb &amp;lt; 0)
	{
		printf(&amp;quot;can&#39;t open /dev/fb0\n&amp;quot;);
		return -1;
	}

	if (ioctl(fd_fb, FBIOGET_VSCREENINFO, &amp;amp;var))
	{
		printf(&amp;quot;can&#39;t get var\n&amp;quot;);
		return -1;
	}

	line_width  = var.xres * var.bits_per_pixel / 8;
	pixel_width = var.bits_per_pixel / 8;
	screen_size = var.xres * var.yres * var.bits_per_pixel / 8;
	fbmem = (unsigned char *)mmap(NULL , screen_size, PROT_READ | PROT_WRITE, MAP_SHARED, fd_fb, 0);
	if (fbmem == (unsigned char *)-1)
	{
		printf(&amp;quot;can&#39;t mmap\n&amp;quot;);
		return -1;
	}

	fd_hzk16 = open(&amp;quot;HZK16&amp;quot;, O_RDONLY);
	if (fd_hzk16 &amp;lt; 0)
	{
		printf(&amp;quot;can&#39;t open HZK16\n&amp;quot;);
		return -1;
	}
    /* 由文件描述符获取文件信息到hzk_stat结构体。http://c.biancheng.net/cpp/html/314.html */
	if(fstat(fd_hzk16, &amp;amp;hzk_stat))
	{
		printf(&amp;quot;can&#39;t get fstat\n&amp;quot;);
		return -1;
	}
	hzkmem = (unsigned char *)mmap(NULL , hzk_stat.st_size, PROT_READ, MAP_SHARED, fd_hzk16, 0);
	if (hzkmem == (unsigned char *)-1)
	{
		printf(&amp;quot;can&#39;t mmap for hzk16\n&amp;quot;);
		return -1;
	}

	/* 清屏: 全部设为黑色 */
	memset(fbmem, 0, screen_size);
    
    /* 在LCD指定位置上显示黑色的中英文混合字符串（背景色为护眼绿） */
	lcd_put_mix_str(0, var.yres-16, str, black, Green_bean);
    
	munmap(fbmem , screen_size);
	close(fd_fb);

    /* 撤销定义，防止冲突 */
    #undef ANSI
    #undef black
    #undef Green_bean
    #undef tangerine
    
	return 0;	
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5-编译程序编码格式与编译格式&#34;&gt;5. 编译程序——编码格式与编译格式&lt;/h1&gt;
&lt;h2 id=&#34;51-指定编码格式&#34;&gt;5.1. 指定编码格式&lt;/h2&gt;
&lt;p&gt;使用点阵字库时，中文字符的显示原理跟ASCII字符是一样的。要注意的地方在于中文的编码：在C源文件中它的编码方式是GB2312还是UTF-8？编译出的可执行程序，其中的汉字编码方式是GB2312还是UTF-8？
注意：一般不会使用UTF-16的编码方式，在这种方式下ASCII字符也是用2字节来表示，而其中一个字节是0，但是在C语言中0表示字符串的结束符，会引起误会。
我们编写C程序时，可以使用ANSI编码，或是UTF-8编码；在编译程序时，可以使用以下的选项告诉编译器：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-finput-charset=GB2312&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-finput-charset=UTF-8&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果不指定“-finput-charset”，&lt;code&gt;GCC就会默认C程序的编码方式为UTF-8，即使你是以ANSI格式保存，也会被当作UTF-8来对待。&lt;/code&gt;
对于编译出来的可执行程序，可以指定它里面的字符是以什么方式编码，可以使用以下的选项编译器：
-fexec-charset=GB2312
-fexec-charset=UTF-8
如果不指定“-fexec-charset”，GCC就会默认编译出的可执行程序中字符的编码方式为UTF-8。&lt;/p&gt;
&lt;p&gt;如果“-finput-charset”与“-fexec-charset”不一样，编译器会进行格式转换。&lt;/p&gt;
&lt;h2 id=&#34;52-编译命令&#34;&gt;5.2. 编译命令：&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;arm-linux-gnueabihf-gcc  -o  show_chinese  show_chinese.c&lt;/code&gt;
注意：不同的板子，编译工具的前缀可能不一样。
注意：使用上述命令时show_chinese.c的编码格式必须是ANSI(GB2312)，否则编译时需要指定&lt;code&gt;-fexec-charset=GB2312&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;53-makefile中指定编译选项&#34;&gt;5.3. Makefile中指定编译选项&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# finput:即使以ANSI格式保存，也会被当作UTF-8来对待; 指定可执行程序中的字符以ANSI方式编码。
CFLAGS := -Wall -O2 -g -finput-charset=UTF-8 -fexec-charset=GB2312
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;6-显示效果&#34;&gt;6. 显示效果&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://strivefar.github.io/img/%E4%B8%AD%E8%8B%B1%E6%96%87%E6%B7%B7%E5%90%88%E8%BE%93%E5%87%BA/display.jpg&#34; alt=&#34;display&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;7-本节全部代码gitee仓库地址&#34;&gt;7. 本节全部代码gitee仓库地址&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://gitee.com/youngfar/imx6ull/tree/master/%E9%9F%A6%E4%B8%9C%E5%B1%B1/%E5%BA%94%E7%94%A8%E5%9F%BA%E7%A1%80/09_show_chinese&#34;&gt;点此进入本节gitee仓库&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;8-参考链接&#34;&gt;8. 参考链接&lt;/h1&gt;
&lt;p&gt;1.韦东山老师的嵌入式视频&lt;/p&gt;
&lt;p&gt;2.&lt;a href=&#34;http://c.biancheng.net/cpp/html/314.html&#34;&gt;由文件描述符获取文件信息到hzk_stat结构体&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;a href=&#34;https://www.cnblogs.com/malecrab/p/5300486.html&#34;&gt;ANSI是什么编码？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;特此感谢！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>设备树详解</title>
      <link>https://strivefar.github.io/project/post/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3-imx6ull/</link>
      <pubDate>Thu, 16 Jul 2020 18:00:59 +0800</pubDate>
      <guid>https://strivefar.github.io/project/post/%E8%AE%BE%E5%A4%87%E6%A0%91%E8%AF%A6%E8%A7%A3-imx6ull/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-device-tree%E7%AE%80%E4%BB%8B&#34;&gt;1. Device Tree简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-device-tree%E7%BC%96%E8%AF%91&#34;&gt;2. Device Tree编译&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-device-tree%E5%A4%B4%E4%BF%A1%E6%81%AF&#34;&gt;3. Device Tree头信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-dtb%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84&#34;&gt;4. DTB文件结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-kernel%E8%A7%A3%E6%9E%90device-tree&#34;&gt;5. kernel解析Device Tree&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-platform_device%E5%92%8Cdevice_node%E7%BB%91%E5%AE%9A&#34;&gt;6. platform_device和device_node绑定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-i2c_client%E5%92%8Cdevice_node%E7%BB%91%E5%AE%9A&#34;&gt;7. i2c_client和device_node绑定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8-device_tree%E4%B8%8Esysfs&#34;&gt;8. Device_Tree与sysfs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9-%E7%89%B9%E6%AD%A4%E6%84%9F%E8%B0%A2&#34;&gt;9. 特此感谢&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#内核对设备树的处理
dts在PC 上被编译为.dtb文件；
uboot把dtb文件传给内核；
内核解析dtb 文件，把每一个节点都转换为 device_node 结构体；
对于某些device_node结构体，会被转换为platform_device结构体。&lt;/p&gt;
&lt;h1 id=&#34;1-device-tree简介&#34;&gt;1. Device Tree简介&lt;/h1&gt;
&lt;p&gt;Linus Torvalds在2011年3月17日的ARM Linux邮件列表宣称“this whole ARM thing is a fucking pain in the ass”，引发ARM Linux社区的地震，随后ARM社区进行了一系列的重大修正。在过去的ARM Linux中，arch/arm/plat-xxx和arch/arm/mach-xxx中充斥着大量的垃圾代码，相当多数的代码只是在描述板级细节，而这些板级细节对于内核来讲，不过是垃圾，如板上的platform设备、resource、i2c_board_info、spi_board_info以及各种硬件的platform_data。 社区必须改变这种局面，于是PowerPC等其他体系架构下已经使用的Flattened Device Tree（FDT）进入ARM社区的视野。Device Tree是一种描述硬件的数据结构，它起源于OpenFirmware(OF)。在Linux2.6中，ARM架构的板极硬件细节过多地被硬编码在arch/arm/plat-xxx和arch/arm/mach-xxx，采用Device Tree后，许多硬件的细节可以直接透过它传递给Linux，而不再需要在kernel中进行大量的冗余编码。&lt;/p&gt;
&lt;p&gt;Device Tree由一系列被命名的结点（node）和属性（property）组成，而结点本身可包含子结点。所谓属性，其实就是成对出现的name和value。在Device Tree中，可描述的信息包括（原先这些信息大多被hard code到kernel中）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU的数量和类别&lt;/li&gt;
&lt;li&gt;内存基地址和大小&lt;/li&gt;
&lt;li&gt;总线和桥&lt;/li&gt;
&lt;li&gt;外设连接&lt;/li&gt;
&lt;li&gt;中断控制器和中断使用情况&lt;/li&gt;
&lt;li&gt;GPIO控制器和GPIO使用情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它基本上就是画一棵电路板上CPU、总线、设备组成的树，Bootloader会将这棵树传递给内核，然后内核可以识别这棵树，并根据它展开出Linux内核中的platform_device、i2c_client、spi_device等设备。这些设备用到的内存、IRQ等资源，也被传递给了kernel，kernel会将这些资源绑定给展开的相应的设备。&lt;/p&gt;
&lt;h1 id=&#34;2-device-tree编译&#34;&gt;2. Device Tree编译&lt;/h1&gt;
&lt;p&gt;Device Tree文件的格式为dts，包含的头文件格式为dtsi，dts文件是一种人可以看懂的编码格式。但是uboot和linux不能直接识别，他们只能识别二进制文件，所以需要把dts文件编译成dtb文件。dtb文件是一种可以被kernel和uboot识别的二进制文件。把dts编译成dtb文件的工具是dtc。Linux源码目录下scripts/dtc目录包含dtc工具的源码。在Linux的scripts/dtc目录下除了提供dtc工具外，也可以自己安装dtc工具，linux下执行：sudo apt-get install device-tree-compiler安装dtc工具。其中还提供了一个fdtdump的工具，可以反编译dtb文件。dts和dtb文件的转换如图1所示。&lt;/p&gt;
&lt;p&gt;dtc工具的使用方法是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dtc –I dts –O dtb –o xxx.dtb xxx.dts
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即可生成dts文件对应的dtb文件了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/%E7%BC%96%E8%AF%91.jpg&#34; alt=&#34;编译&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-device-tree头信息&#34;&gt;3. Device Tree头信息&lt;/h1&gt;
&lt;p&gt;fdtdump工具使用，Linux终端执行ftddump –h，输出以下信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;fdtdump -h
Usage: fdtdump [options]
Options: -[dshV]
-d, –debug Dump debug information while decoding the file
-s, –scan Scan for an embedded fdt in file
-h, –help Print this help and exit
-V, –version Print version and exit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本文采用s5pv21_smc.dtb文件为例说明fdtdump工具的使用。Linux终端执行fdtdump –sd s5pv21_smc.dtb &amp;gt; s5pv21_smc.txt，打开s5pv21_smc.txt文件，部分输出信息如下所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;// magic: 0xd00dfeed
// totalsize: 0xce4 (3300)
// off_dt_struct: 0x38
// off_dt_strings: 0xc34
// off_mem_rsvmap: 0x28
// version: 17
// last_comp_version: 16
// boot_cpuid_phys: 0x0
// size_dt_strings: 0xb0
// size_dt_struct: 0xbfc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上信息便是Device Tree文件头信息，存储在dtb文件的开头部分。&lt;/p&gt;
&lt;p&gt;在Linux内核中使用struct fdt_header结构体描述。struct fdt_header结构体定义在scripts\dtc\libfdt\fdt.h文件中。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct fdt_header {
    fdt32_t magic;               /* magic word FDT_MAGIC */
    fdt32_t totalsize;           /* total size of DT block */
    fdt32_t off_dt_struct;       /* offset to structure */
    fdt32_t off_dt_strings;      /* offset to strings */
    fdt32_t off_mem_rsvmap;      /* offset to memory reserve map */
    fdt32_t version;                 /* format version */
    fdt32_t last_comp_version;   /* last compatible version */

    /* version 2 fields below */
    fdt32_t boot_cpuid_phys;     /* Which physical CPU id we&#39;re booting on */
    /* version 3 fields below */
    fdt32_t size_dt_strings;     /* size of the strings block */

    /* version 17 fields below */
    fdt32_t size_dt_struct;      /* size of the structure block */
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;fdtdump工具的输出信息即是以上结构中每一个成员的值，struct fdt_header结构体包含了Device Tree的私有信息。例如: fdt_header.magic是fdt的魔数,固定值为0xd00dfeed，fdt_header.totalsize是fdt文件的大小。使用二进制工具打开s5pv21_smc.dtb验证。s5pv21_smc.dtb二进制文件头信息如图2所示。从图2中可以得到Device Tree的文件是以大端模式储存。并且，头部信息和fdtdump的输出信息一致。&lt;/p&gt;
&lt;p&gt;Device Tree中的节点信息举例如下所示。
&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/node.png&#34; alt=&#34;编译&#34;&gt;&lt;/p&gt;
&lt;p&gt;上述.dts文件并没有什么真实的用途，但它基本表征了一个Device Tree源文件的结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1个root结点“ &lt;strong&gt;/&lt;/strong&gt; ”；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;root结点下面含一系列子结点，本例中为“&lt;strong&gt;node@0&lt;/strong&gt;”和“&lt;strong&gt;node@1&lt;/strong&gt;”；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结点“node@0”下又含有一系列子结点，本例中为“ &lt;strong&gt;child-node@0&lt;/strong&gt; ”；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各结点都有一系列属性：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;这些属性可能为空，如“ &lt;strong&gt;an-empty-property&lt;/strong&gt;”；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;可能为字符串，如“&lt;strong&gt;a-string-property&lt;/strong&gt;”；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;可能为字符串序列，如“&lt;strong&gt;a-string-list-property&lt;/strong&gt;”；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;可能为Cells（&lt;code&gt;由u32整数组成，用尖括号括起来&lt;/code&gt;），如“&lt;strong&gt;second-child-property&lt;/strong&gt;”；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;可能为字节数据，（&lt;code&gt;每个byte用2个16进制数表示，用“[]”括起来&lt;/code&gt;）如“&lt;strong&gt;a-byte-data-property&lt;/strong&gt;”。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Device Tree源文件的结构分为header、fill_area、dt_struct及dt_string四个区域。header为头信息，fill_area为填充区域，填充数字0，dt_struct存储节点数值及名称相关信息，dt_string存储属性名。例如：a-string-property就存储在dt_string区，”A string”及node1就存储在dt_struct区域。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;我们可以给一个设备节点添加lable，之后可以通过&amp;amp;lable的形式访问这个lable&lt;/code&gt;，这种引用是通过phandle（pointer handle）进行的。例如，图3中的&lt;strong&gt;node1&lt;/strong&gt;就是一个lable，node@0的子节点child-node@0通过&lt;strong&gt;&amp;lt;&amp;amp;node1&amp;gt;&lt;/strong&gt;引用node@1节点。像是这种phandle的节点，在经过DTC工具编译之后，&amp;amp;node1会变成一个特殊的整型数字n，假设n值为1，那么在node@1节点下自动生成两个属性，属性如下：
linux,phandle = &amp;lt;0x00000001&amp;gt;;
phandle = &amp;lt;0x00000001&amp;gt;;
node@0的子节点child-node@0中的a-reference-to-something = &amp;lt;&amp;amp;node1&amp;gt;会变成a-reference-to-something = &amp;lt; 0x00000001&amp;gt;。此处0x00000001就是一个phandle得值，每一个phandle都有一个独一无二的整型值，在后续kernel中通过这个特殊的数字间接找到引用的节点。通过查看fdtdump输出信息以及dtb二进制文件信息，得到struct fdt_header和文件结构之间的关系信息如所示。&lt;/p&gt;
&lt;h1 id=&#34;4-dtb文件结构&#34;&gt;4. DTB文件结构&lt;/h1&gt;
&lt;p&gt;通过以上分析，可以得到Device Tree文件结构如图5所示。dtb的头部首先存放的是fdt_header的结构体信息，接着是填充区域，填充大小为off_dt_struct – sizeof(struct fdt_header)，填充的值为0。接着就是struct fdt_property结构体的相关信息。最后是dt_string部分。
&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/DTB.png&#34; alt=&#34;编译&#34;&gt;&lt;/p&gt;
&lt;p&gt;Device Tree源文件的结构分为header、fill_area、dt_struct及dt_string四个区域。fill_area区域填充数值0。节点（node）信息使用struct fdt_node_header结构体描述。属性信息使用struct fdt_property结构体描述。各个结构体信息如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct fdt_node_header {
    fdt32_t tag;
    char name[0];
};

struct fdt_property {
    fdt32_t tag;
    fdt32_t len;
    fdt32_t nameoff;
    char data[0];
};

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;struct fdt_node_header描述节点信息，tag是标识node的起始结束等信息的标志位，name指向node名称的首地址。tag的取值如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define FDT_BEGIN_NODE  0x1     /* Start node: full name */
#define FDT_END_NODE    0x2     /* End node */
#define FDT_PROP        0x3     /* Property: name off, size, content */
#define FDT_NOP         0x4     /* nop */
#define FDT_END         0x9

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;FDT_BEGIN_NODE和FDT_END_NODE标识node节点的起始和结束，FDT_PROP标识node节点下面的属性起始符，FDT_END标识Device Tree的结束标识符。因此，对于每个node节点的tag标识符一般为FDT_BEGIN_NODE，对于每个node节点下面的属性的tag标识符一般是FDT_PROP。&lt;/p&gt;
&lt;p&gt;描述属性采用struct fdt_property描述，tag标识是属性，取值为FDT_PROP；len为属性值的长度（包括‘\0’，单位：字节）；nameoff为属性名称存储位置相对于off_dt_strings的偏移地址。&lt;/p&gt;
&lt;p&gt;例如：compatible = “samsung,goni”, “samsung,s5pv210”;compatible是属性名称，”samsung,goni”, “samsung,s5pv210”是属性值。compatible属性名称字符串存放的区域是dt_string。”samsung,goni”, “samsung,s5pv210”存放的位置是fdt_property.data后面。因此fdt_property.data指向该属性值。fdt_property.tag的值为属性标识，len为属性值的长度（包括‘\0’，单位：字节）,此处len = 29。nameoff为compatible字符串的位置相对于off_dt_strings的偏移地址，即&amp;amp;compatible = nameoff + off_dt_strings。&lt;/p&gt;
&lt;p&gt;dt_struct在Device Tree中的结构如图6所示。节点的嵌套也带来tag标识符的嵌套。
&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/dt_struct.png&#34; alt=&#34;编译&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;5-kernel解析device-tree&#34;&gt;5. kernel解析Device Tree&lt;/h1&gt;
&lt;p&gt;Device Tree文件结构描述就以上struct fdt_header、struct fdt_node_header及struct fdt_property三个结构体描述。kernel会根据Device Tree的结构解析出kernel能够使用的struct property结构体。kernel根据Device Tree中所有的属性解析出数据填充struct property结构体。struct property结构体描述如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct property {
    char *name;                          /* property full name */
    int length;                          /* property value length */
    void *value;                         /* property value */
    struct property *next;             /* next property under the same node */
    unsigned long _flags;
    unsigned int unique_id;
    struct bin_attribute attr;        /* 属性文件，与sysfs文件系统挂接 */
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总的来说，kernel根据Device Tree的文件结构信息转换成struct property结构体，并将同一个node节点下面的所有属性通过property.next指针进行链接，形成一个单链表。
kernel中究竟是如何解析Device Tree的呢？下面分析函数解析过程。函数调用过程如图7所示。kernel的C语言阶段的入口函数是init/main.c/stsrt_kernel()函数，在early_init_dt_scan_nodes()中会做以下三件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;扫描/chosen或者/chose@0节点下面的bootargs属性值到boot_command_line，此外，还处理initrd相关的property，并保存在initrd_start和initrd_end这两个全局变量中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;扫描根节点下面，获取{size,address}-cells信息，并保存在dt_root_size_cells和dt_root_addr_cells全局变量中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;扫描具有device_type =“memory”属性的/memory或者/memory@0节点下面的reg属性值，并把相关信息保存在meminfo中，全局变量meminfo保存了系统内存相关的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB1.png&#34; alt=&#34;编译&#34;&gt;&lt;/p&gt;
&lt;p&gt;Device Tree中的每一个node节点经过kernel处理都会生成一个struct device_node的结构体，struct device_node最终一般会被挂接到具体的struct device结构体。struct device_node结构体描述如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct device_node {
    const char *name;              /* node的名称，取最后一次“/”和“@”之间子串 */
    const char *type;              /* device_type的属性名称，没有为&amp;lt;NULL&amp;gt; */
    phandle phandle;               /* phandle属性值 */
    const char *full_name;         /* 指向该结构体结束的位置，存放node的路径全名，例如：/chosen */
    struct fwnode_handle fwnode;

    struct  property *properties;  /* 指向该节点下的第一个属性，其他属性与该属性链表相接 */
    struct  property *deadprops;   /* removed properties */
    struct  device_node *parent;   /* 父节点 */
    struct  device_node *child;    /* 子节点 */
    struct  device_node *sibling;  /* 姊妹节点，与自己同等级的node */
    struct  kobject kobj;          /* sysfs文件系统目录体现 */
    unsigned long _flags;          /* 当前node状态标志位，见/include/linux/of.h line124-127 */
    void    *data;
};

/* flag descriptions (need to be visible even when !CONFIG_OF) */
#define OF_DYNAMIC        1 /* node and properties were allocated via kmalloc */
#define OF_DETACHED       2 /* node has been detached from the device tree*/
#define OF_POPULATED      3 /* device already created for the node */
#define OF_POPULATED_BUS  4 /* of_platform_populate recursed to children of this node */

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;struct device_node结构体中的每个成员作用已经备注了注释信息，下面分析以上信息是如何得来的。&lt;/p&gt;
&lt;p&gt;Device Tree的解析首先从unflatten_device_tree()开始，代码列出如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/**
 * unflatten_device_tree - create tree of device_nodes from flat blob
 *
 * unflattens the device-tree passed by the firmware, creating the
 * tree of struct device_node. It also fills the &amp;quot;name&amp;quot; and &amp;quot;type&amp;quot;
 * pointers of the nodes so the normal device-tree walking functions
 * can be used.
 */
void __init unflatten_device_tree(void)
{
	__unflatten_device_tree(initial_boot_params, NULL, &amp;amp;of_root,
				early_init_dt_alloc_memory_arch, false);

	/* Get pointer to &amp;quot;/chosen&amp;quot; and &amp;quot;/aliases&amp;quot; nodes for use everywhere */
	of_alias_scan(early_init_dt_alloc_memory_arch);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分析以上代码，在unflatten_device_tree()中，调用函数__unflatten_device_tree()，参数initial_boot_params指向Device Tree在内存中的首地址，of_root在经过该函数处理之后，会指向根节点，early_init_dt_alloc_memory_arch是一个函数指针，为struct device_node和struct property结构体分配内存的回调函数（callback）。&lt;/p&gt;
&lt;p&gt;在__unflatten_device_tree()函数中，两次调用unflatten_dt_node()函数，第一次是为了得到Device Tree转换成struct device_node和struct property结构体需要分配的内存大小，第二次调用才是具体填充每一个struct device_node和struct property结构体。__unflatten_device_tree()代码列出如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
/**
 * __unflatten_device_tree - create tree of device_nodes from flat blob
 *
 * unflattens a device-tree, creating the
 * tree of struct device_node. It also fills the &amp;quot;name&amp;quot; and &amp;quot;type&amp;quot;
 * pointers of the nodes so the normal device-tree walking functions
 * can be used.
 * @blob: The blob to expand
 * @dad: Parent device node
 * @mynodes: The device_node tree created by the call
 * @dt_alloc: An allocator that provides a virtual address to memory
 * for the resulting tree
 *
 * Returns NULL on failure or the memory chunk containing the unflattened
 * device tree on success.
 */
static void *__unflatten_device_tree(const void *blob,
				     struct device_node *dad,
				     struct device_node **mynodes,
				     void *(*dt_alloc)(u64 size, u64 align),
				     bool detached)
{
	int size;
	void *mem;

	pr_debug(&amp;quot; -&amp;gt; unflatten_device_tree()\n&amp;quot;);

	if (!blob) {
		pr_debug(&amp;quot;No device tree pointer\n&amp;quot;);
		return NULL;
	}

	pr_debug(&amp;quot;Unflattening device tree:\n&amp;quot;);
	pr_debug(&amp;quot;magic: %08x\n&amp;quot;, fdt_magic(blob));
	pr_debug(&amp;quot;size: %08x\n&amp;quot;, fdt_totalsize(blob));
	pr_debug(&amp;quot;version: %08x\n&amp;quot;, fdt_version(blob));

	if (fdt_check_header(blob)) {
		pr_err(&amp;quot;Invalid device tree blob header\n&amp;quot;);
		return NULL;
	}

	/* First pass, scan for size */
	size = unflatten_dt_nodes(blob, NULL, dad, NULL);
	if (size &amp;lt; 0)
		return NULL;

	size = ALIGN(size, 4);
	pr_debug(&amp;quot;  size is %d, allocating...\n&amp;quot;, size);

	/* Allocate memory for the expanded device tree */
	mem = dt_alloc(size + 4, __alignof__(struct device_node));
	if (!mem)
		return NULL;

	memset(mem, 0, size);

	*(__be32 *)(mem + size) = cpu_to_be32(0xdeadbeef);

	pr_debug(&amp;quot;  unflattening %p...\n&amp;quot;, mem);

	/* Second pass, do actual unflattening */
	unflatten_dt_nodes(blob, mem, dad, mynodes);
	if (be32_to_cpup(mem + size) != 0xdeadbeef)
		pr_warning(&amp;quot;End of tree marker overwritten: %08x\n&amp;quot;,
			   be32_to_cpup(mem + size));

	if (detached &amp;amp;&amp;amp; mynodes) {
		of_node_set_flag(*mynodes, OF_DETACHED);
		pr_debug(&amp;quot;unflattened tree is detached\n&amp;quot;);
	}

	pr_debug(&amp;quot; &amp;lt;- unflatten_device_tree()\n&amp;quot;);
	return mem;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;__unflatten_device_tree()代码列出如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
/**
 * unflatten_dt_nodes - Alloc and populate a device_node from the flat tree
 * @blob: The parent device tree blob
 * @mem: Memory chunk to use for allocating device nodes and properties
 * @dad: Parent struct device_node
 * @nodepp: The device_node tree created by the call
 *
 * It returns the size of unflattened device tree or error code
 */
static int unflatten_dt_nodes(const void *blob,
			      void *mem,
			      struct device_node *dad,
			      struct device_node **nodepp)
{
	struct device_node *root;
	int offset = 0, depth = 0, initial_depth = 0;
#define FDT_MAX_DEPTH	64
	unsigned int fpsizes[FDT_MAX_DEPTH];
	struct device_node *nps[FDT_MAX_DEPTH];
	void *base = mem;
	bool dryrun = !base;

	if (nodepp)
		*nodepp = NULL;

	/*
	 * We&#39;re unflattening device sub-tree if @dad is valid. There are
	 * possibly multiple nodes in the first level of depth. We need
	 * set @depth to 1 to make fdt_next_node() happy as it bails
	 * immediately when negative @depth is found. Otherwise, the device
	 * nodes except the first one won&#39;t be unflattened successfully.
	 */
	if (dad)
		depth = initial_depth = 1;

	root = dad;
	fpsizes[depth] = dad ? strlen(of_node_full_name(dad)) : 0;
	nps[depth] = dad;

	for (offset = 0;
	     offset &amp;gt;= 0 &amp;amp;&amp;amp; depth &amp;gt;= initial_depth;
	     offset = fdt_next_node(blob, offset, &amp;amp;depth)) {
		if (WARN_ON_ONCE(depth &amp;gt;= FDT_MAX_DEPTH))
			continue;

		fpsizes[depth+1] = populate_node(blob, offset, &amp;amp;mem,
						 nps[depth],
						 fpsizes[depth],
						 &amp;amp;nps[depth+1], dryrun);
		if (!fpsizes[depth+1])
			return mem - base;

		if (!dryrun &amp;amp;&amp;amp; nodepp &amp;amp;&amp;amp; !*nodepp)
			*nodepp = nps[depth+1];
		if (!dryrun &amp;amp;&amp;amp; !root)
			root = nps[depth+1];
	}

	if (offset &amp;lt; 0 &amp;amp;&amp;amp; offset != -FDT_ERR_NOTFOUND) {
		pr_err(&amp;quot;Error %d processing FDT\n&amp;quot;, offset);
		return -EINVAL;
	}

	/*
	 * Reverse the child list. Some drivers assumes node order matches .dts
	 * node order
	 */
	if (!dryrun)
		reverse_nodes(root);

	return mem - base;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过以上函数处理就得到了所有的struct device_node结构体，为每一个node都会自动添加一个名称为“name”的property，property.length的值为当前node的名称取最后一个“/”和“@”之间的子串（包括‘\0’）。例如：/serial@e2900800，则length = 7，property.value = device_node.name = “serial”。&lt;/p&gt;
&lt;h1 id=&#34;6-platform_device和device_node绑定&#34;&gt;6. platform_device和device_node绑定&lt;/h1&gt;
&lt;p&gt;经过以上解析，Device Tree的数据已经全部解析出具体的struct device_node和struct property结构体，下面需要和具体的device进行绑定。首先讲解platform_device和device_node的绑定过程。在arch/arm/kernel/setup.c文件中，customize_machine()函数负责填充struct platform_device结构体。函数调用过程如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/%E7%BB%91%E5%AE%9A.png&#34; alt=&#34;编译&#34;&gt;&lt;/p&gt;
&lt;p&gt;代码分析如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;
const struct of_device_id of_default_bus_match_table[] = {
    { .compatible = &amp;quot;simple-bus&amp;quot;, },
    { .compatible = &amp;quot;simple-mfd&amp;quot;, },
#ifdef CONFIG_ARM_AMBA
    { .compatible = &amp;quot;arm,amba-bus&amp;quot;, },
#endif /* CONFIG_ARM_AMBA */
    {} /* Empty terminated list */
};

int of_platform_populate(struct device_node *root,
            const struct of_device_id *matches,
            const struct of_dev_auxdata *lookup,
            struct device *parent)
{
    struct device_node *child;
    int rc = 0;

    /* 获取根节点 */
    root = root ? of_node_get(root) : of_find_node_by_path(&amp;quot;/&amp;quot;);
    if (!root)
        return -EINVAL;

    /* 为根节点下面的每一个节点创建platform_device结构体 */
    for_each_child_of_node(root, child) {
        rc = of_platform_bus_create(child, matches, lookup, parent, true);
        if (rc) {
            of_node_put(child);
            break;
        }
    }
    /* 更新device_node flag标志位 */
    of_node_set_flag(root, OF_POPULATED_BUS);

    of_node_put(root);
    return rc;
}

static int of_platform_bus_create(struct device_node *bus,
                  const struct of_device_id *matches,
                  const struct of_dev_auxdata *lookup,
                  struct device *parent, bool strict)
{
    const struct of_dev_auxdata *auxdata;
    struct device_node *child;
    struct platform_device *dev;
    const char *bus_id = NULL;
    void *platform_data = NULL;
    int rc = 0;

    /* 只有包含&amp;quot;compatible&amp;quot;属性的node节点才会生成相应的platform_device结构体 */
    /* Make sure it has a compatible property */
    if (strict &amp;amp;&amp;amp; (!of_get_property(bus, &amp;quot;compatible&amp;quot;, NULL))) {
        return 0;
    }
    /* 省略部分代码 */
    /* 
     * 针对节点下面得到status = &amp;quot;ok&amp;quot; 或者status = &amp;quot;okay&amp;quot;或者不存在status属性的
     * 节点分配内存并填充platform_device结构体
     */
    dev = of_platform_device_create_pdata(bus, bus_id, platform_data, parent);
    if (!dev || !of_match_node(matches, bus))
        return 0;

    /* 递归调用节点解析函数，为子节点继续生成platform_device结构体，前提是父节点
     * 的“compatible” = “simple-bus”，也就是匹配of_default_bus_match_table结构体中的数据
     */
    for_each_child_of_node(bus, child) {
        rc = of_platform_bus_create(child, matches, lookup, &amp;amp;dev-&amp;gt;dev, strict);
        if (rc) {
            of_node_put(child);
            break;
        }
    }
    of_node_set_flag(bus, OF_POPULATED_BUS);
    return rc;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总的来说，当of_platform_populate()函数执行完毕:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;kernel就为DTB中所有包含compatible属性名的第一级node创建platform_device结构体，并向平台设备总线注册设备信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果第一级node的compatible属性值等于“simple-bus”、“simple-mfd”或者”arm,amba-bus”的话，kernel会继续为当前node的第二级包含compatible属性的node创建platform_device结构体，并注册设备。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linux系统下的设备大多都是挂载在平台总线下的，因此在平台总线被注册后，会根据of_root节点的树结构，去寻找该总线的子节点，所有的子节点将被作为设备注册到该总线上。&lt;/p&gt;
&lt;h1 id=&#34;7-i2c_client和device_node绑定&#34;&gt;7. i2c_client和device_node绑定&lt;/h1&gt;
&lt;p&gt;经过customize_machine()函数的初始化，DTB已经转换成platform_device结构体，这其中就包含i2c adapter设备，不同的SoC需要通过平台设备总线的方式自己实现i2c adapter设备的驱动。例如：i2c_adapter驱动的probe函数中会调用i2c_add_numbered_adapter()注册adapter驱动，函数流执行如图9所示。
&lt;img src=&#34;https://strivefar.github.io/img/%E8%AE%BE%E5%A4%87%E6%A0%91/i2c.png&#34; alt=&#34;编译&#34;&gt;
在of_i2c_register_devices()函数内部便利i2c节点下面的每一个子节点，并为子节点（status = “disable”的除外）创建i2c_client结构体，并与子节点的device_node挂接。其中i2c_client的填充是在i2c_new_device()中进行的，最后device_register()。在构建i2c_client的时候，会对node下面的compatible属性名称的厂商名字去除作为i2c_client的name。例如：compatible = “maxim,ds1338”,则i2c_client-&amp;gt;name = “ds1338”。&lt;/p&gt;
&lt;h1 id=&#34;8-device_tree与sysfs&#34;&gt;8. Device_Tree与sysfs&lt;/h1&gt;
&lt;p&gt;kernel启动流程为start_kernel()→rest_init()→kernel_thread():kernel_init()→do_basic_setup()→driver_init()→of_core_init()，在of_core_init()函数中在sys/firmware/devicetree/base目录下面为设备树展开成sysfs的目录和二进制属性文件，所有的node节点就是一个目录，所有的property属性就是一个二进制属性文件。&lt;/p&gt;
&lt;h1 id=&#34;9-特此感谢&#34;&gt;9. 特此感谢&lt;/h1&gt;
&lt;p&gt;感谢原创作者的文章，文章图片表达清晰，代码注释详细，对我帮助很大。
————————————————
版权声明：本文为CSDN博主「smcdef」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/smcdef/article/details/77387975&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
