<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>youngfar | YoungFar的个人博客——Love&amp;Share</title>
    <link>https://strivefar.github.io/authors/youngfar/</link>
      <atom:link href="https://strivefar.github.io/authors/youngfar/index.xml" rel="self" type="application/rss+xml" />
    <description>youngfar</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><copyright>© 2005-2020版权所有[沪ICP备01234567号](http://www.beian.miit.gov.cn)</copyright><lastBuildDate>Sun, 05 Jul 2020 00:04:17 +0800</lastBuildDate>
    <image>
      <url>https://strivefar.github.io/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>youngfar</title>
      <link>https://strivefar.github.io/authors/youngfar/</link>
    </image>
    
    <item>
      <title>总线设备驱动模型</title>
      <link>https://strivefar.github.io/project/post/%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sun, 05 Jul 2020 00:04:17 +0800</pubDate>
      <guid>https://strivefar.github.io/project/post/%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;h2 id=&#34;总线设备驱动模型&#34;&gt;总线设备驱动模型&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://strivefar.github.io/img/%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B/LED%E6%80%BB%E7%BA%BF%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E9%80%9A%E7%94%A8%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6300%25.jpg&#34; alt=&#34;xmind&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>链表中为何使用二级指针或者一级指针的引用</title>
      <link>https://strivefar.github.io/project/post/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/</link>
      <pubDate>Fri, 05 Jun 2020 18:26:48 +0800</pubDate>
      <guid>https://strivefar.github.io/project/post/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;#&#34;&gt;前言&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;#&#34;&gt;参数的调用方式&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#&#34;&gt;传值调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#&#34;&gt;传址调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#&#34;&gt;传引用调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#&#34;&gt;示例说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;#&#34;&gt;使用二级指针/一级指针创建链表时的对比&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#&#34;&gt;主函数中作此调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#&#34;&gt;使用二级指针创建链表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#&#34;&gt;使用一级指针创建链表会成功吗&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;#&#34;&gt;销毁链表时二级指针和一级指针的对比&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#&#34;&gt;使用二级指针销毁链表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#&#34;&gt;使用一级指针销毁链表会成功吗&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;#&#34;&gt;总结&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;#&#34;&gt;完整代码&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;#&#34;&gt;参考来源&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;前言&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;在学习数据结构时，在链表初始化或者销毁链表的时候，经常使用二级指针或者一级指针的引用，这是为什么呢？同样是指向内存单元的地址，为什么就不能使用一级指针呢？使用一级指针去初始化或者是销毁链表的时候，究竟会发生什么呢？到底什么时候该用二级指针，什么时候该用一级指针？&lt;/p&gt;
&lt;p&gt;如果你对这些问题有疑问，可以参考本篇文章，以下是我个人对这些问题的理解，如有问题，欢迎随时联系我。&lt;/p&gt;
&lt;h1 id=&#34;参数的调用方式&#34;&gt;参数的调用方式&lt;/h1&gt;
&lt;p&gt;我们通常使用的函数调用方式无非两种，一种是&lt;strong&gt;传值调用&lt;/strong&gt;，一种是&lt;strong&gt;传址调用&lt;/strong&gt;。
谈起&lt;strong&gt;指针&lt;/strong&gt;我们可能瞬间就会把它和传址调用联系在一起，但实际上，&lt;strong&gt;对于指针来讲，它也存在着这两种调用方式，传值调用和传值调用&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;传值调用&#34;&gt;传值调用&lt;/h2&gt;
&lt;p&gt;传值调用是指在调用参数时,不是对原参数进行操作,而是创建参数的拷贝并对其进行操作,这种调用有利于保护数据。&lt;/p&gt;
&lt;h2 id=&#34;传址调用&#34;&gt;传址调用&lt;/h2&gt;
&lt;p&gt;传址调用的过程中把函数外部创建的变量的内存地址传递给函数参数，这种调用可以让函数和函数外边的变量建立起联系，函数内部可以直接操作函数外部；&lt;/p&gt;
&lt;h2 id=&#34;传引用调用&#34;&gt;传引用调用&lt;/h2&gt;
&lt;p&gt;适用于C++，不适用于C语言&lt;/p&gt;
&lt;h2 id=&#34;示例说明&#34;&gt;示例说明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;
传递一级指针变量本身等价于在传递指针变量的值，虽然有指针参与其中，但在函数内部，也只是创建了指针的copy，无非就是把传过来的实参的值给指针的copy用一用，并没有对实参（原指针变量）进行操作&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;    
#include &amp;lt;string.h&amp;gt;    
using namespace std;    
    
void fun1(char* str)    
{    
    str = new char[5];    
    strcpy (str, &amp;quot;test string&amp;quot;);    
}    
    
void fun2(char** str)    
{    
    *str = new char[5];    
    strcpy (*str, &amp;quot;test string&amp;quot;);    
}    
    
int main()    
{    
    char* s = NULL;        
    cout &amp;lt;&amp;lt; &amp;quot;call function fun1&amp;quot; &amp;lt;&amp;lt; endl;    
    fun1 (s);    
    if (!s)    
        cout &amp;lt;&amp;lt; &amp;quot;s is null!&amp;quot; &amp;lt;&amp;lt; endl;    
    else    
        cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;    
    
    cout &amp;lt;&amp;lt; &amp;quot;call function fun2&amp;quot; &amp;lt;&amp;lt; endl;    
    fun2 (&amp;amp;s);    
    if (!s)    
        cout &amp;lt;&amp;lt; &amp;quot;s is null!&amp;quot; &amp;lt;&amp;lt; endl;    
    else    
        cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;    
    return 0;    
}    
————————————————
版权声明：本文为CSDN博主「踏莎行hyx」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/u012234115/article/details/39717215
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出结果：
&lt;img src=&#34;https://strivefar.github.io/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png&#34; alt=&#34;wechat&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;使用二级指针一级指针创建链表时的对比&#34;&gt;使用二级指针/一级指针创建链表时的对比&lt;/h1&gt;
&lt;h2 id=&#34;主函数中作此调用&#34;&gt;主函数中作此调用&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;int main()
{
    LinkList L;
    ElemType e;
    Status i;
    int j, k;
    //InitList1(L);   //一级指针方式创建表头，失败
    InitList2(&amp;amp;L);  //二级指针方式创建表头，成功
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;使用二级指针创建链表&#34;&gt;使用二级指针创建链表&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//初始化表头，用二级指针
Status InitList2(LinkList *L) //等价于Node **L
{
    *L = (LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */
    if (!(*L))                           /* 存储分配失败 */
        return ERROR;
    (*L)-&amp;gt;next = NULL; /* 指针域为空 */

    return OK;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用图片说明更为直观：
&lt;strong&gt;函数内部可以直接操作函数外部&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://strivefar.github.io/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E5%88%9D%E5%A7%8B%E5%8C%96.png&#34; alt=&#34;wechat&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简明描述为：&lt;/strong&gt;
&lt;img src=&#34;https://strivefar.github.io/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E5%88%9B%E5%BB%BA%E9%93%BE%E8%A1%A8%E6%9C%89%E5%A4%B4%E7%BB%93%E7%82%B9%E7%9A%84%E6%A1%86%E5%9B%BE.png&#34; alt=&#34;wechat&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果没有头结点：&lt;/strong&gt;
![在这里插入图片描述]&lt;img src=&#34;https://strivefar.github.io/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E5%88%9B%E5%BB%BA%E9%93%BE%E8%A1%A8%E6%A1%86%E5%9B%BE.png&#34; alt=&#34;wechat&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;使用一级指针创建链表会成功吗&#34;&gt;使用一级指针创建链表会成功吗&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//初始化表头，用一级指针（此方式无效）
Status InitList1(LinkList L) //等价于Node *L
{
    L = (LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */
    if (!L)                             /* 存储分配失败 */
        return ERROR;
    L-&amp;gt;next = NULL; /* 指针域为空 */

    return OK;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用图片说明更为直观：
![在这里插入图片描述]&lt;img src=&#34;https://strivefar.github.io/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E5%88%9D%E5%A7%8B%E5%8C%96.png&#34; alt=&#34;wechat&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;很明显，把传过来的实参的值给指针的copy用一用，并没有对实参（原指针变量）进行操作&lt;/strong&gt;，这样创建的链表是毫无意义的，main.c后面再使用L时，用的依旧是个垃圾值，是有隐患的。&lt;/p&gt;
&lt;h1 id=&#34;销毁链表时二级指针和一级指针的对比&#34;&gt;销毁链表时二级指针和一级指针的对比&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;main.c中&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;printf(&amp;quot;销毁链表\n&amp;quot;);
//DestroyList1(L);   //一级指针方式销毁链表，失败,且出现满屏乱码
DestroyList2(&amp;amp;L);  //二级指针方式销毁链表，成功
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;使用二级指针销毁链表&#34;&gt;使用二级指针销毁链表&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//销毁链表，使用二级指针
Status DestroyList2(LinkList *L)
{
    LinkList p, q;
    p = (*L)-&amp;gt;next; /*  p指向第一个结点 */
    while (p)       /*  没到表尾 */
    {
        q = p-&amp;gt;next;
        free(p);
        p = q;
    }
    free(*L); //头结点彻底没有掉才是销毁
    *L = NULL;
    return OK;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用图片说明更为直观：&lt;/p&gt;
&lt;p&gt;![在这里插入图片描述]&lt;img src=&#34;https://strivefar.github.io/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8.png&#34; alt=&#34;wechat&#34;&gt;&lt;/p&gt;
&lt;p&gt;简单来说：
&lt;strong&gt;销毁链表就是让头指针为空，然后这个链表就彻底湮没在内存中了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;![在这里插入图片描述]&lt;img src=&#34;https://strivefar.github.io/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E9%94%80%E6%AF%81%E5%A4%B4%E7%BB%93%E7%82%B9%E6%A1%86%E5%9B%BE.png&#34; alt=&#34;wechat&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;使用一级指针销毁链表会成功吗&#34;&gt;使用一级指针销毁链表会成功吗&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//销毁链表，使用一级指针(此方式无效)
Status DestroyList1(LinkList L)
{
    LinkList p, q;
    p = L-&amp;gt;next; /*  p指向第一个结点 */
    while (p)    /*  没到表尾 */
    {
        q = p-&amp;gt;next;
        free(p);
        p = q;
    }
    free(L);
    L = NULL;
    return OK;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用图片说明更为直观：&lt;/p&gt;
&lt;p&gt;![在这里插入图片描述]&lt;img src=&#34;https://strivefar.github.io/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%88%96%E8%80%85%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8/%E4%BD%BF%E7%94%A8%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8.png&#34; alt=&#34;wechat&#34;&gt;
可见这种方式的确很危险，实际测试中也的确出现了乱码&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;1.初始化链表头部指针需要用二级指针或者一级指针的引用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.销毁链表需要用到二级指针或者一级指针的引用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.插入、删除、遍历、清空结点用一级指针即可。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;完整代码&#34;&gt;完整代码&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;quot;stdio.h&amp;quot;
#include &amp;quot;stdlib.h&amp;quot;
#include &amp;quot;time.h&amp;quot;
#define OK 1
#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 20    /* 存储空间初始分配量 */
typedef int Status;   /* Status是函数的类型,其值是函数结果状态代码，如OK等 */
typedef int ElemType; /* ElemType类型根据实际情况而定，这里假设为int */
Status visit(ElemType c)
{
    printf(&amp;quot;%d &amp;quot;, c);
    return OK;
}
typedef struct Node
{
    ElemType data;
    struct Node *next;
} Node;
typedef struct Node *LinkList; /* 定义LinkList */

//初始化表头，用一级指针（此方式无效）
Status InitList1(LinkList L) //等价于Node *L
{
    L = (LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */
    if (!L)                             /* 存储分配失败 */
        return ERROR;
    L-&amp;gt;next = NULL; /* 指针域为空 */

    return OK;
}

//初始化表头，用二级指针
Status InitList2(LinkList *L) //等价于Node **L
{
    *L = (LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */
    if (!(*L))                           /* 存储分配失败 */
        return ERROR;
    (*L)-&amp;gt;next = NULL; /* 指针域为空 */

    return OK;
}

//初始化表头，用一级指针引用
Status InitList3(LinkList &amp;amp;L) //等价于Node *&amp;amp;L
{
    L = (LinkList)malloc(sizeof(Node)); /* 产生头结点,并使L指向此头结点 */
    if (!L)                             /* 存储分配失败 */
        return ERROR;
    L-&amp;gt;next = NULL; /* 指针域为空 */

    return OK;
}

//清空链表，使用二级指针
Status ClearList1(LinkList *L)
{
    LinkList p, q;
    p = (*L)-&amp;gt;next; /*  p指向第一个结点 */
    while (p)       /*  没到表尾 */
    {
        q = p-&amp;gt;next;
        free(p);
        p = q;
    }
    (*L)-&amp;gt;next = NULL; /* 头结点指针域为空 */
    return OK;
}

//清空链表，使用一级指针
Status ClearList2(LinkList L)
{
    LinkList p, q;
    p = L-&amp;gt;next; /*  p指向(这里的第一个结点只头结点) */
    while (p)    /*  没到表尾 */
    {
        q = p-&amp;gt;next;
        free(p);
        p = q;
    }
    L-&amp;gt;next = NULL; /* 头结点指针域为空 */
    return OK;
}

//销毁链表，使用一级指针(此方式无效)
Status DestroyList1(LinkList L)
{
    LinkList p, q;
    p = L-&amp;gt;next; /*  p指向第一个结点 */
    while (p)    /*  没到表尾 */
    {
        q = p-&amp;gt;next;
        free(p);
        p = q;
    }
    free(L);
    L = NULL;
    return OK;
}

//销毁链表，使用二级指针
Status DestroyList2(LinkList *L)
{
    LinkList p, q;
    p = (*L)-&amp;gt;next; /* p指向头结点(第一个结点) */
    while (p)       /*  没到表尾 */
    {
        q = p-&amp;gt;next;
        free(p);
        p = q;
    }
    free(*L); //头结点彻底没有掉才是销毁
    *L = NULL;
    return OK;
}

//销毁链表，使用一级指针引用
Status DestroyList3(LinkList &amp;amp;L)
{
    LinkList p, q;
    p = L-&amp;gt;next; /*  p指向第一个结点 */
    while (p)    /*  没到表尾 */
    {
        q = p-&amp;gt;next;
        free(p);
        p = q;
    }
    free(L);
    L = NULL;
    return OK;
}
/* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
/* 操作结果：用e返回L中第i个数据元素的值 */
Status GetElem(LinkList L, int i, ElemType *e)
{
    int j;
    LinkList p;        /* 声明一结点p */
    p = L-&amp;gt;next;       /* 让p指向链表L的第一个结点 */
    j = 1;             /*  j为计数器 */
    while (p &amp;amp;&amp;amp; j &amp;lt; i) /* p不为空或者计数器j还没有等于i时，循环继续 */
    {
        p = p-&amp;gt;next; /* 让p指向下一个结点 */
        ++j;
    }
    if (!p || j &amp;gt; i)
        return ERROR; /*  第i个元素不存在 */
    *e = p-&amp;gt;data;     /*  取第i个元素的数据 */
    return OK;
}

//在中间插入元素，用二级指针
Status ListInsert1(LinkList *L, int i, ElemType e)
{
    int j;
    LinkList p, s;
    p = *L;
    j = 1;
    while (p &amp;amp;&amp;amp; j &amp;lt; i) /* 寻找第i个结点 */
    {
        p = p-&amp;gt;next;
        ++j;
    }
    if (!p || j &amp;gt; i)
        return ERROR;                   /* 第i个元素不存在 */
    s = (LinkList)malloc(sizeof(Node)); /*  生成新结点(C语言标准函数) */
    s-&amp;gt;data = e;
    s-&amp;gt;next = p-&amp;gt;next; /* 将p的后继结点赋值给s的后继  */
    p-&amp;gt;next = s;       /* 将s赋值给p的后继 */
    return OK;
}
//在中间插入元素，用一级指针
Status ListInsert2(LinkList L, int i, ElemType e)
{
    int j;
    LinkList p, s;
    p = L;
    j = 1;
    while (p &amp;amp;&amp;amp; j &amp;lt; i) /* 寻找第i个结点 */
    {
        p = p-&amp;gt;next;
        ++j;
    }
    if (!p || j &amp;gt; i)
        return ERROR;                   /* 第i个元素不存在 */
    s = (LinkList)malloc(sizeof(Node)); /*  生成新结点(C语言标准函数) */
    s-&amp;gt;data = e;
    s-&amp;gt;next = p-&amp;gt;next; /* 将p的后继结点赋值给s的后继  */
    p-&amp;gt;next = s;       /* 将s赋值给p的后继 */
    return OK;
}
//删除一个元素，用二级指针
Status ListDelete1(LinkList *L, int i, ElemType *e)
{
    int j;
    LinkList p, q;
    p = *L;
    j = 1;
    while (p-&amp;gt;next &amp;amp;&amp;amp; j &amp;lt; i) /* 遍历寻找第i个元素 */
    {
        p = p-&amp;gt;next;
        ++j;
    }
    if (!(p-&amp;gt;next) || j &amp;gt; i)
        return ERROR; /* 第i个元素不存在 */
    q = p-&amp;gt;next;
    p-&amp;gt;next = q-&amp;gt;next; /* 将q的后继赋值给p的后继 */
    *e = q-&amp;gt;data;      /* 将q结点中的数据给e */
    free(q);           /* 让系统回收此结点，释放内存 */
    return OK;
}
//删除一个元素，用一级指针
Status ListDelete2(LinkList L, int i, ElemType *e)
{
    int j;
    LinkList p, q;
    p = L;
    j = 1;
    while (p-&amp;gt;next &amp;amp;&amp;amp; j &amp;lt; i) /* 遍历寻找第i个元素 */
    {
        p = p-&amp;gt;next;
        ++j;
    }
    if (!(p-&amp;gt;next) || j &amp;gt; i)
        return ERROR; /* 第i个元素不存在 */
    q = p-&amp;gt;next;
    p-&amp;gt;next = q-&amp;gt;next; /* 将q的后继赋值给p的后继 */
    *e = q-&amp;gt;data;      /* 将q结点中的数据给e */
    free(q);           /* 让系统回收此结点，释放内存 */
    return OK;
}
/* 初始条件：顺序线性表L已存在 */
/* 操作结果：依次对L的每个数据元素输出 */
Status ListTraverse(LinkList L)
{
    LinkList p = L-&amp;gt;next;
    while (p)
    {
        visit(p-&amp;gt;data);
        p = p-&amp;gt;next;
    }
    printf(&amp;quot;\n&amp;quot;);
    return OK;
}
int main()
{
    LinkList L;
    ElemType e;
    Status i;
    int j, k;
    //InitList1(L);   //一级指针方式创建表头，失败
    //InitList2(&amp;amp;L);  //二级指针方式创建表头，成功
    InitList3(L); //一级指针引用方式创建表头，成功
    for (j = 1; j &amp;lt;= 7; j++)
        ListInsert2(L, 1, j);
    printf(&amp;quot;一级指针方式在L的表头依次插入1～7后：&amp;quot;);
    ListTraverse(L);

    ListInsert1(&amp;amp;L, 3, 12);
    printf(&amp;quot;二级指针方式在L的中间插入12后：&amp;quot;);
    ListTraverse(L);

    ListInsert2(L, 5, 27);
    printf(&amp;quot;一级指针在L的中间插入27后：&amp;quot;);
    ListTraverse(L);

    GetElem(L, 5, &amp;amp;e);
    printf(&amp;quot;第5个元素的值为：%d\n&amp;quot;, e);

    ListDelete1(&amp;amp;L, 5, &amp;amp;e); /* 删除第5个数据 */
    printf(&amp;quot;二级指针方式删除第%d个的元素值为：%d\n&amp;quot;, 5, e);
    printf(&amp;quot;依次输出L的元素：&amp;quot;);
    ListTraverse(L);

    ListDelete2(L, 3, &amp;amp;e); /* 删除第3个数据 */
    printf(&amp;quot;一级指针方式删除第%d个的元素值为：%d\n&amp;quot;, 3, e);
    printf(&amp;quot;依次输出L的元素：&amp;quot;);
    ListTraverse(L);

    printf(&amp;quot;二级指针方式清空链表\n&amp;quot;);
    ClearList1(&amp;amp;L);
    printf(&amp;quot;依次输出L的元素：&amp;quot;);
    ListTraverse(L);

    for (j = 1; j &amp;lt;= 7; j++)
        ListInsert2(L, j, j);
    printf(&amp;quot;在L的表尾依次插入1～7后：&amp;quot;);
    ListTraverse(L);

    printf(&amp;quot;一级指针方式清空链表\n&amp;quot;);
    ClearList2(L);
    printf(&amp;quot;依次输出L的元素：&amp;quot;);
    ListTraverse(L);

    printf(&amp;quot;销毁链表\n&amp;quot;);
    //DestroyList1(L);   //一级指针方式销毁链表，失败,且出现满屏乱码
    DestroyList2(&amp;amp;L); //二级指针方式销毁链表，成功
    DestroyList3(L);  //一级指针引用方式销毁链表，成功

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;参考来源&#34;&gt;参考来源&lt;/h1&gt;
&lt;p&gt;本文参考了以下博文，结合自己的理解，总结记录了相关知识，特此感谢
&lt;a href=&#34;https://blog.csdn.net/u012234115/article/details/39717215&#34;&gt;https://blog.csdn.net/u012234115/article/details/39717215&lt;/a&gt;
&lt;a href=&#34;https://blog.csdn.net/DX_Jone/article/details/102817995&#34;&gt;https://blog.csdn.net/DX_Jone/article/details/102817995&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>动态编译和静态编译——制作动态库和静态库</title>
      <link>https://strivefar.github.io/project/post/getting-started/</link>
      <pubDate>Wed, 13 May 2020 00:00:00 +0000</pubDate>
      <guid>https://strivefar.github.io/project/post/getting-started/</guid>
      <description>&lt;h1 id=&#34;参考链接&#34;&gt;参考链接&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;http://c.biancheng.net/view/2385.html&#34;&gt;GCC生成动态链接库（.so文件）：-shared和-fPIC选项&lt;/a&gt;
&lt;a href=&#34;http://c.biancheng.net/view/7168.html&#34;&gt;GCC创建和使用静态链接库（.a文件）&lt;/a&gt;
&lt;a href=&#34;https://www.bilibili.com/video/BV1ZT4y137Ba?from=search&amp;amp;seid=5456022104877118795&#34;&gt;gcc的使用方法；动态编译和静态编译；Linux制作动态库和静态库&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;命名规则&#34;&gt;命名规则&lt;/h1&gt;
&lt;p&gt;静态库命名规则如下：
&lt;strong&gt;libxxx.o&lt;/strong&gt;
&lt;strong&gt;lib&lt;/strong&gt;:前缀
&lt;strong&gt;.o&lt;/strong&gt;:静态库
动态链接库（shared object file，共享对象文件）命名规则如下：
&lt;strong&gt;libxxx.so&lt;/strong&gt;
&lt;strong&gt;lib&lt;/strong&gt;:前缀
&lt;strong&gt;.so&lt;/strong&gt;:动态库&lt;/p&gt;
&lt;h1 id=&#34;静态库参数&#34;&gt;静态库参数&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503195703920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;gcc-常用编译选项&#34;&gt;gcc 常用编译选项&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503200518148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;动态库和静态库的对比&#34;&gt;动态库和静态库的对比&lt;/h1&gt;
&lt;p&gt;我们先来说一下静态库；
Linux下的静态库是以.a结尾的二进制文件，它作为一个程序的模块，它在链接期间就被组合到了程序中，比如说我有一个主程序mian.c，那么我把它和静态库链接的时候，它就直接把这个静态库组合到了我的main.c里面生成的一个二进制文件.a。
而与静态链接库相对的是动态链接库，同样的是把主函数mian.c和动态库进行链接，与静态库不同的是,这个动态库在程序运行的阶段才会被加载进内存,参与主函数运行
下面用几张图来说明一下：
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503132421885.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503195153959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;tr&gt;&lt;td bgcolor=orange&gt;还可以加上-static选项，让链接静态库后的math.out彻底的独立起来，“完全静态”&lt;/td&gt;&lt;/tr&gt;，因此，得到的二进制文件会非常大。
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503133250379.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503133154266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503132624143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;使用静态动态链接库的优缺点&#34;&gt;使用静态/动态链接库的优缺点：&lt;/h1&gt;
&lt;h3 id=&#34;静态库&#34;&gt;静态库：&lt;/h3&gt;
&lt;p&gt;编译后的执行程序不需要外部的函数库支持，&lt;strong&gt;因为所有使用的函数都经被编译进去了&lt;/strong&gt;。当然这也会成为他的缺点，因为如果&lt;strong&gt;静态函数库改变&lt;/strong&gt;了，那么你的程序必须&lt;strong&gt;重新编译&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;静态库的代码在编译时链接到应用程序中，因此&lt;strong&gt;编译时库文件必须存在并且需要通过“-L”参数传递给编译器&lt;/strong&gt;，应用程序在开始执行时，库函数代码将随程序一 起调入进程内存段直到进程结束，其执行过程不需要原静态库存在。&lt;/p&gt;
&lt;h3 id=&#34;动态库&#34;&gt;动态库：&lt;/h3&gt;
&lt;p&gt;动态函数库在编译的时候&lt;strong&gt;并没有&lt;/strong&gt;被编译进目标代码中，你的程序&lt;strong&gt;执行到相关函数时才调用该函数库里的相应函数&lt;/strong&gt;，因此动态函数库所产生的可执行文件比较&lt;strong&gt;小&lt;/strong&gt;。由于函数库没有被整合进你的程序，而是程序运行时动态的申请并调用，所以程序的&lt;strong&gt;运行环境中必须提供相应的库&lt;/strong&gt;。动态函数库的改变并不影响你的程序，所以动态函数库的&lt;strong&gt;升级比较方便&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不同的INIX系统链接动态库方法，实现细节不一样，编译PIC型.o中间文件的方法一般是采用C语言编译器的-KPIC或者 -fPIC选项
&lt;strong&gt;最主要的是GCC命令行的一个选项:&lt;/strong&gt;
&lt;strong&gt;-shared&lt;/strong&gt;:该选项指定&lt;strong&gt;生成动态连接库&lt;/strong&gt;(让连接器生成T类型的导出符号表，有时候也生成弱连接W类
型的导出符号) ,不用该标志外部程序无法连接。相当于一个可执行文件
&lt;strong&gt;-fPIC&lt;/strong&gt;:表示编译为&lt;strong&gt;位置独立&lt;/strong&gt;的代码，不用此选项的话编译后的代码是位置相关的,所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。&lt;/p&gt;
&lt;h1 id=&#34;制作链接库的目的商业角度&#34;&gt;制作链接库的目的（商业角度）：&lt;/h1&gt;
&lt;p&gt;这就和&lt;strong&gt;商业&lt;/strong&gt;项目挂钩了:
假如我们是一个项目的外包方，我们是有专利的，&lt;strong&gt;希望别人使用我们已经实现的功能，但又不希望别人看到我们的源代码&lt;/strong&gt;，所以这对商业机构是非常友好的。&lt;/p&gt;
&lt;h1 id=&#34;makefile中的使用实例&#34;&gt;Makefile中的使用实例：&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503143928633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20200503144212953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4ODE2ODcz,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
